,id,title,description,is_premium,solution_link,acceptance_rate,frequency,url,discuss_count,accepted,submissions,companies,related_topics,likes,dislikes,rating,asked_by_faang,similar_questions
0,4,Median of Two Sorted Arrays,"Given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return the median of the two sorted arrays.


Example 1:
Input: nums1 = [1,3], nums2 = [2]
Output: 2.00000
Explanation: merged array = [1,2,3] and median is 2.


Example 2:
Input: nums1 = [1,2], nums2 = [3,4]
Output: 2.50000
Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.


Example 3:
Input: nums1 = [0,0], nums2 = [0,0]
Output: 0.00000

Example 4:
Input: nums1 = [], nums2 = [1]
Output: 1.00000

Example 5:
Input: nums1 = [2], nums2 = []
Output: 2.00000

Constraints:
`nums1.length == m`
`nums2.length == n`
`0 <= m <= 1000`
`0 <= n <= 1000`
`1 <= m + n <= 2000`
`-106 <= nums1[i], nums2[i] <= 106`
Follow up: The overall run time complexity should be `O(log (m+n))`.",0,/articles/median-of-two-sorted-arrays,31.4,86.2,https://leetcode.com/problems/median-of-two-sorted-arrays,999,904.7K,2.9M,"Amazon,Goldman Sachs,Facebook,Microsoft,Apple,Adobe,Google,Bloomberg,Zillow,Uber,Flipkart,Paypal","Array,Binary Search,Divide and Conquer",9665,1486,87,1,
1,10,Regular Expression Matching,"Given an input string (`s`) and a pattern (`p`), implement regular expression matching with support for `'.'` and `'*'` where:` `
`'.'` Matches any single character.​​​​
`'*'` Matches zero or more of the preceding element.

The matching should cover the entire input string (not partial).


Example 1:
Input: s = ""aa"", p = ""a""
Output: false
Explanation: ""a"" does not match the entire string ""aa"".


Example 2:
Input: s = ""aa"", p = ""a*""
Output: true
Explanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes ""aa"".


Example 3:
Input: s = ""ab"", p = "".*""
Output: true
Explanation: "".*"" means ""zero or more (*) of any character (.)"".


Example 4:
Input: s = ""aab"", p = ""c*a*b""
Output: true
Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches ""aab"".


Example 5:
Input: s = ""mississippi"", p = ""mis*is*p*.""
Output: false

Constraints:
`0 <= s.length <= 20`
`0 <= p.length <= 30`
`s` contains only lowercase English letters.

`p` contains only lowercase English letters, `'.'`, and `'*'`.

It is guaranteed for each appearance of the character `'*'`, there will be a previous valid character to match.",0,/articles/regular-expression-matching,27.4,75.0,https://leetcode.com/problems/regular-expression-matching,999,526.6K,1.9M,"Facebook,Amazon,Microsoft,Google,Adobe,Coursera,Apple","String,Dynamic Programming,Backtracking",5583,841,87,1,"[Wildcard Matching, /problems/wildcard-matching/, Hard]"
2,23,Merge k Sorted Lists,"You are given an array of `k` linked-lists `lists`, each linked-list is sorted in ascending order.

Merge all the linked-lists into one sorted linked-list and return it.


Example 1:
Input: lists = [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]
Explanation: The linked-lists are:
[
  1->4->5,
  1->3->4,
  2->6
]
merging them into one sorted list:
1->1->2->3->4->4->5->6

Example 2:
Input: lists = []
Output: []

Example 3:
Input: lists = [[]]
Output: []

Constraints:
`k == lists.length`
`0 <= k <= 10^4`
`0 <= lists[i].length <= 500`
`-10^4 <= lists[i][j] <= 10^4`
`lists[i]` is sorted in ascending order.

The sum of `lists[i].length` won't exceed `10^4`.",0,/articles/merge-k-sorted-list,43.0,83.2,https://leetcode.com/problems/merge-k-sorted-lists,999,856.1K,2M,"Amazon,Facebook,Microsoft,Bloomberg,Apple,Oracle,Databricks,Google,Twitter,Uber,Adobe,Wish,ByteDance,Palantir Technologies,Tesla","Linked List,Divide and Conquer,Heap",6892,349,95,1,"[Merge Two Sorted Lists, /problems/merge-two-sorted-lists/, Easy], [Ugly Number II, /problems/ugly-number-ii/, Medium]"
3,25,Reverse Nodes in k-Group,"Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.

k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.

Follow up:
Could you solve the problem in `O(1)` extra memory space?
You may not alter the values in the list's nodes, only nodes itself may be changed.


Example 1:
Input: head = [1,2,3,4,5], k = 2
Output: [2,1,4,3,5]

Example 2:
Input: head = [1,2,3,4,5], k = 3
Output: [3,2,1,4,5]

Example 3:
Input: head = [1,2,3,4,5], k = 1
Output: [1,2,3,4,5]

Example 4:
Input: head = [1], k = 1
Output: [1]

Constraints:
The number of nodes in the list is in the range `sz`.

`1 <= sz <= 5000`
`0 <= Node.val <= 1000`
`1 <= k <= sz`",0,/articles/reverse-nodes-in-k-group,45.3,69.1,https://leetcode.com/problems/reverse-nodes-in-k-group,999,341.1K,752.3K,"Amazon,Microsoft,Apple,ByteDance,Facebook,Google",Linked List,3490,400,90,1,"[Swap Nodes in Pairs, /problems/swap-nodes-in-pairs/, Medium], [Swapping Nodes in a Linked List, /problems/swapping-nodes-in-a-linked-list/, Medium]"
4,30,Substring with Concatenation of All Words,"You are given a string `s` and an array of strings `words` of the same length. Return all starting indices of substring(s) in `s` that is a concatenation of each word in `words` exactly once, in any order, and without any intervening characters.

You can return the answer in any order.


Example 1:
Input: s = ""barfoothefoobarman"", words = [""foo"",""bar""]
Output: [0,9]
Explanation: Substrings starting at index 0 and 9 are ""barfoo"" and ""foobar"" respectively.

The output order does not matter, returning [9,0] is fine too.


Example 2:
Input: s = ""wordgoodgoodgoodbestword"", words = [""word"",""good"",""best"",""word""]
Output: []

Example 3:
Input: s = ""barfoofoobarthefoobarman"", words = [""bar"",""foo"",""the""]
Output: [6,9,12]

Constraints:
`1 <= s.length <= 104`
`s` consists of lower-case English letters.

`1 <= words.length <= 5000`
`1 <= words[i].length <= 30`
`words[i]` consists of lower-case English letters.",0,,26.4,31.0,https://leetcode.com/problems/substring-with-concatenation-of-all-words,732,203K,770K,"Amazon,Adobe","Hash Table,Two Pointers,String",1209,1455,45,1,"[Minimum Window Substring, /problems/minimum-window-substring/, Hard]"
5,32,Longest Valid Parentheses,"Given a string containing just the characters `'('` and `')'`, find the length of the longest valid (well-formed) parentheses substring.


Example 1:
Input: s = ""(()""
Output: 2
Explanation: The longest valid parentheses substring is ""()"".


Example 2:
Input: s = "")()())""
Output: 4
Explanation: The longest valid parentheses substring is ""()()"".


Example 3:
Input: s = """"
Output: 0

Constraints:
`0 <= s.length <= 3 * 104`
`s[i]` is `'('`, or `')'`.",0,/articles/longest-valid-parentheses,29.9,24.5,https://leetcode.com/problems/longest-valid-parentheses,999,366.3K,1.2M,"Amazon,Facebook,Apple,ByteDance","String,Dynamic Programming",5015,182,96,1,"[Valid Parentheses, /problems/valid-parentheses/, Easy]"
6,37,Sudoku Solver,"Write a program to solve a Sudoku puzzle by filling the empty cells.

A sudoku solution must satisfy all of the following rules:
Each of the digits `1-9` must occur exactly once in each row.

Each of the digits `1-9` must occur exactly once in each column.

Each of the digits `1-9` must occur exactly once in each of the 9 `3x3` sub-boxes of the grid.

The `'.'` character indicates empty cells.


Example 1:
Input: board = [[""5"",""3"",""."",""."",""7"",""."",""."",""."","".""],[""6"",""."",""."",""1"",""9"",""5"",""."",""."","".""],[""."",""9"",""8"",""."",""."",""."",""."",""6"","".""],[""8"",""."",""."",""."",""6"",""."",""."",""."",""3""],[""4"",""."",""."",""8"",""."",""3"",""."",""."",""1""],[""7"",""."",""."",""."",""2"",""."",""."",""."",""6""],[""."",""6"",""."",""."",""."",""."",""2"",""8"","".""],[""."",""."",""."",""4"",""1"",""9"",""."",""."",""5""],[""."",""."",""."",""."",""8"",""."",""."",""7"",""9""]]
Output: [[""5"",""3"",""4"",""6"",""7"",""8"",""9"",""1"",""2""],[""6"",""7"",""2"",""1"",""9"",""5"",""3"",""4"",""8""],[""1"",""9"",""8"",""3"",""4"",""2"",""5"",""6"",""7""],[""8"",""5"",""9"",""7"",""6"",""1"",""4"",""2"",""3""],[""4"",""2"",""6"",""8"",""5"",""3"",""7"",""9"",""1""],[""7"",""1"",""3"",""9"",""2"",""4"",""8"",""5"",""6""],[""9"",""6"",""1"",""5"",""3"",""7"",""2"",""8"",""4""],[""2"",""8"",""7"",""4"",""1"",""9"",""6"",""3"",""5""],[""3"",""4"",""5"",""2"",""8"",""6"",""1"",""7"",""9""]]
Explanation: The input board is shown above and the only valid solution is shown below:

Constraints:
`board.length == 9`
`board[i].length == 9`
`board[i][j]` is a digit or `'.'`.

It is guaranteed that the input board has only one solution.",0,/articles/sudoku-solver,47.0,67.6,https://leetcode.com/problems/sudoku-solver,999,231.5K,492.2K,"DoorDash,Amazon,Oracle,Pinterest,Facebook,Intuit","Hash Table,Backtracking",2662,104,96,1,"[Valid Sudoku, /problems/valid-sudoku/, Medium], [Unique Paths III, /problems/unique-paths-iii/, Hard]"
7,41,First Missing Positive,"Given an unsorted integer array `nums`, find the smallest missing positive integer.


Example 1:
Input: nums = [1,2,0]
Output: 3

Example 2:
Input: nums = [3,4,-1,1]
Output: 2

Example 3:
Input: nums = [7,8,9,11,12]
Output: 1

Constraints:
`0 <= nums.length <= 300`
`-231 <= nums[i] <= 231 - 1`
Follow up: Could you implement an algorithm that runs in `O(n)` time and uses constant extra space?",0,/articles/first-missing-positive,33.9,77.3,https://leetcode.com/problems/first-missing-positive,999,466.2K,1.4M,"Microsoft,Amazon,Facebook,Google,Oracle,Adobe,Bloomberg,Wish,Uber,Apple,Walmart Labs,Tesla,JPMorgan",Array,5504,970,85,1,"[Missing Number, /problems/missing-number/, Easy], [Find the Duplicate Number, /problems/find-the-duplicate-number/, Medium], [Find All Numbers Disappeared in an Array, /problems/find-all-numbers-disappeared-in-an-array/, Easy], [Couples Holding Hands, /problems/couples-holding-hands/, Hard]"
8,42,Trapping Rain Water,"Given `n` non-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it can trap after raining.


Example 1:
Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6
Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.


Example 2:
Input: height = [4,2,0,3,2,5]
Output: 9

Constraints:
`n == height.length`
`0 <= n <= 3 * 104`
`0 <= height[i] <= 105`",0,/articles/trapping-rain-water,51.6,96.3,https://leetcode.com/problems/trapping-rain-water,999,715K,1.4M,"Goldman Sachs,Facebook,Amazon,Microsoft,Bloomberg,Apple,Databricks,Google,Qualtrics,Adobe,Oracle,Yahoo","Array,Two Pointers,Dynamic Programming,Stack",10683,159,99,1,"[Container With Most Water, /problems/container-with-most-water/, Medium], [Product of Array Except Self, /problems/product-of-array-except-self/, Medium], [Trapping Rain Water II, /problems/trapping-rain-water-ii/, Hard], [Pour Water, /problems/pour-water/, Medium]"
9,44,Wildcard Matching,"Given an input string (`s`) and a pattern (`p`), implement wildcard pattern matching with support for `'?'` and `'*'` where:
`'?'` Matches any single character.

`'*'` Matches any sequence of characters (including the empty sequence).

The matching should cover the entire input string (not partial).


Example 1:
Input: s = ""aa"", p = ""a""
Output: false
Explanation: ""a"" does not match the entire string ""aa"".


Example 2:
Input: s = ""aa"", p = ""*""
Output: true
Explanation: '*' matches any sequence.


Example 3:
Input: s = ""cb"", p = ""?a""
Output: false
Explanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.


Example 4:
Input: s = ""adceb"", p = ""*a*b""
Output: true
Explanation: The first '*' matches the empty sequence, while the second '*' matches the substring ""dce"".


Example 5:
Input: s = ""acdcb"", p = ""a*c?b""
Output: false

Constraints:
`0 <= s.length, p.length <= 2000`
`s` contains only lowercase English letters.

`p` contains only lowercase English letters, `'?'` or `'*'`.",0,/articles/wildcard-matching,25.5,59.0,https://leetcode.com/problems/wildcard-matching,823,296.2K,1.2M,"Adobe,Amazon,Citadel,Facebook,Microsoft,Google,Bloomberg,Snapchat","String,Dynamic Programming,Backtracking,Greedy",2848,139,95,1,"[Regular Expression Matching, /problems/regular-expression-matching/, Hard]"
10,51,N-Queens,"The n-queens puzzle is the problem of placing `n` queens on an `n x n` chessboard such that no two queens attack each other.

Given an integer `n`, return all distinct solutions to the n-queens puzzle.

Each solution contains a distinct board configuration of the n-queens' placement, where `'Q'` and `'.'` both indicate a queen and an empty space, respectively.


Example 1:
Input: n = 4
Output: [["".Q.."",""...Q"",""Q..."",""..Q.""],[""..Q."",""Q..."",""...Q"","".Q..""]]
Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above

Example 2:
Input: n = 1
Output: [[""Q""]]

Constraints:
`1 <= n <= 9`",0,/articles/n-queens,50.2,60.1,https://leetcode.com/problems/n-queens,999,248.4K,495.2K,"Facebook,Microsoft,Amazon,ByteDance,Apple,Adobe",Backtracking,2803,102,96,1,"[N-Queens II, /problems/n-queens-ii/, Hard], [Grid Illumination, /problems/grid-illumination/, Hard]"
11,52,N-Queens II,"The n-queens puzzle is the problem of placing `n` queens on an `n x n` chessboard such that no two queens attack each other.

Given an integer `n`, return the number of distinct solutions to the n-queens puzzle.


Example 1:
Input: n = 4
Output: 2
Explanation: There are two distinct solutions to the 4-queens puzzle as shown.


Example 2:
Input: n = 1
Output: 1

Constraints:
`1 <= n <= 9`",0,/articles/n-queens-ii,60.5,13.7,https://leetcode.com/problems/n-queens-ii,643,158.9K,262.4K,"Amazon,Zenefits",Backtracking,790,181,81,1,"[N-Queens, /problems/n-queens/, Hard]"
12,60,Permutation Sequence,"The set `[1, 2, 3, ..., n]` contains a total of `n!` unique permutations.

By listing and labeling all of the permutations in order, we get the following sequence for `n = 3`:
`""123""`
`""132""`
`""213""`
`""231""`
`""312""`
`""321""`
Given `n` and `k`, return the `kth` permutation sequence.


Example 1:
Input: n = 3, k = 3
Output: ""213""

Example 2:
Input: n = 4, k = 9
Output: ""2314""

Example 3:
Input: n = 3, k = 1
Output: ""123""

Constraints:
`1 <= n <= 9`
`1 <= k <= n!`",0,/articles/permutation-sequence,39.5,24.1,https://leetcode.com/problems/permutation-sequence,999,223K,563.9K,"Amazon,Adobe","Math,Backtracking",2152,361,86,1,"[Next Permutation, /problems/next-permutation/, Medium], [Permutations, /problems/permutations/, Medium]"
13,65,Valid Number,"A valid number can be split up into these components (in order):
A decimal number or an integer.

(Optional) An `'e'` or `'E'`, followed by an integer.

A decimal number can be split up into these components (in order):
(Optional) A sign character (either `'+'` or `'-'`).

One of the following formats:
	
At least one digit, followed by a dot `'.'`.

At least one digit, followed by a dot `'.'`, followed by at least one digit.

A dot `'.'`, followed by at least one digit.

An integer can be split up into these components (in order):
(Optional) A sign character (either `'+'` or `'-'`).

At least one digit.

For example, all the following are valid numbers: `[""2"", ""0089"", ""-0.1"", ""+3.14"", ""4."", ""-.9"", ""2e10"", ""-90E3"", ""3e+7"", ""+6e-1"", ""53.5e93"", ""-123.456e789""]`, while the following are not valid numbers: `[""abc"", ""1a"", ""1e"", ""e3"", ""99e2.5"", ""--6"", ""-+3"", ""95a54e53""]`.

Given a string `s`, return `true` if `s` is a valid number.


Example 1:
Input: s = ""0""
Output: true

Example 2:
Input: s = ""e""
Output: false

Example 3:
Input: s = "".""
Output: false

Example 4:
Input: s = "".1""
Output: true

Constraints:
`1 <= s.length <= 20`
`s` consists of only English letters (both uppercase and lowercase), digits (`0-9`), plus `'+'`, minus `'-'`, or dot `'.'`.",0,,16.0,54.1,https://leetcode.com/problems/valid-number,999,199.5K,1.2M,"Facebook,LinkedIn,Oracle,Twitch","Math,String",902,5572,14,1,"[String to Integer (atoi), /problems/string-to-integer-atoi/, Medium]"
14,68,Text Justification,"Given an array of words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.

You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces `' '` when necessary so that each line has exactly maxWidth characters.

Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.

For the last line of text, it should be left justified and no extra space is inserted between words.

Note:
A word is defined as a character sequence consisting of non-space characters only.

Each word's length is guaranteed to be greater than 0 and not exceed maxWidth.

The input array `words` contains at least one word.


Example 1:
Input: words = [""This"", ""is"", ""an"", ""example"", ""of"", ""text"", ""justification.""], maxWidth = 16
Output:
[
   ""This    is    an"",
   ""example  of text"",
   ""justification.  ""
]

Example 2:
Input: words = [""What"",""must"",""be"",""acknowledgment"",""shall"",""be""], maxWidth = 16
Output:
[
  ""What   must   be"",
  ""acknowledgment  "",
  ""shall be        ""
]
Explanation: Note that the last line is ""shall be    "" instead of ""shall     be"", because the last line must be left-justified instead of fully-justified.

Note that the second line is also left-justified becase it contains only one word.


Example 3:
Input: words = [""Science"",""is"",""what"",""we"",""understand"",""well"",""enough"",""to"",""explain"",""to"",""a"",""computer."",""Art"",""is"",""everything"",""else"",""we"",""do""], maxWidth = 20
Output:
[
  ""Science  is  what we"",
  ""understand      well"",
  ""enough to explain to"",
  ""a  computer.  Art is"",
  ""everything  else  we"",
  ""do                  ""
]

Constraints:
`1 <= words.length <= 300`
`1 <= words[i].length <= 20`
`words[i]` consists of only English letters and symbols.

`1 <= maxWidth <= 100`
`words[i].length <= maxWidth`",0,,30.1,95.5,https://leetcode.com/problems/text-justification,936,167K,553.9K,"Intuit,Twilio,Uber,Karat,Indeed,Google,Amazon,Reddit,LinkedIn,Bloomberg,Microsoft,Twitter,Paypal,Apple,ByteDance,Databricks,Netflix,eBay",String,987,1954,34,1,"[Rearrange Spaces Between Words, /problems/rearrange-spaces-between-words/, Easy]"
15,72,Edit Distance,"Given two strings `word1` and `word2`, return the minimum number of operations required to convert `word1` to `word2`.

You have the following three operations permitted on a word:
Insert a character
Delete a character
Replace a character

Example 1:
Input: word1 = ""horse"", word2 = ""ros""
Output: 3
Explanation: 
horse -> rorse (replace 'h' with 'r')
rorse -> rose (remove 'r')
rose -> ros (remove 'e')

Example 2:
Input: word1 = ""intention"", word2 = ""execution""
Output: 5
Explanation: 
intention -> inention (remove 't')
inention -> enention (replace 'i' with 'e')
enention -> exention (replace 'n' with 'x')
exention -> exection (replace 'n' with 'c')
exection -> execution (insert 'u')

Constraints:
`0 <= word1.length, word2.length <= 500`
`word1` and `word2` consist of lowercase English letters.",0,/articles/edit-distance,47.1,59.8,https://leetcode.com/problems/edit-distance,999,346.5K,736K,"Amazon,Microsoft,Google,Square,Palantir Technologies","String,Dynamic Programming",5416,67,99,1,"[One Edit Distance, /problems/one-edit-distance/, Medium], [Delete Operation for Two Strings, /problems/delete-operation-for-two-strings/, Medium], [Minimum ASCII Delete Sum for Two Strings, /problems/minimum-ascii-delete-sum-for-two-strings/, Medium], [Uncrossed Lines, /problems/uncrossed-lines/, Medium]"
16,76,Minimum Window Substring,"Given two strings `s` and `t`, return the minimum window in `s` which will contain all the characters in `t`. If there is no such window in `s` that covers all characters in `t`, return the empty string `""""`.

Note that If there is such a window, it is guaranteed that there will always be only one unique minimum window in `s`.


Example 1:
Input: s = ""ADOBECODEBANC"", t = ""ABC""
Output: ""BANC""

Example 2:
Input: s = ""a"", t = ""a""
Output: ""a""

Constraints:
`1 <= s.length, t.length <= 105`
`s` and `t` consist of English letters.

Follow up: Could you find an algorithm that runs in `O(n)` time?",0,/articles/minimum-window-substring,36.2,69.1,https://leetcode.com/problems/minimum-window-substring,999,518.5K,1.4M,"Facebook,Amazon,Microsoft,Lyft,Apple,LinkedIn,Google,Uber,Bloomberg,Pinterest,Snapchat,Adobe,ByteDance","Hash Table,Two Pointers,String,Sliding Window",6350,428,94,1,"[Substring with Concatenation of All Words, /problems/substring-with-concatenation-of-all-words/, Hard], [Minimum Size Subarray Sum, /problems/minimum-size-subarray-sum/, Medium], [Sliding Window Maximum, /problems/sliding-window-maximum/, Hard], [Permutation in String, /problems/permutation-in-string/, Medium], [Smallest Range Covering Elements from K Lists, /problems/smallest-range-covering-elements-from-k-lists/, Hard], [Minimum Window Subsequence, /problems/minimum-window-subsequence/, Hard]"
17,84,Largest Rectangle in Histogram,"Given an array of integers `heights` representing the histogram's bar height where the width of each bar is `1`, return the area of the largest rectangle in the histogram.


Example 1:
Input: heights = [2,1,5,6,2,3]
Output: 10
Explanation: The above is a histogram where width of each bar is 1.

The largest rectangle is shown in the red area, which has an area = 10 units.


Example 2:
Input: heights = [2,4]
Output: 4

Constraints:
`1 <= heights.length <= 105`
`0 <= heights[i] <= 104`",0,/articles/largest-rectangle-in-histogram,37.4,57.5,https://leetcode.com/problems/largest-rectangle-in-histogram,999,350.8K,937.9K,"Amazon,Microsoft,Adobe,MAQ Software","Array,Stack",5576,111,98,1,"[Maximal Rectangle, /problems/maximal-rectangle/, Hard], [Maximum Score of a Good Subarray, /problems/maximum-score-of-a-good-subarray/, Hard]"
18,85,Maximal Rectangle,"Given a `rows x cols` binary `matrix` filled with `0`'s and `1`'s, find the largest rectangle containing only `1`'s and return its area.


Example 1:
Input: matrix = [[""1"",""0"",""1"",""0"",""0""],[""1"",""0"",""1"",""1"",""1""],[""1"",""1"",""1"",""1"",""1""],[""1"",""0"",""0"",""1"",""0""]]
Output: 6
Explanation: The maximal rectangle is shown in the above picture.


Example 2:
Input: matrix = []
Output: 0

Example 3:
Input: matrix = [[""0""]]
Output: 0

Example 4:
Input: matrix = [[""1""]]
Output: 1

Example 5:
Input: matrix = [[""0"",""0""]]
Output: 0

Constraints:
`rows == matrix.length`
`cols == matrix[i].length`
`0 <= row, cols <= 200`
`matrix[i][j]` is `'0'` or `'1'`.",0,/articles/maximal-rectangle,39.7,62.6,https://leetcode.com/problems/maximal-rectangle,651,222.8K,561.2K,"Google,Amazon,Adobe,Bloomberg,Apple","Array,Hash Table,Dynamic Programming,Stack",4086,86,98,1,"[Largest Rectangle in Histogram, /problems/largest-rectangle-in-histogram/, Hard], [Maximal Square, /problems/maximal-square/, Medium]"
19,87,Scramble String,"We can scramble a string s to get a string t using the following algorithm:
If the length of the string is 1, stop.

If the length of the string is > 1, do the following:
	
Split the string into two non-empty substrings at a random index, i.e., if the string is `s`, divide it to `x` and `y` where `s = x + y`.

Randomly decide to swap the two substrings or to keep them in the same order. i.e., after this step, `s` may become `s = x + y` or `s = y + x`.

Apply step 1 recursively on each of the two substrings `x` and `y`.

Given two strings `s1` and `s2` of the same length, return `true` if `s2` is a scrambled string of `s1`, otherwise, return `false`.


Example 1:
Input: s1 = ""great"", s2 = ""rgeat""
Output: true
Explanation: One possible scenario applied on s1 is:
""great"" --> ""gr/eat"" // divide at random index.

""gr/eat"" --> ""gr/eat"" // random decision is not to swap the two substrings and keep them in order.

""gr/eat"" --> ""g/r / e/at"" // apply the same algorithm recursively on both substrings. divide at ranom index each of them.

""g/r / e/at"" --> ""r/g / e/at"" // random decision was to swap the first substring and to keep the second substring in the same order.

""r/g / e/at"" --> ""r/g / e/ a/t"" // again apply the algorithm recursively, divide ""at"" to ""a/t"".

""r/g / e/ a/t"" --> ""r/g / e/ a/t"" // random decision is to keep both substrings in the same order.

The algorithm stops now and the result string is ""rgeat"" which is s2.

As there is one possible scenario that led s1 to be scrambled to s2, we return true.


Example 2:
Input: s1 = ""abcde"", s2 = ""caebd""
Output: false

Example 3:
Input: s1 = ""a"", s2 = ""a""
Output: true

Constraints:
`s1.length == s2.length`
`1 <= s1.length <= 30`
`s1` and `s2` consist of lower-case English letters.",0,,34.8,9.0,https://leetcode.com/problems/scramble-string,335,122.9K,353.2K,Apple,"String,Dynamic Programming",760,805,49,1,
20,99,Recover Binary Search Tree,"You are given the `root` of a binary search tree (BST), where exactly two nodes of the tree were swapped by mistake. Recover the tree without changing its structure.

Follow up: A solution using `O(n)` space is pretty straight forward. Could you devise a constant space solution?

Example 1:
Input: root = [1,3,null,null,2]
Output: [3,1,null,null,2]
Explanation: 3 cannot be a left child of 1 because 3 > 1. Swapping 1 and 3 makes the BST valid.


Example 2:
Input: root = [3,1,4,null,null,2]
Output: [2,1,4,null,null,3]
Explanation: 2 cannot be in the right subtree of 3 because 2 < 3. Swapping 2 and 3 makes the BST valid.


Constraints:
The number of nodes in the tree is in the range `[2, 1000]`.

`-231 <= Node.val <= 231 - 1`",0,/articles/recover-binary-search-tree,42.8,51.2,https://leetcode.com/problems/recover-binary-search-tree,631,206.9K,484K,"Oracle,Amazon,Microsoft,Uber","Tree,Depth-first Search",2361,91,96,1,
21,115,Distinct Subsequences,"Given two strings `s` and `t`, return the number of distinct subsequences of `s` which equals `t`.

A string's subsequence is a new string formed from the original string by deleting some (can be none) of the characters without disturbing the remaining characters' relative positions. (i.e., `""ACE""` is a subsequence of `""ABCDE""` while `""AEC""` is not).

It is guaranteed the answer fits on a 32-bit signed integer.


Example 1:
Input: s = ""rabbbit"", t = ""rabbit""
Output: 3
Explanation:
As shown below, there are 3 ways you can generate ""rabbit"" from S.

`rabbbit`
`rabbbit`
`rabbbit`

Example 2:
Input: s = ""babgbag"", t = ""bag""
Output: 5
Explanation:
As shown below, there are 5 ways you can generate ""bag"" from S.

`babgbag`
`babgbag`
`babgbag`
`babgbag`
`babgbag`

Constraints:
`1 <= s.length, t.length <= 1000`
`s` and `t` consist of English letters.",0,/articles/distinct-subsequences,40.0,49.9,https://leetcode.com/problems/distinct-subsequences,654,160.9K,402.3K,"Mathworks,Google,Amazon,Bloomberg","String,Dynamic Programming",1859,63,97,1,
22,123,Best Time to Buy and Sell Stock III,"You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.

Find the maximum profit you can achieve. You may complete at most two transactions.

Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).


Example 1:
Input: prices = [3,3,5,0,0,3,1,4]
Output: 6
Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.

Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.


Example 2:
Input: prices = [1,2,3,4,5]
Output: 4
Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.

Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.


Example 3:
Input: prices = [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.


Example 4:
Input: prices = [1]
Output: 0

Constraints:
`1 <= prices.length <= 105`
`0 <= prices[i] <= 105`",0,/articles/best-time-to-buy-and-sell-stock-iii,40.2,42.2,https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii,775,284.2K,707.6K,"Amazon,Google","Array,Dynamic Programming",3417,88,97,1,"[Best Time to Buy and Sell Stock, /problems/best-time-to-buy-and-sell-stock/, Easy], [Best Time to Buy and Sell Stock II, /problems/best-time-to-buy-and-sell-stock-ii/, Easy], [Best Time to Buy and Sell Stock IV, /problems/best-time-to-buy-and-sell-stock-iv/, Hard], [Maximum Sum of 3 Non-Overlapping Subarrays, /problems/maximum-sum-of-3-non-overlapping-subarrays/, Hard]"
23,124,Binary Tree Maximum Path Sum,"A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.

The path sum of a path is the sum of the node's values in the path.

Given the `root` of a binary tree, return the maximum path sum of any path.


Example 1:
Input: root = [1,2,3]
Output: 6
Explanation: The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.


Example 2:
Input: root = [-10,9,20,null,null,15,7]
Output: 42
Explanation: The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.


Constraints:
The number of nodes in the tree is in the range `[1, 3 * 104]`.

`-1000 <= Node.val <= 1000`",0,/articles/binary-tree-maximum-path-sum,35.6,69.3,https://leetcode.com/problems/binary-tree-maximum-path-sum,999,490.5K,1.4M,"Facebook,Amazon,Google,Microsoft,Bloomberg,Oracle,Adobe,Apple,Yahoo,ByteDance","Tree,Depth-first Search,Recursion",5446,387,93,1,"[Path Sum, /problems/path-sum/, Easy], [Sum Root to Leaf Numbers, /problems/sum-root-to-leaf-numbers/, Medium], [Path Sum IV, /problems/path-sum-iv/, Medium], [Longest Univalue Path, /problems/longest-univalue-path/, Medium], [Time Needed to Inform All Employees, /problems/time-needed-to-inform-all-employees/, Medium]"
24,126,Word Ladder II,"A transformation sequence from word `beginWord` to word `endWord` using a dictionary `wordList` is a sequence of words `beginWord -> s1 -> s2 -> ... -> sk` such that:
Every adjacent pair of words differs by a single letter.

Every `si` for `1 <= i <= k` is in `wordList`. Note that `beginWord` does not need to be in `wordList`.

`sk == endWord`
Given two words, `beginWord` and `endWord`, and a dictionary `wordList`, return all the shortest transformation sequences from `beginWord` to `endWord`, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words `[beginWord, s1, s2, ..., sk]`.


Example 1:
Input: beginWord = ""hit"", endWord = ""cog"", wordList = [""hot"",""dot"",""dog"",""lot"",""log"",""cog""]
Output: [[""hit"",""hot"",""dot"",""dog"",""cog""],[""hit"",""hot"",""lot"",""log"",""cog""]]
Explanation: There are 2 shortest transformation sequences:
""hit"" -> ""hot"" -> ""dot"" -> ""dog"" -> ""cog""
""hit"" -> ""hot"" -> ""lot"" -> ""log"" -> ""cog""

Example 2:
Input: beginWord = ""hit"", endWord = ""cog"", wordList = [""hot"",""dot"",""dog"",""lot"",""log""]
Output: []
Explanation: The endWord ""cog"" is not in wordList, therefore there is no valid transformation sequence.


Constraints:
`1 <= beginWord.length <= 10`
`endWord.length == beginWord.length`
`1 <= wordList.length <= 5000`
`wordList[i].length == beginWord.length`
`beginWord`, `endWord`, and `wordList[i]` consist of lowercase English letters.

`beginWord != endWord`
All the words in `wordList` are unique.",0,,23.8,55.3,https://leetcode.com/problems/word-ladder-ii,866,223K,937K,"Uber,Amazon,Facebook,Box,Lyft,Microsoft,Google,Bloomberg","Array,String,Backtracking,Breadth-first Search",2391,293,89,1,"[Word Ladder, /problems/word-ladder/, Hard]"
25,127,Word Ladder,"A transformation sequence from word `beginWord` to word `endWord` using a dictionary `wordList` is a sequence of words `beginWord -> s1 -> s2 -> ... -> sk` such that:
Every adjacent pair of words differs by a single letter.

Every `si` for `1 <= i <= k` is in `wordList`. Note that `beginWord` does not need to be in `wordList`.

`sk == endWord`
Given two words, `beginWord` and `endWord`, and a dictionary `wordList`, return the number of words in the shortest transformation sequence from `beginWord` to `endWord`, or `0` if no such sequence exists.


Example 1:
Input: beginWord = ""hit"", endWord = ""cog"", wordList = [""hot"",""dot"",""dog"",""lot"",""log"",""cog""]
Output: 5
Explanation: One shortest transformation sequence is ""hit"" -> ""hot"" -> ""dot"" -> ""dog"" -> cog"", which is 5 words long.


Example 2:
Input: beginWord = ""hit"", endWord = ""cog"", wordList = [""hot"",""dot"",""dog"",""lot"",""log""]
Output: 0
Explanation: The endWord ""cog"" is not in wordList, therefore there is no valid transformation sequence.


Constraints:
`1 <= beginWord.length <= 10`
`endWord.length == beginWord.length`
`1 <= wordList.length <= 5000`
`wordList[i].length == beginWord.length`
`beginWord`, `endWord`, and `wordList[i]` consist of lowercase English letters.

`beginWord != endWord`
All the words in `wordList` are unique.",0,/articles/word-ladder,32.1,84.2,https://leetcode.com/problems/word-ladder,999,564.1K,1.8M,"Amazon,Facebook,Lyft,Microsoft,Google,Uber,Bloomberg,Qualtrics,Snapchat,Oracle,Yahoo,Apple,Zillow,Citadel",Breadth-first Search,4859,1404,78,1,"[Word Ladder II, /problems/word-ladder-ii/, Hard], [Minimum Genetic Mutation, /problems/minimum-genetic-mutation/, Medium]"
26,128,Longest Consecutive Sequence,"Given an unsorted array of integers `nums`, return the length of the longest consecutive elements sequence.


Example 1:
Input: nums = [100,4,200,1,3,2]
Output: 4
Explanation: The longest consecutive elements sequence is `[1, 2, 3, 4]`. Therefore its length is 4.


Example 2:
Input: nums = [0,3,7,2,5,8,4,6,0,1]
Output: 9

Constraints:
`0 <= nums.length <= 104`
`-109 <= nums[i] <= 109`
Follow up: Could you implement the `O(n)` solution?",0,/articles/longest-consecutive-sequence,46.5,60.0,https://leetcode.com/problems/longest-consecutive-sequence,999,389K,837.1K,"Google,Amazon,Microsoft,Facebook,Bloomberg,Twitter","Array,Union Find",4894,238,95,1,"[Binary Tree Longest Consecutive Sequence, /problems/binary-tree-longest-consecutive-sequence/, Medium]"
27,132,Palindrome Partitioning II,"Given a string `s`, partition `s` such that every substring of the partition is a palindrome.

Return the minimum cuts needed for a palindrome partitioning of `s`.


Example 1:
Input: s = ""aab""
Output: 1
Explanation: The palindrome partitioning [""aa"",""b""] could be produced using 1 cut.


Example 2:
Input: s = ""a""
Output: 0

Example 3:
Input: s = ""ab""
Output: 1

Constraints:
`1 <= s.length <= 2000`
`s` consists of lower-case English letters only.",0,,31.4,7.7,https://leetcode.com/problems/palindrome-partitioning-ii,430,153.2K,487.9K,"Amazon,Google",Dynamic Programming,1760,52,97,1,"[Palindrome Partitioning, /problems/palindrome-partitioning/, Medium], [Palindrome Partitioning IV, /problems/palindrome-partitioning-iv/, Hard]"
28,135,Candy,"There are `n` children standing in a line. Each child is assigned a rating value given in the integer array `ratings`.

You are giving candies to these children subjected to the following requirements:
Each child must have at least one candy.

Children with a higher rating get more candies than their neighbors.

Return the minimum number of candies you need to have to distribute the candies to the children.


Example 1:
Input: ratings = [1,0,2]
Output: 5
Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.


Example 2:
Input: ratings = [1,2,2]
Output: 4
Explanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively.

The third child gets 1 candy because it satisfies the above two conditions.


Constraints:
`n == ratings.length`
`1 <= n <= 2 * 104`
`0 <= ratings[i] <= 2 * 104`",0,/articles/candy,33.3,45.7,https://leetcode.com/problems/candy,584,153.8K,462.1K,Amazon,Greedy,1402,195,88,1,
29,140,Word Break II,"Given a string `s` and a dictionary of strings `wordDict`, add spaces in `s` to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in any order.

Note that the same word in the dictionary may be reused multiple times in the segmentation.


Example 1:
Input: s = ""catsanddog"", wordDict = [""cat"",""cats"",""and"",""sand"",""dog""]
Output: [""cats and dog"",""cat sand dog""]

Example 2:
Input: s = ""pineapplepenapple"", wordDict = [""apple"",""pen"",""applepen"",""pine"",""pineapple""]
Output: [""pine apple pen apple"",""pineapple pen apple"",""pine applepen apple""]
Explanation: Note that you are allowed to reuse a dictionary word.


Example 3:
Input: s = ""catsandog"", wordDict = [""cats"",""dog"",""sand"",""and"",""cat""]
Output: []

Constraints:
`1 <= s.length <= 20`
`1 <= wordDict.length <= 1000`
`1 <= wordDict[i].length <= 10`
`s` and `wordDict[i]` consist of only lowercase English letters.

All the strings of `wordDict` are unique.",0,/articles/word-break-ii,35.3,70.4,https://leetcode.com/problems/word-break-ii,999,315.5K,893.4K,"Facebook,Amazon,Bloomberg,ByteDance,Google,Microsoft","Dynamic Programming,Backtracking",3046,443,87,1,"[Word Break, /problems/word-break/, Medium], [Concatenated Words, /problems/concatenated-words/, Hard]"
30,149,Max Points on a Line,"Given an array of `points` where `points[i] = [xi, yi]` represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.


Example 1:
Input: points = [[1,1],[2,2],[3,3]]
Output: 3

Example 2:
Input: points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]
Output: 4

Constraints:
`1 <= points.length <= 300`
`points[i].length == 2`
`-104 <= xi, yi <= 104`
All the `points` are unique.",0,/articles/max-points-on-a-line,17.6,61.7,https://leetcode.com/problems/max-points-on-a-line,776,177K,1M,"Apple,Google,LinkedIn,Amazon","Hash Table,Math",85,30,74,1,"[Line Reflection, /problems/line-reflection/, Medium]"
31,154,Find Minimum in Rotated Sorted Array II,"Suppose an array of length `n` sorted in ascending order is rotated between `1` and `n` times. For example, the array `nums = [0,1,4,4,5,6,7]` might become:
`[4,5,6,7,0,1,4]` if it was rotated `4` times.

`[0,1,4,4,5,6,7]` if it was rotated `7` times.

Notice that rotating an array `[a[0], a[1], a[2], ..., a[n-1]]` 1 time results in the array `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`.

Given the sorted rotated array `nums` that may contain duplicates, return the minimum element of this array.


Example 1:
Input: nums = [1,3,5]
Output: 1

Example 2:
Input: nums = [2,2,2,0,1]
Output: 0

Constraints:
`n == nums.length`
`1 <= n <= 5000`
`-5000 <= nums[i] <= 5000`
`nums` is sorted and rotated between `1` and `n` times.

Follow up: This is the same as Find Minimum in Rotated Sorted Array but with duplicates. Would allow duplicates affect the run-time complexity? How and why?",0,/articles/find-minimum-in-rotated-sorted-array-ii,42.1,24.4,https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii,931,241.2K,572.8K,"Amazon,Google,Oracle","Array,Binary Search",1504,273,85,1,"[Find Minimum in Rotated Sorted Array, /problems/find-minimum-in-rotated-sorted-array/, Medium]"
32,158,Read N Characters Given Read4 II - Call multiple times,"Given a `file` and assume that you can only read the file using a given method `read4`, implement a method `read` to read `n` characters. Your method `read` may be called multiple times.

Method read4: 
The API `read4` reads four consecutive characters from `file`, then writes those characters into the buffer array `buf4`.

The return value is the number of actual characters read.

Note that `read4()` has its own file pointer, much like `FILE *fp` in C.

Definition of read4:
    Parameter:  char[] buf4
    Returns:    int
buf4[] is a destination, not a source. The results from read4 will be copied to buf4[].

Below is a high-level example of how `read4` works:
File file(""abcde`""); // File is ""`abcde`"", initially file pointer (fp) points to 'a'
char[] buf4 = new char[4]; // Create buffer with enough space to store characters
read4(buf4); // read4 returns 4. Now buf4 = ""abcd"", fp points to 'e'
read4(buf4); // read4 returns 1. Now buf4 = ""e"", fp points to end of file
read4(buf4); // read4 returns 0. Now buf4 = """", fp points to end of file`
Method read:
By using the `read4` method, implement the method read that reads `n` characters from `file` and store it in the buffer array `buf`. Consider that you cannot manipulate `file` directly.

The return value is the number of actual characters read.

Definition of read: 
    Parameters:	char[] buf, int n
    Returns:	int
buf[] is a destination, not a source. You will need to write the results to buf[].

Note:
Consider that you cannot manipulate the file directly. The file is only accessible for `read4` but not for `read`.

The read function may be called multiple times.

Please remember to RESET your class variables declared in Solution, as static/class variables are persisted across multiple test cases. Please see here for more details.

You may assume the destination buffer array, `buf`, is guaranteed to have enough space for storing `n` characters.

It is guaranteed that in a given test case the same buffer `buf` is called by `read`.


Example 1:
Input: file = ""abc"", queries = [1,2,1]
Output: [1,2,0]
Explanation: The test case represents the following scenario:
File file(""abc"");
Solution sol;
sol.read(buf, 1); // After calling your read method, buf should contain ""a"". We read a total of 1 character from the file, so return 1.

sol.read(buf, 2); // Now buf should contain ""bc"". We read a total of 2 characters from the file, so return 2.

sol.read(buf, 1); // We have reached the end of file, no more characters can be read. So return 0.

Assume buf is allocated and guaranteed to have enough space for storing all characters from the file.


Example 2:
Input: file = ""abc"", queries = [4,1]
Output: [3,0]
Explanation: The test case represents the following scenario:
File file(""abc"");
Solution sol;
sol.read(buf, 4); // After calling your read method, buf should contain ""abc"". We read a total of 3 characters from the file, so return 3.

sol.read(buf, 1); // We have reached the end of file, no more characters can be read. So return 0.


Constraints:
`1 <= file.length <= 500`
`file` consist of English letters and digits.

`1 <= queries.length <= 10`
`1 <= queries[i] <= 500`",1,,37.4,59.8,https://leetcode.com/problems/read-n-characters-given-read4-ii-call-multiple-times,555,132.3K,354K,"Facebook,Lyft,Oracle,Apple",String,627,1334,32,1,"[Read N Characters Given Read4, /problems/read-n-characters-given-read4/, Easy]"
33,164,Maximum Gap,"Given an integer array `nums`, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return `0`.


Example 1:
Input: nums = [3,6,9,1]
Output: 3
Explanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3.


Example 2:
Input: nums = [10]
Output: 0
Explanation: The array contains less than 2 elements, therefore return 0.


Constraints:
`1 <= nums.length <= 104`
`0 <= nums[i] <= 109`
Follow up: Could you solve it in linear time/space?",0,/articles/maximum-gap,37.1,34.2,https://leetcode.com/problems/maximum-gap,357,101K,272.3K,Amazon,Sort,1130,210,84,1,
34,174,Dungeon Game,"The demons had captured the princess and imprisoned her in the bottom-right corner of a `dungeon`. The `dungeon` consists of `m x n` rooms laid out in a 2D grid. Our valiant knight was initially positioned in the top-left room and must fight his way through `dungeon` to rescue the princess.

The knight has an initial health point represented by a positive integer. If at any point his health point drops to `0` or below, he dies immediately.

Some of the rooms are guarded by demons (represented by negative integers), so the knight loses health upon entering these rooms; other rooms are either empty (represented as 0) or contain magic orbs that increase the knight's health (represented by positive integers).

To reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.

Return the knight's minimum initial health so that he can rescue the princess.

Note that any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.


Example 1:
Input: dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]]
Output: 7
Explanation: The initial health of the knight must be at least 7 if he follows the optimal path: RIGHT-> RIGHT -> DOWN -> DOWN.


Example 2:
Input: dungeon = [[0]]
Output: 1

Constraints:
`m == dungeon.length`
`n == dungeon[i].length`
`1 <= m, n <= 200`
`-1000 <= dungeon[i][j] <= 1000`",0,/articles/dungeon-game,33.4,19.7,https://leetcode.com/problems/dungeon-game,625,124.1K,371.5K,JPMorgan,"Binary Search,Dynamic Programming",2256,47,98,0,"[Unique Paths, /problems/unique-paths/, Medium], [Minimum Path Sum, /problems/minimum-path-sum/, Medium], [Cherry Pickup, /problems/cherry-pickup/, Hard]"
35,185,Department Top Three Salaries,SQL Schema,0,/articles/department-top-three-salaries,39.8,30.2,https://leetcode.com/problems/department-top-three-salaries,687,108.8K,273.7K,"Amazon,Uber",,729,151,83,1,
36,188,Best Time to Buy and Sell Stock IV,"You are given an integer array `prices` where `prices[i]` is the price of a given stock on the `ith` day, and an integer `k`.

Find the maximum profit you can achieve. You may complete at most `k` transactions.

Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).


Example 1:
Input: k = 2, prices = [2,4,1]
Output: 2
Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.


Example 2:
Input: k = 2, prices = [3,2,6,5,0,3]
Output: 7
Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.


Constraints:
`0 <= k <= 100`
`0 <= prices.length <= 1000`
`0 <= prices[i] <= 1000`",0,/articles/best-time-to-buy-and-sell-stock-iv,30.0,46.3,https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv,588,177.8K,592.5K,"Amazon,Google,Uber",Dynamic Programming,2362,133,95,1,"[Best Time to Buy and Sell Stock, /problems/best-time-to-buy-and-sell-stock/, Easy], [Best Time to Buy and Sell Stock II, /problems/best-time-to-buy-and-sell-stock-ii/, Easy], [Best Time to Buy and Sell Stock III, /problems/best-time-to-buy-and-sell-stock-iii/, Hard]"
37,212,Word Search II,"Given an `m x n` `board` of characters and a list of strings `words`, return all words on the board.

Each word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.


Example 1:
Input: board = [[""o"",""a"",""a"",""n""],[""e"",""t"",""a"",""e""],[""i"",""h"",""k"",""r""],[""i"",""f"",""l"",""v""]], words = [""oath"",""pea"",""eat"",""rain""]
Output: [""eat"",""oath""]

Example 2:
Input: board = [[""a"",""b""],[""c"",""d""]], words = [""abcb""]
Output: []

Constraints:
`m == board.length`
`n == board[i].length`
`1 <= m, n <= 12`
`board[i][j]` is a lowercase English letter.

`1 <= words.length <= 3 * 104`
`1 <= words[i].length <= 10`
`words[i]` consists of lowercase English letters.

All the strings of `words` are unique.",0,/articles/word-search-ii,37.4,68.4,https://leetcode.com/problems/word-search-ii,999,291.9K,780K,"Amazon,Microsoft,Uber,Apple,Google,Facebook,Snapchat,Twitter","Backtracking,Trie",3594,142,96,1,"[Word Search, /problems/word-search/, Medium], [Unique Paths III, /problems/unique-paths-iii/, Hard]"
38,214,Shortest Palindrome,"You are given a string `s`. You can convert `s` to a palindrome by adding characters in front of it.

Return the shortest palindrome you can find by performing this transformation.


Example 1:
Input: s = ""aacecaaa""
Output: ""aaacecaaa""

Example 2:
Input: s = ""abcd""
Output: ""dcbabcd""

Constraints:
`0 <= s.length <= 5 * 104`
`s` consists of lowercase English letters only.",0,/articles/shortest-palindrome,30.8,37.5,https://leetcode.com/problems/shortest-palindrome,508,114.1K,370.8K,Microsoft,String,1586,149,91,0,"[Longest Palindromic Substring, /problems/longest-palindromic-substring/, Medium], [Implement strStr(), /problems/implement-strstr/, Easy], [Palindrome Pairs, /problems/palindrome-pairs/, Hard]"
39,218,The Skyline Problem,"A city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return the skyline formed by these buildings collectively.

The geometric information of each building is given in the array `buildings` where `buildings[i] = [lefti, righti, heighti]`:
`lefti` is the x coordinate of the left edge of the `ith` building.

`righti` is the x coordinate of the right edge of the `ith` building.

`heighti` is the height of the `ith` building.

You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height `0`.

The skyline should be represented as a list of ""key points"" sorted by their x-coordinate in the form `[[x1,y1],[x2,y2],...]`. Each key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, which always has a y-coordinate `0` and is used to mark the skyline's termination where the rightmost building ends. Any ground between the leftmost and rightmost buildings should be part of the skyline's contour.

Note: There must be no consecutive horizontal lines of equal height in the output skyline. For instance, `[...,[2 3],[4 5],[7 5],[11 5],[12 7],...]` is not acceptable; the three lines of height 5 should be merged into one in the final output as such: `[...,[2 3],[4 5],[12 7],...]`

Example 1:
Input: buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]
Output: [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]
Explanation:
Figure A shows the buildings of the input.

Figure B shows the skyline formed by those buildings. The red points in figure B represent the key points in the output list.


Example 2:
Input: buildings = [[0,2,3],[2,5,3]]
Output: [[0,3],[5,0]]

Constraints:
`1 <= buildings.length <= 104`
`0 <= lefti < righti <= 231 - 1`
`1 <= heighti <= 231 - 1`
`buildings` is sorted by `lefti` in non-decreasing order.",0,/articles/skyline-problem,36.6,51.9,https://leetcode.com/problems/the-skyline-problem,659,167.7K,457.8K,"Microsoft,Amazon,Google,Twitter,Uber","Divide and Conquer,Heap,Binary Indexed Tree,Segment Tree,Line Sweep",2792,157,95,1,"[Falling Squares, /problems/falling-squares/, Hard]"
40,224,Basic Calculator,"Given a string `s` representing an expression, implement a basic calculator to evaluate it.


Example 1:
Input: s = ""1 + 1""
Output: 2

Example 2:
Input: s = "" 2-1 + 2 ""
Output: 3

Example 3:
Input: s = ""(1+(4+5+2)-3)+(6+8)""
Output: 23

Constraints:
`1 <= s.length <= 3 * 105`
`s` consists of digits, `'+'`, `'-'`, `'('`, `')'`, and `' '`.

`s` represents a valid expression.",0,/articles/basic-calculator,38.3,86.4,https://leetcode.com/problems/basic-calculator,659,204K,533.3K,"Amazon,Roblox,Facebook,Indeed,Karat,Microsoft,Google,ByteDance,Uber,Wish","Math,Stack",2131,177,92,1,"[Evaluate Reverse Polish Notation, /problems/evaluate-reverse-polish-notation/, Medium], [Basic Calculator II, /problems/basic-calculator-ii/, Medium], [Different Ways to Add Parentheses, /problems/different-ways-to-add-parentheses/, Medium], [Expression Add Operators, /problems/expression-add-operators/, Hard], [Basic Calculator III, /problems/basic-calculator-iii/, Hard]"
41,233,Number of Digit One,"Given an integer `n`, count the total number of digit `1` appearing in all non-negative integers less than or equal to `n`.


Example 1:
Input: n = 13
Output: 6

Example 2:
Input: n = 0
Output: 0

Constraints:
`0 <= n <= 2 * 109`",0,/articles/number-of-digit-one,31.8,25.9,https://leetcode.com/problems/number-of-digit-one,295,52.8K,165.8K,Amazon,Math,388,730,35,1,"[Factorial Trailing Zeroes, /problems/factorial-trailing-zeroes/, Easy], [Digit Count in Range, /problems/digit-count-in-range/, Hard]"
42,239,Sliding Window Maximum,"You are given an array of integers `nums`, there is a sliding window of size `k` which is moving from the very left of the array to the very right. You can only see the `k` numbers in the window. Each time the sliding window moves right by one position.

Return the max sliding window.


Example 1:
Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
Output: [3,3,5,5,6,7]
Explanation: 
Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7

Example 2:
Input: nums = [1], k = 1
Output: [1]

Example 3:
Input: nums = [1,-1], k = 1
Output: [1,-1]

Example 4:
Input: nums = [9,11], k = 2
Output: [11]

Example 5:
Input: nums = [4,-2], k = 2
Output: [4]

Constraints:
`1 <= nums.length <= 105`
`-104 <= nums[i] <= 104`
`1 <= k <= nums.length`",0,/articles/sliding-window-maximum,44.8,79.4,https://leetcode.com/problems/sliding-window-maximum,999,384.5K,858.9K,"Amazon,ByteDance,Dropbox,Facebook,Google,Citadel,Bloomberg,Microsoft,Akuna Capital,IBM,Twitter","Heap,Sliding Window,Dequeue",5504,228,96,1,"[Minimum Window Substring, /problems/minimum-window-substring/, Hard], [Min Stack, /problems/min-stack/, Easy], [Longest Substring with At Most Two Distinct Characters, /problems/longest-substring-with-at-most-two-distinct-characters/, Medium], [Paint House II, /problems/paint-house-ii/, Hard], [Jump Game VI, /problems/jump-game-vi/, Medium]"
43,248,Strobogrammatic Number III,"Given two strings low and high that represent two integers `low` and `high` where `low <= high`, return the number of strobogrammatic numbers in the range `[low, high]`.

A strobogrammatic number is a number that looks the same when rotated `180` degrees (looked at upside down).


Example 1:
Input: low = ""50"", high = ""100""
Output: 3

Example 2:
Input: low = ""0"", high = ""0""
Output: 1

Constraints:
`1 <= low.length, high.length <= 15`
`low` and `high` consist of only digits.

`low <= high`
`low` and `high` do not contain any leading zeros except for zero itself.",1,,40.4,7.1,https://leetcode.com/problems/strobogrammatic-number-iii,158,30.7K,76.1K,Google,"Math,Recursion",218,154,59,1,"[Strobogrammatic Number, /problems/strobogrammatic-number/, Easy], [Strobogrammatic Number II, /problems/strobogrammatic-number-ii/, Medium]"
44,262,Trips and Users,SQL Schema,0,,35.5,22.4,https://leetcode.com/problems/trips-and-users,845,78.5K,221.2K,Uber,,486,357,58,0,
45,265,Paint House II,"There are a row of `n` houses, each house can be painted with one of the `k` colors. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.

The cost of painting each house with a certain color is represented by an `n x k` cost matrix costs.

For example, `costs[0][0]` is the cost of painting house `0` with color `0`; `costs[1][2]` is the cost of painting house `1` with color `2`, and so on...

Return the minimum cost to paint all houses.


Example 1:
Input: costs = [[1,5,3],[2,9,4]]
Output: 5
Explanation:
Paint house 0 into color 0, paint house 1 into color 2. Minimum cost: 1 + 4 = 5; 
Or paint house 0 into color 2, paint house 1 into color 0. Minimum cost: 3 + 2 = 5.


Example 2:
Input: costs = [[1,3],[2,4]]
Output: 5

Constraints:
`costs.length == n`
`costs[i].length == k`
`1 <= n <= 100`
`1 <= k <= 20`
`1 <= costs[i][j] <= 20`
Follow up: Could you solve it in `O(nk)` runtime?",1,/articles/paint-house-ii,45.9,15.5,https://leetcode.com/problems/paint-house-ii,238,68.5K,149.2K,"LinkedIn,Walmart Labs",Dynamic Programming,628,26,96,0,"[Product of Array Except Self, /problems/product-of-array-except-self/, Medium], [Sliding Window Maximum, /problems/sliding-window-maximum/, Hard], [Paint House, /problems/paint-house/, Medium], [Paint Fence, /problems/paint-fence/, Medium]"
46,269,Alien Dictionary,"There is a new alien language that uses the English alphabet. However, the order among the letters is unknown to you.

You are given a list of strings `words` from the alien language's dictionary, where the strings in `words` are sorted lexicographically by the rules of this new language.

Return a string of the unique letters in the new alien language sorted in lexicographically increasing order by the new language's rules. If there is no solution, return `""""`. If there are multiple solutions, return any of them.

A string `s` is lexicographically smaller than a string `t` if at the first letter where they differ, the letter in `s` comes before the letter in `t` in the alien language. If the first `min(s.length, t.length)` letters are the same, then `s` is smaller if and only if `s.length < t.length`.


Example 1:
Input: words = [""wrt"",""wrf"",""er"",""ett"",""rftt""]
Output: ""wertf""

Example 2:
Input: words = [""z"",""x""]
Output: ""zx""

Example 3:
Input: words = [""z"",""x"",""z""]
Output: """"
Explanation: The order is invalid, so return `""""`.


Constraints:
`1 <= words.length <= 100`
`1 <= words[i].length <= 100`
`words[i]` consists of only lowercase English letters.",1,/articles/alien-dictionary,33.8,75.7,https://leetcode.com/problems/alien-dictionary,918,198.1K,585.8K,"Facebook,Amazon,Airbnb,Pinterest,Google,Microsoft,ByteDance","Graph,Topological Sort",2445,471,84,1,"[Course Schedule II, /problems/course-schedule-ii/, Medium]"
47,272,Closest Binary Search Tree Value II,"Given the `root` of a binary search tree, a `target` value, and an integer `k`, return the `k` values in the BST that are closest to the `target`. You may return the answer in any order.

You are guaranteed to have only one unique set of `k` values in the BST that are closest to the `target`.


Example 1:
Input: root = [4,2,5,1,3], target = 3.714286, k = 2
Output: [4,3]

Example 2:
Input: root = [1], target = 0.000000, k = 1
Output: [1]

Constraints:
The number of nodes in the tree is `n`.

`1 <= k <= n <= 104`.

`0 <= Node.val <= 109`
`-109 <= target <= 109`
Follow up: Assume that the BST is balanced. Could you solve it in less than `O(n)` runtime (where `n = total nodes`)?",1,/articles/closest-bst-value-ii,52.6,15.7,https://leetcode.com/problems/closest-binary-search-tree-value-ii,380,68.6K,130.3K,"LinkedIn,Oracle","Stack,Tree",759,21,97,0,"[Binary Tree Inorder Traversal, /problems/binary-tree-inorder-traversal/, Medium], [Closest Binary Search Tree Value, /problems/closest-binary-search-tree-value/, Easy]"
48,273,Integer to English Words,"Convert a non-negative integer `num` to its English words representation.


Example 1:
Input: num = 123
Output: ""One Hundred Twenty Three""

Example 2:
Input: num = 12345
Output: ""Twelve Thousand Three Hundred Forty Five""

Example 3:
Input: num = 1234567
Output: ""One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven""

Example 4:
Input: num = 1234567891
Output: ""One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One""

Constraints:
`0 <= num <= 231 - 1`",0,/articles/integer-to-english-words,28.3,88.3,https://leetcode.com/problems/integer-to-english-words,826,229.9K,813K,"Facebook,Amazon,Microsoft,Palantir Technologies,Square,Adobe,Oracle","Math,String",1438,3588,29,1,"[Integer to Roman, /problems/integer-to-roman/, Medium]"
49,282,Expression Add Operators,"Given a string `num` that contains only digits and an integer `target`, return all possibilities to add the binary operators `'+'`, `'-'`, or `'*'` between the digits of `num` so that the resultant expression evaluates to the `target` value.


Example 1:
Input: num = ""123"", target = 6
Output: [""1*2*3"",""1+2+3""]

Example 2:
Input: num = ""232"", target = 8
Output: [""2*3+2"",""2+3*2""]

Example 3:
Input: num = ""105"", target = 5
Output: [""1*0+5"",""10-5""]

Example 4:
Input: num = ""00"", target = 0
Output: [""0*0"",""0+0"",""0-0""]

Example 5:
Input: num = ""3456237490"", target = 9191
Output: []

Constraints:
`1 <= num.length <= 10`
`num` consists of only digits.

`-231 <= target <= 231 - 1`",0,/articles/expression-add-operators,36.9,37.5,https://leetcode.com/problems/expression-add-operators,311,129.2K,350K,"Facebook,Citadel",Divide and Conquer,1622,272,86,1,"[Evaluate Reverse Polish Notation, /problems/evaluate-reverse-polish-notation/, Medium], [Basic Calculator, /problems/basic-calculator/, Hard], [Basic Calculator II, /problems/basic-calculator-ii/, Medium], [Different Ways to Add Parentheses, /problems/different-ways-to-add-parentheses/, Medium], [Target Sum, /problems/target-sum/, Medium]"
50,295,Find Median from Data Stream,"The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value and the median is the mean of the two middle values.

For example, for `arr = [2,3,4]`, the median is `3`.

For example, for `arr = [2,3]`, the median is `(2 + 3) / 2 = 2.5`.

Implement the MedianFinder class:
`MedianFinder()` initializes the `MedianFinder` object.

`void addNum(int num)` adds the integer `num` from the data stream to the data structure.

`double findMedian()` returns the median of all elements so far. Answers within `10-5` of the actual answer will be accepted.


Example 1:
Input
[""MedianFinder"", ""addNum"", ""addNum"", ""findMedian"", ""addNum"", ""findMedian""]
[[], [1], [2], [], [3], []]
Output
[null, null, null, 1.5, null, 2.0]
Explanation
MedianFinder medianFinder = new MedianFinder();
medianFinder.addNum(1);    // arr = [1]
medianFinder.addNum(2);    // arr = [1, 2]
medianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)
medianFinder.addNum(3);    // arr[1, 2, 3]
medianFinder.findMedian(); // return 2.0

Constraints:
`-105 <= num <= 105`
There will be at least one element in the data structure before calling `findMedian`.

At most `5 * 104` calls will be made to `addNum` and `findMedian`.

Follow up:
If all integer numbers from the stream are in the range `[0, 100]`, how would you optimize your solution?
If `99%` of all integer numbers from the stream are in the range `[0, 100]`, how would you optimize your solution?",0,/articles/find-median-from-data-stream,47.4,87.3,https://leetcode.com/problems/find-median-from-data-stream,881,288K,607.7K,"Amazon,Facebook,Microsoft,ByteDance,Google,Apple,eBay,Bloomberg,Salesforce,Goldman Sachs,Nvidia,Uber,Walmart Labs,VMware,Adobe,Twilio","Heap,Design",3979,74,98,1,"[Sliding Window Median, /problems/sliding-window-median/, Hard]"
51,296,Best Meeting Point,"Given an `m x n` binary grid `grid` where each `1` marks the home of one friend, return the minimal total travel distance.

The total travel distance is the sum of the distances between the houses of the friends and the meeting point.

The distance is calculated using Manhattan Distance, where `distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|`.


Example 1:
Input: grid = [[1,0,0,0,1],[0,0,0,0,0],[0,0,1,0,0]]
Output: 6
Explanation: Given three friends living at (0,0), (0,4), and (2,2).

The point (0,2) is an ideal meeting point, as the total travel distance of 2 + 2 + 2 = 6 is minimal.

So return 6.


Example 2:
Input: grid = [[1,1]]
Output: 1

Constraints:
`m == grid.length`
`n == grid[i].length`
`1 <= m, n <= 200`
`grid[i][j]` is either `0` or `1`.

There will be at least two friends in the `grid`.",1,/articles/best-meeting-point,58.2,19.8,https://leetcode.com/problems/best-meeting-point,164,42.5K,73K,"Google,Amazon,Bloomberg,Microsoft","Math,Sort",597,49,92,1,"[Shortest Distance from All Buildings, /problems/shortest-distance-from-all-buildings/, Hard], [Minimum Moves to Equal Array Elements II, /problems/minimum-moves-to-equal-array-elements-ii/, Medium]"
52,297,Serialize and Deserialize Binary Tree,"Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.

Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.

Clarification: The input/output format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.


Example 1:
Input: root = [1,2,3,null,null,4,5]
Output: [1,2,3,null,null,4,5]

Example 2:
Input: root = []
Output: []

Example 3:
Input: root = [1]
Output: [1]

Example 4:
Input: root = [1,2]
Output: [1,2]

Constraints:
The number of nodes in the tree is in the range `[0, 104]`.

`-1000 <= Node.val <= 1000`",0,/articles/serialize-and-deserialize-binary-tree,50.2,74.4,https://leetcode.com/problems/serialize-and-deserialize-binary-tree,999,430.9K,858.6K,"Facebook,Microsoft,Amazon,LinkedIn,Uber,Bloomberg,eBay,Quora,Qualtrics,Google,Oracle,Citadel,Walmart Labs","Tree,Design",4145,191,96,1,"[Encode and Decode Strings, /problems/encode-and-decode-strings/, Medium], [Serialize and Deserialize BST, /problems/serialize-and-deserialize-bst/, Medium], [Find Duplicate Subtrees, /problems/find-duplicate-subtrees/, Medium], [Serialize and Deserialize N-ary Tree, /problems/serialize-and-deserialize-n-ary-tree/, Hard]"
53,301,Remove Invalid Parentheses,"Given a string `s` that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid.

Return all the possible results. You may return the answer in any order.


Example 1:
Input: s = ""()())()""
Output: [""(())()"",""()()()""]

Example 2:
Input: s = ""(a)())()""
Output: [""(a())()"",""(a)()()""]

Example 3:
Input: s = "")(""
Output: [""""]

Constraints:
`1 <= s.length <= 25`
`s` consists of lowercase English letters and parentheses `'('` and `')'`.

There will be at most `20` parentheses in `s`.",0,/articles/remove-invalid-parentheses,44.8,63.4,https://leetcode.com/problems/remove-invalid-parentheses,541,260.4K,580.8K,"Facebook,Bloomberg,ByteDance,Amazon,Qualtrics","Depth-first Search,Breadth-first Search",3281,152,96,1,"[Valid Parentheses, /problems/valid-parentheses/, Easy]"
54,302,Smallest Rectangle Enclosing Black Pixels,"You are given an `image` that is represented by a binary matrix with `0` as a white pixel and `1` as a black pixel.

The black pixels are connected (i.e., there is only one black region). Pixels are connected horizontally and vertically.

Given two integers `x` and `y` that represent the location of one of the black pixels, return the area of the smallest (axis-aligned) rectangle that encloses all black pixels.


Example 1:
Input: image = [[""0"",""0"",""1"",""0""],[""0"",""1"",""1"",""0""],[""0"",""1"",""0"",""0""]], x = 0, y = 2
Output: 6

Example 2:
Input: image = [[""1""]], x = 0, y = 0
Output: 1

Constraints:
`m == image.length`
`n == image[i].length`
`1 <= m, n <= 100`
`image[i][j]` is either `'0'` or `'1'`.

`1 <= x < m`
`1 <= y < n`
`image[x][y] == '1'.`
The black pixels in the `image` only form one component.",1,/articles/smallest-rectangle-enclosing-black-pixels,52.6,4.4,https://leetcode.com/problems/smallest-rectangle-enclosing-black-pixels,113,30.3K,57.5K,Google,Binary Search,244,59,81,1,
55,305,Number of Islands II,"You are given an empty 2D binary grid `grid` of size `m x n`. The grid represents a map where `0`'s represent water and `1`'s represent land. Initially, all the cells of `grid` are water cells (i.e., all the cells are `0`'s).

We may perform an add land operation which turns the water at position into a land. You are given an array `positions` where `positions[i] = [ri, ci]` is the position `(ri, ci)` at which we should operate the `ith` operation.

Return an array of integers `answer` where `answer[i]` is the number of islands after turning the cell `(ri, ci)` into a land.

An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.


Example 1:
Input: m = 3, n = 3, positions = [[0,0],[0,1],[1,2],[2,1]]
Output: [1,1,2,3]
Explanation:
Initially, the 2d grid is filled with water.

- Operation #1: addLand(0, 0) turns the water at grid[0][0] into a land. We have 1 island.

- Operation #2: addLand(0, 1) turns the water at grid[0][1] into a land. We still have 1 island.

- Operation #3: addLand(1, 2) turns the water at grid[1][2] into a land. We have 2 islands.

- Operation #4: addLand(2, 1) turns the water at grid[2][1] into a land. We have 3 islands.


Example 2:
Input: m = 1, n = 1, positions = [[0,0]]
Output: [1]

Constraints:
`1 <= m, n, positions.length <= 104`
`1 <= m * n <= 104`
`positions[i].length == 2`
`0 <= ri < m`
`0 <= ci < n`
Follow up: Could you solve it in time complexity `O(k log(mn))`, where `k == positions.length`?",1,/articles/number-of-islands-ii,39.6,14.2,https://leetcode.com/problems/number-of-islands-ii,359,88.4K,223.3K,Amazon,Union Find,1007,28,97,1,"[Number of Islands, /problems/number-of-islands/, Medium]"
56,308,Range Sum Query 2D - Mutable,"Given a 2D matrix `matrix`, find the sum of the elements inside the rectangle defined by its upper left corner `(row1, col1)` and lower right corner `(row2, col2)`.

Implement the NumMatrix class:
`NumMatrix(int[][] matrix)` initializes the object with the integer matrix `matrix`.

`void update(int row, int col, int val)` updates the value of `matrix[row][col]` to be `val`.

`int sumRegion(int row1, int col1, int row2, int col2)` returns the sum of the elements of the `matrix` array inside the rectangle defined by its upper left corner `(row1, col1)` and lower right corner `(row2, col2)`.


Example 1:
Input
[""NumMatrix"", ""sumRegion"", ""update"", ""sumRegion""]
[[[[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]], [2, 1, 4, 3], [3, 2, 2], [2, 1, 4, 3]]
Output
[null, 8, null, 10]
Explanation
NumMatrix numMatrix = new NumMatrix([[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]);
numMatrix.sumRegion(2, 1, 4, 3); // return 8
numMatrix.update(3, 2, 2);
numMatrix.sumRegion(2, 1, 4, 3); // return 10

Constraints:
`m == matrix.length`
`n == matrix[i].length`
`1 <= m, n <= 200`
`-105 <= matrix[i][j] <= 105`
`0 <= row < m`
`0 <= col < n`
`-105 <= val <= 105`
`0 <= row1 <= row2 < m`
`0 <= col1 <= col2 < n`
At most `104` calls will be made to `sumRegion` and `update`.",1,/articles/range-sum-query-2d-mutable,38.1,11.6,https://leetcode.com/problems/range-sum-query-2d-mutable,252,55.7K,146.1K,Google,"Binary Indexed Tree,Segment Tree",501,66,88,1,"[Range Sum Query 2D - Immutable, /problems/range-sum-query-2d-immutable/, Medium], [Range Sum Query - Mutable, /problems/range-sum-query-mutable/, Medium]"
57,312,Burst Balloons,"You are given `n` balloons, indexed from `0` to `n - 1`. Each balloon is painted with a number on it represented by an array `nums`. You are asked to burst all the balloons.

If you burst the `ith` balloon, you will get `nums[i - 1] * nums[i] * nums[i + 1]` coins. If `i - 1` or `i + 1` goes out of bounds of the array, then treat it as if there is a balloon with a `1` painted on it.

Return the maximum coins you can collect by bursting the balloons wisely.


Example 1:
Input: nums = [3,1,5,8]
Output: 167
Explanation:
nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []
coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167

Example 2:
Input: nums = [1,5]
Output: 10

Constraints:
`n == nums.length`
`1 <= n <= 500`
`0 <= nums[i] <= 100`",0,/articles/burst-balloons,53.9,58.7,https://leetcode.com/problems/burst-balloons,433,132.3K,245.4K,"Adobe,Bloomberg,Amazon,Google,Codenation","Divide and Conquer,Dynamic Programming",3483,106,97,1,"[Minimum Cost to Merge Stones, /problems/minimum-cost-to-merge-stones/, Hard]"
58,315,Count of Smaller Numbers After Self,"You are given an integer array `nums` and you have to return a new `counts` array. The `counts` array has the property where `counts[i]` is the number of smaller elements to the right of `nums[i]`.


Example 1:
Input: nums = [5,2,6,1]
Output: [2,1,1,0]
Explanation:
To the right of 5 there are 2 smaller elements (2 and 1).

To the right of 2 there is only 1 smaller element (1).

To the right of 6 there is 1 smaller element (1).

To the right of 1 there is 0 smaller element.


Example 2:
Input: nums = [-1]
Output: [0]

Example 3:
Input: nums = [-1,-1]
Output: [0,0]

Constraints:
`1 <= nums.length <= 105`
`-104 <= nums[i] <= 104`",0,,42.4,56.5,https://leetcode.com/problems/count-of-smaller-numbers-after-self,900,166.1K,391.9K,"Google,Amazon,Apple,Bloomberg","Binary Search,Divide and Conquer,Sort,Binary Indexed Tree,Segment Tree",3332,105,97,1,"[Count of Range Sum, /problems/count-of-range-sum/, Hard], [Queue Reconstruction by Height, /problems/queue-reconstruction-by-height/, Medium], [Reverse Pairs, /problems/reverse-pairs/, Hard], [How Many Numbers Are Smaller Than the Current Number, /problems/how-many-numbers-are-smaller-than-the-current-number/, Easy]"
59,317,Shortest Distance from All Buildings,"You are given an `m x n` grid `grid` of values `0`, `1`, or `2`, where:
each `0` marks an empty land that you can pass by freely,
each `1` marks a building that you cannot pass through, and
each `2` marks an obstacle that you cannot pass through.

You want to build a house on an empty land that reaches all buildings in the shortest total travel distance. You can only move up, down, left, and right.

Return the shortest travel distance for such a house. If it is not possible to build such a house according to the above rules, return `-1`.

The total travel distance is the sum of the distances between the houses of the friends and the meeting point.

The distance is calculated using Manhattan Distance, where `distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|`.


Example 1:
Input: grid = [[1,0,2,0,1],[0,0,0,0,0],[0,0,1,0,0]]
Output: 7
Explanation: Given three buildings at (0,0), (0,4), (2,2), and an obstacle at (0,2).

The point (1,2) is an ideal empty land to build a house, as the total travel distance of 3+3+1=7 is minimal.

So return 7.


Example 2:
Input: grid = [[1,0]]
Output: 1

Example 3:
Input: grid = [[1]]
Output: -1

Constraints:
`m == grid.length`
`n == grid[i].length`
`1 <= m, n <= 100`
`grid[i][j]` is either `0`, `1`, or `2`.

There will be at least one building in the `grid`.",1,,42.9,43.8,https://leetcode.com/problems/shortest-distance-from-all-buildings,343,89.2K,207.8K,"Facebook,Google,Amazon,Qualtrics",Breadth-first Search,983,63,94,1,"[Walls and Gates, /problems/walls-and-gates/, Medium], [Best Meeting Point, /problems/best-meeting-point/, Hard], [As Far from Land as Possible, /problems/as-far-from-land-as-possible/, Medium]"
60,321,Create Maximum Number,"You are given two integer arrays `nums1` and `nums2` of lengths `m` and `n` respectively. `nums1` and `nums2` represent the digits of two numbers. You are also given an integer `k`.

Create the maximum number of length `k <= m + n` from digits of the two numbers. The relative order of the digits from the same array must be preserved.

Return an array of the `k` digits representing the answer.


Example 1:
Input: nums1 = [3,4,6,5], nums2 = [9,1,2,5,8,3], k = 5
Output: [9,8,6,5,3]

Example 2:
Input: nums1 = [6,7], nums2 = [6,0,4], k = 5
Output: [6,7,6,0,4]

Example 3:
Input: nums1 = [3,9], nums2 = [8,9], k = 3
Output: [9,8,9]

Constraints:
`m == nums1.length`
`n == nums2.length`
`1 <= m, n <= 500`
`0 <= nums1[i], nums2[i] <= 9`
`1 <= k <= m + n`
Follow up: Try to optimize your time and space complexity.",0,,27.6,28.6,https://leetcode.com/problems/create-maximum-number,146,43.5K,157.7K,Apple,"Dynamic Programming,Greedy",927,269,78,1,"[Remove K Digits, /problems/remove-k-digits/, Medium], [Maximum Swap, /problems/maximum-swap/, Medium]"
61,327,Count of Range Sum,"Given an integer array `nums` and two integers `lower` and `upper`, return the number of range sums that lie in `[lower, upper]` inclusive.

Range sum `S(i, j)` is defined as the sum of the elements in `nums` between indices `i` and `j` inclusive, where `i <= j`.


Example 1:
Input: nums = [-2,5,-1], lower = -2, upper = 2
Output: 3
Explanation: The three ranges are: [0,0], [2,2], and [0,2] and their respective sums are: -2, -1, 2.


Example 2:
Input: nums = [0], lower = 0, upper = 0
Output: 1

Constraints:
`1 <= nums.length <= 104`
`-231 <= nums[i] <= 231 - 1`
`-3 * 104 <= lower <= upper <= 3 * 104`
Follow up: A naive algorithm of `O(n2)` is trivial, Could you do better than that?",0,,36.2,17.2,https://leetcode.com/problems/count-of-range-sum,219,49.6K,136.8K,"Amazon,Google","Binary Search,Divide and Conquer,Sort,Binary Indexed Tree,Segment Tree",1016,118,90,1,"[Count of Smaller Numbers After Self, /problems/count-of-smaller-numbers-after-self/, Hard], [Reverse Pairs, /problems/reverse-pairs/, Hard]"
62,329,Longest Increasing Path in a Matrix,"Given an `m x n` integers `matrix`, return the length of the longest increasing path in `matrix`.

From each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).


Example 1:
Input: matrix = [[9,9,4],[6,6,8],[2,1,1]]
Output: 4
Explanation: The longest increasing path is `[1, 2, 6, 9]`.


Example 2:
Input: matrix = [[3,4,5],[3,2,6],[2,2,1]]
Output: 4
Explanation: The longest increasing path is `[3, 4, 5, 6]`. Moving diagonally is not allowed.


Example 3:
Input: matrix = [[1]]
Output: 1

Constraints:
`m == matrix.length`
`n == matrix[i].length`
`1 <= m, n <= 200`
`0 <= matrix[i][j] <= 231 - 1`",0,/articles/longest-increasing-path-in-a-matrix,45.4,59.6,https://leetcode.com/problems/longest-increasing-path-in-a-matrix,851,202.1K,445.6K,"Google,Facebook,Bloomberg,Amazon,ByteDance,DoorDash","Depth-first Search,Topological Sort,Memoization",2888,52,98,1,
63,330,Patching Array,"Given a sorted integer array `nums` and an integer `n`, add/patch elements to the array such that any number in the range `[1, n]` inclusive can be formed by the sum of some elements in the array.

Return the minimum number of patches required.


Example 1:
Input: nums = [1,3], n = 6
Output: 1
Explanation:
Combinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4.

Now if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].

Possible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6].

So we only need 1 patch.


Example 2:
Input: nums = [1,5,10], n = 20
Output: 2
Explanation: The two patches can be [2, 4].


Example 3:
Input: nums = [1,2,2], n = 5
Output: 0

Constraints:
`1 <= nums.length <= 1000`
`1 <= nums[i] <= 104`
`nums` is sorted in ascending order.

`1 <= n <= 231 - 1`",0,/articles/patching-array,35.1,12.1,https://leetcode.com/problems/patching-array,109,39.4K,112.2K,Google,Greedy,630,84,88,1,"[Maximum Number of Consecutive Values You Can Make, /problems/maximum-number-of-consecutive-values-you-can-make/, Medium]"
64,335,Self Crossing,"You are given an array of integers `distance`.

You start at point `(0,0)` on an X-Y plane and you move `distance[0]` meters to the north, then `distance[1]` meters to the west, `distance[2]` meters to the south, `distance[3]` meters to the east, and so on. In other words, after each move, your direction changes counter-clockwise.

Return `true` if your path crosses itself, and `false` if it does not.


Example 1:
Input: distance = [2,1,1,2]
Output: true

Example 2:
Input: distance = [1,2,3,4]
Output: false

Example 3:
Input: distance = [1,1,1,1]
Output: true

Constraints:
`1 <= distance.length <= 500`
`1 <= distance[i] <= 500`
Follow up: Could you write a one-pass algorithm with `O(1)` extra space?",0,,28.7,13.0,https://leetcode.com/problems/self-crossing,117,25.1K,87.2K,"Amazon,Google",Math,177,400,31,1,
65,336,Palindrome Pairs,"Given a list of unique words, return all the pairs of the distinct indices `(i, j)` in the given list, so that the concatenation of the two words `words[i] + words[j]` is a palindrome.


Example 1:
Input: words = [""abcd"",""dcba"",""lls"",""s"",""sssll""]
Output: [[0,1],[1,0],[3,2],[2,4]]
Explanation: The palindromes are [""dcbaabcd"",""abcddcba"",""slls"",""llssssll""]

Example 2:
Input: words = [""bat"",""tab"",""cat""]
Output: [[0,1],[1,0]]
Explanation: The palindromes are [""battab"",""tabbat""]

Example 3:
Input: words = [""a"",""""]
Output: [[0,1],[1,0]]

Constraints:
`1 <= words.length <= 5000`
`0 <= words[i].length <= 300`
`words[i]` consists of lower-case English letters.",0,/articles/palindrome-pairs,34.8,34.9,https://leetcode.com/problems/palindrome-pairs,372,114.6K,328.9K,"Airbnb,ByteDance,Facebook","Hash Table,String,Trie",1742,172,91,1,"[Longest Palindromic Substring, /problems/longest-palindromic-substring/, Medium], [Shortest Palindrome, /problems/shortest-palindrome/, Hard]"
66,352,Data Stream as Disjoint Intervals,"Given a data stream input of non-negative integers `a1, a2, ..., an`, summarize the numbers seen so far as a list of disjoint intervals.

Implement the `SummaryRanges` class:
`SummaryRanges()` Initializes the object with an empty stream.

`void addNum(int val)` Adds the integer `val` to the stream.

`int[][] getIntervals()` Returns a summary of the integers in the stream currently as a list of disjoint intervals `[starti, endi]`.


Example 1:
Input
[""SummaryRanges"", ""addNum"", ""getIntervals"", ""addNum"", ""getIntervals"", ""addNum"", ""getIntervals"", ""addNum"", ""getIntervals"", ""addNum"", ""getIntervals""]
[[], [1], [], [3], [], [7], [], [2], [], [6], []]
Output
[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]
Explanation
SummaryRanges summaryRanges = new SummaryRanges();
summaryRanges.addNum(1);      // arr = [1]
summaryRanges.getIntervals(); // return [[1, 1]]
summaryRanges.addNum(3);      // arr = [1, 3]
summaryRanges.getIntervals(); // return [[1, 1], [3, 3]]
summaryRanges.addNum(7);      // arr = [1, 3, 7]
summaryRanges.getIntervals(); // return [[1, 1], [3, 3], [7, 7]]
summaryRanges.addNum(2);      // arr = [1, 2, 3, 7]
summaryRanges.getIntervals(); // return [[1, 3], [7, 7]]
summaryRanges.addNum(6);      // arr = [1, 2, 3, 6, 7]
summaryRanges.getIntervals(); // return [[1, 3], [6, 7]]

Constraints:
`0 <= val <= 104`
At most `3 * 104` calls will be made to `addNum` and `getIntervals`.

Follow up: What if there are lots of merges and the number of disjoint intervals is small compared to the size of the data stream?",0,,48.8,12.0,https://leetcode.com/problems/data-stream-as-disjoint-intervals,306,42.3K,86.6K,Oracle,"Binary Search,Ordered Map",473,118,80,0,"[Summary Ranges, /problems/summary-ranges/, Easy], [Find Right Interval, /problems/find-right-interval/, Medium], [Range Module, /problems/range-module/, Hard]"
67,354,Russian Doll Envelopes,"You are given a 2D array of integers `envelopes` where `envelopes[i] = [wi, hi]` represents the width and the height of an envelope.

One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height.

Return the maximum number of envelopes you can Russian doll (i.e., put one inside the other).

Note: You cannot rotate an envelope.


Example 1:
Input: envelopes = [[5,4],[6,4],[6,7],[2,3]]
Output: 3
Explanation: The maximum number of envelopes you can Russian doll is `3` ([2,3] => [5,4] => [6,7]).


Example 2:
Input: envelopes = [[1,1],[1,1],[1,1]]
Output: 1

Constraints:
`1 <= envelopes.length <= 5000`
`envelopes[i].length == 2`
`1 <= wi, hi <= 104`",0,/articles/russian-doll-envelopes,37.7,20.9,https://leetcode.com/problems/russian-doll-envelopes,404,100.8K,267.4K,"Google,Amazon,ByteDance,Uber","Binary Search,Dynamic Programming",1968,58,97,1,"[Longest Increasing Subsequence, /problems/longest-increasing-subsequence/, Medium]"
68,358,Rearrange String k Distance Apart,"Given a string `s` and an integer `k`, rearrange `s` such that the same characters are at least distance `k` from each other. If it is not possible to rearrange the string, return an empty string `""""`.


Example 1:
Input: s = ""aabbcc"", k = 3
Output: ""abcabc""
Explanation: The same letters are at least a distance of 3 from each other.


Example 2:
Input: s = ""aaabc"", k = 3
Output: """"
Explanation: It is not possible to rearrange the string.


Example 3:
Input: s = ""aaadbbcc"", k = 2
Output: ""abacabcd""
Explanation: The same letters are at least a distance of 2 from each other.


Constraints:
`1 <= s.length <= 3 * 105`
`s` consists of only lowercase English letters.

`0 <= k <= s.length`",1,,35.7,14.7,https://leetcode.com/problems/rearrange-string-k-distance-apart,206,42.5K,118.8K,"Microsoft,Facebook","Hash Table,Heap,Greedy",577,23,96,1,"[Task Scheduler, /problems/task-scheduler/, Medium], [Reorganize String, /problems/reorganize-string/, Medium]"
69,363,Max Sum of Rectangle No Larger Than K,"Given an `m x n` matrix `matrix` and an integer `k`, return the max sum of a rectangle in the matrix such that its sum is no larger than `k`.

It is guaranteed that there will be a rectangle with a sum no larger than `k`.


Example 1:
Input: matrix = [[1,0,1],[0,-2,3]], k = 2
Output: 2
Explanation: Because the sum of the blue rectangle [[0, 1], [-2, 3]] is 2, and 2 is the max number no larger than k (k = 2).


Example 2:
Input: matrix = [[2,2,-1]], k = 3
Output: 3

Constraints:
`m == matrix.length`
`n == matrix[i].length`
`1 <= m, n <= 100`
`-100 <= matrix[i][j] <= 100`
`-105 <= k <= 105`
Follow up: What if the number of rows is much larger than the number of columns?",0,,38.5,63.2,https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k,169,53.8K,139.8K,Roblox,"Binary Search,Dynamic Programming,Queue",1093,80,93,0,
70,381,Insert Delete GetRandom O(1) - Duplicates allowed,"Implement the `RandomizedCollection` class:
`RandomizedCollection()` Initializes the `RandomizedCollection` object.

`bool insert(int val)` Inserts an item `val` into the multiset if not present. Returns `true` if the item was not present, `false` otherwise.

`bool remove(int val)` Removes an item `val` from the multiset if present. Returns `true` if the item was present, `false` otherwise. Note that if `val` has multiple occurrences in the multiset, we only remove one of them.

`int getRandom()` Returns a random element from the current multiset of elements (it's guaranteed that at least one element exists when this method is called). The probability of each element being returned is linearly related to the number of same values the multiset contains.


Example 1:
Input
[""RandomizedCollection"", ""insert"", ""insert"", ""insert"", ""getRandom"", ""remove"", ""getRandom""]
[[], [1], [1], [2], [], [1], []]
Output
[null, true, false, true, 2, true, 1]
Explanation
RandomizedCollection randomizedCollection = new RandomizedCollection();
randomizedCollection.insert(1);   // return True. Inserts 1 to the collection. Returns true as the collection did not contain 1.

randomizedCollection.insert(1);   // return False. Inserts another 1 to the collection. Returns false as the collection contained 1. Collection now contains [1,1].

randomizedCollection.insert(2);   // return True. Inserts 2 to the collection, returns true. Collection now contains [1,1,2].

randomizedCollection.getRandom(); // getRandom should return 1 with the probability 2/3, and returns 2 with the probability 1/3.

randomizedCollection.remove(1);   // return True. Removes 1 from the collection, returns true. Collection now contains [1,2].

randomizedCollection.getRandom(); // getRandom should return 1 and 2 both equally likely.


Constraints:
`-231 <= val <= 231 - 1`
At most `105` calls will be made to `insert`, `remove`, and `getRandom`.

There will be at least one element in the data structure when `getRandom` is called.

Follow up: Could you implement the functions of the class with each function works in average `O(1)` time?",0,/articles/insert-delete-getrandom-o1-duplicates-allowed,35.0,52.3,https://leetcode.com/problems/insert-delete-getrandom-o1-duplicates-allowed,355,83.7K,239.2K,"Facebook,Affirm","Array,Hash Table,Design",1111,90,93,1,"[Insert Delete GetRandom O(1), /problems/insert-delete-getrandom-o1/, Medium]"
71,391,Perfect Rectangle,"Given an array `rectangles` where `rectangles[i] = [xi, yi, ai, bi]` represents an axis-aligned rectangle. The bottom-left point of the rectangle is `(xi, yi)` and the top-right point of it is `(ai, bi)`.

Return `true` if all the rectangles together form an exact cover of a rectangular region.


Example 1:
Input: rectangles = [[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]]
Output: true
Explanation: All 5 rectangles together form an exact cover of a rectangular region.


Example 2:
Input: rectangles = [[1,1,2,3],[1,3,2,4],[3,1,4,2],[3,2,4,4]]
Output: false
Explanation: Because there is a gap between the two rectangular regions.


Example 3:
Input: rectangles = [[1,1,3,3],[3,1,4,2],[1,3,2,4],[3,2,4,4]]
Output: false
Explanation: Because there is a gap in the top center.


Example 4:
Input: rectangles = [[1,1,3,3],[3,1,4,2],[1,3,2,4],[2,2,4,4]]
Output: false
Explanation: Because two of the rectangles overlap with each other.


Constraints:
`1 <= rectangles.length <= 2 * 104`
`rectangles[i].length == 4`
`-105 <= xi, yi, ai, bi <= 105`",0,,31.3,8.1,https://leetcode.com/problems/perfect-rectangle,140,29.5K,94.3K,Apple,Line Sweep,461,86,84,1,
72,403,Frog Jump,"A frog is crossing a river. The river is divided into some number of units, and at each unit, there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.

Given a list of `stones`' positions (in units) in sorted ascending order, determine if the frog can cross the river by landing on the last stone. Initially, the frog is on the first stone and assumes the first jump must be `1` unit.

If the frog's last jump was `k` units, its next jump must be either `k - 1`, `k`, or `k + 1` units. The frog can only jump in the forward direction.


Example 1:
Input: stones = [0,1,3,5,6,8,12,17]
Output: true
Explanation: The frog can jump to the last stone by jumping 1 unit to the 2nd stone, then 2 units to the 3rd stone, then 2 units to the 4th stone, then 3 units to the 6th stone, 4 units to the 7th stone, and 5 units to the 8th stone.


Example 2:
Input: stones = [0,1,2,3,4,8,9,11]
Output: false
Explanation: There is no way to jump to the last stone as the gap between the 5th and 6th stone is too large.


Constraints:
`2 <= stones.length <= 2000`
`0 <= stones[i] <= 231 - 1`
`stones[0] == 0`",0,/articles/frog-jump,41.7,55.5,https://leetcode.com/problems/frog-jump,675,118.6K,284.4K,"Amazon,Microsoft,ByteDance,Google",Dynamic Programming,1497,130,92,1,
73,407,Trapping Rain Water II,"Given an `m x n` matrix of positive integers representing the height of each unit cell in a 2D elevation map, compute the volume of water it is able to trap after raining.


Example:
Given the following 3x6 height map:
[
  [1,4,3,1,3,2],
  [3,2,1,3,2,4],
  [2,3,3,2,3,1]
]
Return 4.

The above image represents the elevation map `[[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]` before the rain.

After the rain, water is trapped between the blocks. The total volume of water trapped is 4.


Constraints:
`1 <= m, n <= 110`
`0 <= heightMap[i][j] <= 20000`",0,,44.5,36.3,https://leetcode.com/problems/trapping-rain-water-ii,196,52K,116.8K,"Google,Amazon","Heap,Breadth-first Search",1776,39,98,1,"[Trapping Rain Water, /problems/trapping-rain-water/, Hard]"
74,410,Split Array Largest Sum,"Given an array `nums` which consists of non-negative integers and an integer `m`, you can split the array into `m` non-empty continuous subarrays.

Write an algorithm to minimize the largest sum among these `m` subarrays.


Example 1:
Input: nums = [7,2,5,10,8], m = 2
Output: 18
Explanation:
There are four ways to split nums into two subarrays.

The best way is to split it into [7,2,5] and [10,8],
where the largest sum among the two subarrays is only 18.


Example 2:
Input: nums = [1,2,3,4,5], m = 2
Output: 9

Example 3:
Input: nums = [1,4,4], m = 3
Output: 4

Constraints:
`1 <= nums.length <= 1000`
`0 <= nums[i] <= 106`
`1 <= m <= min(50, nums.length)`",0,/articles/split-array-largest-sum,46.6,38.9,https://leetcode.com/problems/split-array-largest-sum,437,118.5K,254K,"Amazon,Google","Binary Search,Dynamic Programming",2522,92,96,1,
75,411,Minimum Unique Word Abbreviation,"A string can be abbreviated by replacing any number of non-adjacent substrings with their lengths. For example, a string such as `""substitution""` could be abbreviated as (but not limited to):
`""s10n""` (`""s ubstitutio n""`)
`""sub4u4""` (`""sub stit u tion""`)
`""12""` (`""substitution""`)
`""su3i1u2on""` (`""su bst i t u ti on""`)
`""substitution""` (no substrings replaced)
Note that `""s55n""` (`""s ubsti tutio n""`) is not a valid abbreviation of `""substitution""` because the replaced substrings are adjacent.

The length of an abbreviation is the number of letters that were not replaced plus the number of substrings that were replaced. For example, the abbreviation `""s10n""` has a length of `3` (`2` letters + `1` substring) and `""su3i1u2on""` has a length of `9` (`6` letters + `3` substrings).

Given a target string `target` and an array of strings `dictionary`, return an abbreviation of `target` with the shortest possible length such that it is not an abbreviation of any string in `dictionary`. If there are multiple shortest abbreviations, return any of them.


Example 1:
Input: target = ""apple"", dictionary = [""blade""]
Output: ""a4""
Explanation: The shortest abbreviation of ""apple"" is ""5"", but this is also an abbreviation of ""blade"".

The next shortest abbreviations are ""a4"" and ""4e"". ""4e"" is an abbreviation of blade while ""a4"" is not.

Hence, return ""a4"".


Example 2:
Input: target = ""apple"", dictionary = [""blade"",""plain"",""amber""]
Output: ""1p3""
Explanation: ""5"" is an abbreviation of both ""apple"" but also every word in the dictionary.

""a4"" is an abbreviation of ""apple"" but also ""amber"".

""4e"" is an abbreviation of ""apple"" but also ""blade"".

""1p3"", ""2p2"", and ""3l1"" are the next shortest abbreviations of ""apple"".

Since none of them are abbreviations of words in the dictionary, returning any of them is correct.


Constraints:
`target.length == m`
`dictionary.length == n`
`1 <= m <= 21`
`0 <= n <= 1000`
`1 <= dictionary[i] <= 100`
`log2(n) + m <= 21` if `n > 0`",1,,37.4,0.0,https://leetcode.com/problems/minimum-unique-word-abbreviation,66,12.2K,32.5K,Google,"Backtracking,Bit Manipulation",147,131,53,1,"[Generalized Abbreviation, /problems/generalized-abbreviation/, Medium], [Valid Word Abbreviation, /problems/valid-word-abbreviation/, Easy], [Word Abbreviation, /problems/word-abbreviation/, Hard]"
76,420,Strong Password Checker,"A password is considered strong if the below conditions are all met:
It has at least `6` characters and at most `20` characters.

It contains at least one lowercase letter, at least one uppercase letter, and at least one digit.

It does not contain three repeating characters in a row (i.e., `""...aaa...""` is weak, but `""...aa...a...""` is strong, assuming other conditions are met).

Given a string `password`, return the minimum number of steps required to make `password` strong. if `password` is already strong, return `0`.

In one step, you can:
Insert one character to `password`,
Delete one character from `password`, or
Replace one character of `password` with another character.


Example 1:
Input: password = ""a""
Output: 5

Example 2:
Input: password = ""aA1""
Output: 3

Example 3:
Input: password = ""1337C0d3""
Output: 0

Constraints:
`1 <= password.length <= 50`
`password` consists of letters, digits, dot `'.'` or exclamation mark `'!'`.",0,,13.9,80.0,https://leetcode.com/problems/strong-password-checker,166,17.5K,126.1K,"Google,Oracle,Microsoft",,317,939,25,1,
77,425,Word Squares,"Given a set of words (without duplicates), find all word squares you can build from them.

A sequence of words forms a valid word square if the kth row and column read the exact same string, where 0 ≤ k < max(numRows, numColumns).

For example, the word sequence `[""ball"",""area"",""lead"",""lady""]` forms a word square because each word reads the same both horizontally and vertically.

b a l l
a r e a
l e a d
l a d y
Note:
There are at least 1 and at most 1000 words.

All words will have the exact same length.

Word length is at least 1 and at most 5.

Each word contains only lowercase English alphabet `a-z`.


Example 1:
Input:
[""area"",""lead"",""wall"",""lady"",""ball""]
Output:
[
  [ ""wall"",
    ""area"",
    ""lead"",
    ""lady""
  ],
  [ ""ball"",
    ""area"",
    ""lead"",
    ""lady""
  ]
]
Explanation:
The output consists of two word squares. The order of output does not matter (just the order of words in each word square matters).


Example 2:
Input:
[""abat"",""baba"",""atan"",""atal""]
Output:
[
  [ ""baba"",
    ""abat"",
    ""baba"",
    ""atan""
  ],
  [ ""baba"",
    ""abat"",
    ""baba"",
    ""atal""
  ]
]
Explanation:
The output consists of two word squares. The order of output does not matter (just the order of words in each word square matters).",1,/articles/word-squares,50.3,19.2,https://leetcode.com/problems/word-squares,171,48K,95.6K,Bloomberg,"Backtracking,Trie",720,45,94,0,"[Valid Word Square, /problems/valid-word-square/, Easy]"
78,428,Serialize and Deserialize N-ary Tree,"Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.

Design an algorithm to serialize and deserialize an N-ary tree. An N-ary tree is a rooted tree in which each node has no more than N children. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that an N-ary tree can be serialized to a string and this string can be deserialized to the original tree structure.

For example, you may serialize the following `3-ary` tree
as `[1 [3[5 6] 2 4]]`. Note that this is just an example, you do not necessarily need to follow this format.

Or you can follow LeetCode's level order traversal serialization format, where each group of children is separated by the null value.

For example, the above tree may be serialized as `[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]`.

You do not necessarily need to follow the above suggested formats, there are many more different formats that work so please be creative and come up with different approaches yourself.


Constraints:
The number of nodes in the tree is in the range `[0, 104]`.

`0 <= Node.val <= 104`
The height of the n-ary tree is less than or equal to `1000`
Do not use class member/global/static variables to store states. Your encode and decode algorithms should be stateless.",1,/articles/serialize-and-deserialize-n-ary-tree,61.8,39.3,https://leetcode.com/problems/serialize-and-deserialize-n-ary-tree,284,46K,74.5K,"Microsoft,Apple,Google,Amazon",Tree,597,32,95,1,"[Serialize and Deserialize Binary Tree, /problems/serialize-and-deserialize-binary-tree/, Hard], [Serialize and Deserialize BST, /problems/serialize-and-deserialize-bst/, Medium], [Encode N-ary Tree to Binary Tree, /problems/encode-n-ary-tree-to-binary-tree/, Hard]"
79,431,Encode N-ary Tree to Binary Tree,"Design an algorithm to encode an N-ary tree into a binary tree and decode the binary tree to get the original N-ary tree. An N-ary tree is a rooted tree in which each node has no more than N children. Similarly, a binary tree is a rooted tree in which each node has no more than 2 children. There is no restriction on how your encode/decode algorithm should work. You just need to ensure that an N-ary tree can be encoded to a binary tree and this binary tree can be decoded to the original N-nary tree structure.

Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See following example).

For example, you may encode the following `3-ary` tree to a binary tree in this way:
Input: root = [1,null,3,2,4,null,5,6]
Note that the above is just an example which might or might not work. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.


Constraints:
The height of the n-ary tree is less than or equal to `1000`
The total number of nodes is between `[0, 10^4]`
Do not use class member/global/static variables to store states. Your encode and decode algorithms should be stateless.",1,/articles/encode-n-ary-tree-to-binary-tree,74.9,14.8,https://leetcode.com/problems/encode-n-ary-tree-to-binary-tree,89,11.5K,15.3K,Flipkart,Tree,290,17,94,0,"[Serialize and Deserialize N-ary Tree, /problems/serialize-and-deserialize-n-ary-tree/, Hard]"
80,432,All O`one Data Structure,"Implement a data structure supporting the following operations:
Inc(Key) - Inserts a new key  with value 1. Or increments an existing key by 1. Key is guaranteed to be a non-empty string.

Dec(Key) - If Key's value is 1, remove it from the data structure. Otherwise decrements an existing key by 1. If the key does not exist, this function does nothing. Key is guaranteed to be a non-empty string.

GetMaxKey() - Returns one of the keys with maximal value. If no element exists, return an empty string `""""`.

GetMinKey() - Returns one of the keys with minimal value. If no element exists, return an empty string `""""`.

Challenge: Perform all these in O(1) time complexity.",0,,33.2,49.4,https://leetcode.com/problems/all-oone-data-structure,349,39K,117.4K,Amazon,Design,767,91,89,1,
81,440,K-th Smallest in Lexicographical Order,"Given integers `n` and `k`, find the lexicographically k-th smallest integer in the range from `1` to `n`.

Note: 1 ≤ k ≤ n ≤ 109.


Example:
Input:
n: 13   k: 2
Output:
10
Explanation:
The lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10.",0,,29.9,10.6,https://leetcode.com/problems/k-th-smallest-in-lexicographical-order,72,15K,50.2K,"ByteDance,Hulu",,415,60,87,0,
82,446,Arithmetic Slices II - Subsequence,"A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.

For example, these are arithmetic sequences:
1, 3, 5, 7, 9
7, 7, 7, 7
3, -1, -5, -9
The following sequence is not arithmetic.

1, 1, 2, 5, 7
A zero-indexed array A consisting of N numbers is given. A subsequence slice of that array is any sequence of integers (P0, P1, ..., Pk) such that 0 ≤ P0 < P1 < ... < Pk < N.

A subsequence slice (P0, P1, ..., Pk) of array A is called arithmetic if the sequence A[P0], A[P1], ..., A[Pk-1], A[Pk] is arithmetic. In particular, this means that k ≥ 2.

The function should return the number of arithmetic subsequence slices in the array A.

The input contains N integers. Every integer is in the range of -231 and 231-1 and 0 ≤ N ≤ 1000. The output is guaranteed to be less than 231-1.


Example:
Input: [2, 4, 6, 8, 10]
Output: 7
Explanation:
All arithmetic subsequence slices are:
[2,4,6]
[4,6,8]
[6,8,10]
[2,4,6,8]
[4,6,8,10]
[2,4,6,8,10]
[2,6,10]",0,/articles/arithmetic-slices-ii-subsequence,33.6,19.6,https://leetcode.com/problems/arithmetic-slices-ii-subsequence,111,24.9K,74.2K,Google,Dynamic Programming,686,66,91,1,"[Arithmetic Slices, /problems/arithmetic-slices/, Medium]"
83,458,Poor Pigs,"There are `buckets` buckets of liquid, where exactly one of the buckets is poisonous. To figure out which one is poisonous, you feed some number of (poor) pigs the liquid to see whether they will die or not. Unfortunately, you only have `minutesToTest` minutes to determine which bucket is poisonous.

You can feed the pigs according to these steps:
Choose some live pigs to feed.

For each pig, choose which buckets to feed it. The pig will consume all the chosen buckets simultaneously and will take no time.

Wait for `minutesToDie` minutes. You may not feed any other pigs during this time.

After `minutesToDie` minutes have passed, any pigs that have been fed the poisonous bucket will die, and all others will survive.

Repeat this process until you run out of time.

Given `buckets`, `minutesToDie`, and `minutesToTest`, return the minimum number of pigs needed to figure out which bucket is poisonous within the allotted time.


Example 1:
Input: buckets = 1000, minutesToDie = 15, minutesToTest = 60
Output: 5

Example 2:
Input: buckets = 4, minutesToDie = 15, minutesToTest = 15
Output: 2

Example 3:
Input: buckets = 4, minutesToDie = 15, minutesToTest = 30
Output: 2

Constraints:
`1 <= buckets <= 1000`
`1 <= minutesToDie <= minutesToTest <= 100`",0,/articles/poor-pigs,54.6,14.0,https://leetcode.com/problems/poor-pigs,137,30.9K,56.5K,,,548,1035,35,0,
84,460,LFU Cache,"Design and implement a data structure for a Least Frequently Used (LFU) cache.

Implement the `LFUCache` class:
`LFUCache(int capacity)` Initializes the object with the `capacity` of the data structure.

`int get(int key)` Gets the value of the `key` if the `key` exists in the cache. Otherwise, returns `-1`.

`void put(int key, int value)` Update the value of the `key` if present, or inserts the `key` if not already present. When the cache reaches its `capacity`, it should invalidate and remove the least frequently used key before inserting a new item. For this problem, when there is a tie (i.e., two or more keys with the same frequency), the least recently used `key` would be invalidated.

To determine the least frequently used key, a use counter is maintained for each key in the cache. The key with the smallest use counter is the least frequently used key.

When a key is first inserted into the cache, its use counter is set to `1` (due to the `put` operation). The use counter for a key in the cache is incremented either a `get` or `put` operation is called on it.


Example 1:
Input
[""LFUCache"", ""put"", ""put"", ""get"", ""put"", ""get"", ""get"", ""put"", ""get"", ""get"", ""get""]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]
Output
[null, null, null, 1, null, -1, 3, null, -1, 3, 4]
Explanation
// cnt(x) = the use counter for key x
// cache=[] will show the last used order for tiebreakers (leftmost element is  most recent)
LFUCache lfu = new LFUCache(2);
lfu.put(1, 1);   // cache=[1,_], cnt(1)=1
lfu.put(2, 2);   // cache=[2,1], cnt(2)=1, cnt(1)=1
lfu.get(1);      // return 1
                 // cache=[1,2], cnt(2)=1, cnt(1)=2
lfu.put(3, 3);   // 2 is the LFU key because cnt(2)=1 is the smallest, invalidate 2.

                 // cache=[3,1], cnt(3)=1, cnt(1)=2
lfu.get(2);      // return -1 (not found)
lfu.get(3);      // return 3
                 // cache=[3,1], cnt(3)=2, cnt(1)=2
lfu.put(4, 4);   // Both 1 and 3 have the same cnt, but 1 is LRU, invalidate 1.

                 // cache=[4,3], cnt(4)=1, cnt(3)=2
lfu.get(1);      // return -1 (not found)
lfu.get(3);      // return 3
                 // cache=[3,4], cnt(4)=1, cnt(3)=3
lfu.get(4);      // return 4
                 // cache=[3,4], cnt(4)=2, cnt(3)=3

Constraints:
`0 <= capacity, key, value <= 104`
At most `105` calls will be made to `get` and `put`.

Follow up: Could you do both operations in `O(1)` time complexity?",0,,36.4,81.8,https://leetcode.com/problems/lfu-cache,675,103.5K,284.3K,"Amazon,Microsoft,Google,Citadel,Bloomberg,Salesforce,Twitch",Design,1935,150,93,1,"[LRU Cache, /problems/lru-cache/, Medium], [Design In-Memory File System, /problems/design-in-memory-file-system/, Hard]"
85,465,Optimal Account Balancing,"A group of friends went on holiday and sometimes lent each other money. For example, Alice paid for Bill's lunch for $10. Then later Chris gave Alice $5 for a taxi ride. We can model each transaction as a tuple (x, y, z) which means person x gave person y $z. Assuming Alice, Bill, and Chris are person 0, 1, and 2 respectively (0, 1, 2 are the person's ID), the transactions can be represented as `[[0, 1, 10], [2, 0, 5]]`.

Given a list of transactions between a group of people, return the minimum number of transactions required to settle the debt.

Note:
A transaction will be given as a tuple (x, y, z). Note that `x ≠ y` and `z > 0`.

Person's IDs may not be linear, e.g. we could have the persons 0, 1, 2 or we could also have the persons 0, 2, 6.


Example 1:
Input:
[[0,1,10], [2,0,5]]
Output:
2
Explanation:
Person #0 gave person #1 $10.

Person #2 gave person #0 $5.

Two transactions are needed. One way to settle the debt is person #1 pays person #0 and #2 $5 each.


Example 2:
Input:
[[0,1,10], [1,0,1], [1,2,5], [2,0,5]]
Output:
1
Explanation:
Person #0 gave person #1 $10.

Person #1 gave person #0 $1.

Person #1 gave person #2 $5.

Person #2 gave person #0 $5.

Therefore, person #1 only need to give person #0 $4, and all debt is settled.",1,,48.4,53.5,https://leetcode.com/problems/optimal-account-balancing,136,46.6K,96.2K,"Google,Uber",,759,74,91,1,
86,466,Count The Repetitions,"Define `S = [s,n]` as the string S which consists of n connected strings s. For example, `[""abc"", 3]` =""abcabcabc"". 
On the other hand, we define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1. For example, “abc”  can be obtained from “abdbec” based on our definition, but it can not be obtained from “acbbe”.

You are given two non-empty strings s1 and s2 (each at most 100 characters long) and two integers 0 ≤ n1 ≤ 106 and 1 ≤ n2 ≤ 106. Now consider the strings S1 and S2, where `S1=[s1,n1]` and `S2=[s2,n2]`. Find the maximum integer M such that `[S2,M]` can be obtained from `S1`.


Example:
Input:
s1=""acb"", n1=4
s2=""ab"", n2=2
Return:
2",0,/articles/count-the-repetitions,28.6,17.2,https://leetcode.com/problems/count-the-repetitions,73,12.3K,42.8K,Amazon,Dynamic Programming,218,200,52,1,
87,471,Encode String with Shortest Length,"Given a non-empty string, encode the string such that its encoded length is the shortest.

The encoding rule is: `k[encoded_string]`, where the `encoded_string` inside the square brackets is being repeated exactly `k` times.

Note:
`k` will be a positive integer.

If an encoding process does not make the string shorter, then do not encode it. If there are several solutions, return any of them.


Example 1:
Input: s = ""aaa""
Output: ""aaa""
Explanation: There is no way to encode it such that it is shorter than the input string, so we do not encode it.


Example 2:
Input: s = ""aaaaa""
Output: ""5[a]""
Explanation: ""5[a]"" is shorter than ""aaaaa"" by 1 character.


Example 3:
Input: s = ""aaaaaaaaaa""
Output: ""10[a]""
Explanation: ""a9[a]"" or ""9[a]a"" are also valid solutions, both of them have the same length = 5, which is the same as ""10[a]"".


Example 4:
Input: s = ""aabcaabcd""
Output: ""2[aabc]d""
Explanation: ""aabc"" occurs twice, so one answer can be ""2[aabc]d"".


Example 5:
Input: s = ""abbbabbbcabbbabbbc""
Output: ""2[2[abbb]c]""
Explanation: ""abbbabbbc"" occurs twice, but ""abbbabbbc"" can also be encoded to ""2[abbb]c"", so one answer can be ""2[2[abbb]c]"".


Constraints:
`1 <= s.length <= 150`
`s` consists of only lowercase English letters.",1,,49.6,48.5,https://leetcode.com/problems/encode-string-with-shortest-length,83,23.4K,47.2K,"Google,Amazon",Dynamic Programming,472,26,95,1,"[Decode String, /problems/decode-string/, Medium], [Number of Atoms, /problems/number-of-atoms/, Hard]"
88,472,Concatenated Words,"Given an array of strings `words` (without duplicates), return all the concatenated words in the given list of `words`.

A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.


Example 1:
Input: words = [""cat"",""cats"",""catsdogcats"",""dog"",""dogcatsdog"",""hippopotamuses"",""rat"",""ratcatdogcat""]
Output: [""catsdogcats"",""dogcatsdog"",""ratcatdogcat""]
Explanation: ""catsdogcats"" can be concatenated by ""cats"", ""dog"" and ""cats""; 
""dogcatsdog"" can be concatenated by ""dog"", ""cats"" and ""dog""; 
""ratcatdogcat"" can be concatenated by ""rat"", ""cat"", ""dog"" and ""cat"".


Example 2:
Input: words = [""cat"",""dog"",""catdog""]
Output: [""catdog""]

Constraints:
`1 <= words.length <= 104`
`0 <= words[i].length <= 1000`
`words[i]` consists of only lowercase English letters.

`0 <= sum(words[i].length) <= 6 * 105`",0,,43.7,50.3,https://leetcode.com/problems/concatenated-words,471,90.3K,206.5K,Amazon,"Dynamic Programming,Depth-first Search,Trie",1133,146,89,1,"[Word Break II, /problems/word-break-ii/, Hard]"
89,479,Largest Palindrome Product,"Find the largest palindrome made from the product of two n-digit numbers.

Since the result could be very large, you should return the largest palindrome mod 1337.


Example:
Input: 2
Output: 987
Explanation: 99 x 91 = 9009, 9009 % 1337 = 987
Note:
The range of n is [1,8].",0,,29.7,43.0,https://leetcode.com/problems/largest-palindrome-product,83,18K,60.6K,Yahoo,,100,1372,7,0,
90,480,Sliding Window Median,"Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.


Examples:
`[2,3,4]` , the median is `3`
`[2,3]`, the median is `(2 + 3) / 2 = 2.5`
Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Your job is to output the median array for each window in the original array.

For example,
Given nums = `[1,3,-1,-3,5,3,6,7]`, and k = 3.

Window position                Median
---------------               -----
[1  3  -1] -3  5  3  6  7       1
 1 [3  -1  -3] 5  3  6  7       -1
 1  3 [-1  -3  5] 3  6  7       -1
 1  3  -1 [-3  5  3] 6  7       3
 1  3  -1  -3 [5  3  6] 7       5
 1  3  -1  -3  5 [3  6  7]      6
Therefore, return the median sliding window as `[1,-1,-1,3,5,6]`.

Note: 
You may assume `k` is always valid, ie: `k` is always smaller than input array's size for non-empty array.

Answers within `10^-5` of the actual value will be accepted as correct.",0,/articles/sliding-window-median,38.9,53.2,https://leetcode.com/problems/sliding-window-median,435,73.5K,188.8K,"Facebook,Spotify,JPMorgan,Google,Amazon,Flipkart,Adobe",Sliding Window,1357,97,93,1,"[Find Median from Data Stream, /problems/find-median-from-data-stream/, Hard]"
91,483,Smallest Good Base,"For an integer n, we call k>=2 a good base of n, if all digits of n base k are 1.

Now given a string representing n, you should return the smallest good base of n in string format.


Example 1:
Input: ""13""
Output: ""3""
Explanation: 13 base 3 is 111.


Example 2:
Input: ""4681""
Output: ""8""
Explanation: 4681 base 8 is 11111.


Example 3:
Input: ""1000000000000000000""
Output: ""999999999999999999""
Explanation: 1000000000000000000 base 999999999999999999 is 11.

Note:
The range of n is [3, 10^18].

The string representing n is always valid and will not have leading zeros.",0,,36.3,0.0,https://leetcode.com/problems/smallest-good-base,55,14.3K,39.3K,Google,"Math,Binary Search",193,367,34,1,
92,488,Zuma Game,"Think about Zuma Game. You have a row of balls on the table, colored red(R), yellow(Y), blue(B), green(G), and white(W). You also have several balls in your hand.

Each time, you may choose a ball in your hand, and insert it into the row (including the leftmost place and rightmost place). Then, if there is a group of 3 or more balls in the same color touching, remove these balls. Keep doing this until no more balls can be removed.

Find the minimal balls you have to insert to remove all the balls on the table. If you cannot remove all the balls, output -1.


Example 1:
Input: board = ""WRRBBW"", hand = ""RB""
Output: -1
Explanation: WRRBBW -> WRR[R]BBW -> WBBW -> WBB[B]W -> WW

Example 2:
Input: board = ""WWRRBBWW"", hand = ""WRBRW""
Output: 2
Explanation: WWRRBBWW -> WWRR[R]BBWW -> WWBBWW -> WWBB[B]WW -> WWWW -> empty

Example 3:
Input: board = ""G"", hand = ""GGGGG""
Output: 2
Explanation: G -> G[G] -> GG[G] -> empty 

Example 4:
Input: board = ""RBYYBBRRB"", hand = ""YRBGB""
Output: 3
Explanation: RBYYBBRRB -> RBYY[Y]BBRRB -> RBBBRRB -> RRRB -> B -> B[B] -> BB[B] -> empty 

Constraints:
You may assume that the initial row of balls on the table won’t have any 3 or more consecutive balls with the same color.

`1 <= board.length <= 16`
`1 <= hand.length <= 5`
Both input strings will be non-empty and only contain characters 'R','Y','B','G','W'.",0,,38.2,42.5,https://leetcode.com/problems/zuma-game,143,16.5K,43.2K,"Salesforce,Bloomberg",Depth-first Search,277,301,48,0,
93,489,Robot Room Cleaner,"Given a robot cleaner in a room modeled as a grid.

Each cell in the grid can be empty or blocked.

The robot cleaner with 4 given APIs can move forward, turn left or turn right. Each turn it made is 90 degrees.

When it tries to move into a blocked cell, its bumper sensor detects the obstacle and it stays on the current cell.

Design an algorithm to clean the entire room using only the 4 given APIs shown below.

interface Robot {
  // returns true if next cell is open and robot moves into the cell.

  // returns false if next cell is obstacle and robot stays on the current cell.

  boolean move();
  // Robot will stay on the same cell after calling turnLeft/turnRight.

  // Each turn will be 90 degrees.

  void turnLeft();
  void turnRight();
  // Clean the current cell.

  void clean();
}

Example:
Input:
room = [
  [1,1,1,1,1,0,1,1],
  [1,1,1,1,1,0,1,1],
  [1,0,1,1,1,1,1,1],
  [0,0,0,1,0,0,0,0],
  [1,1,1,1,1,1,1,1]
],
row = 1,
col = 3
Explanation:
All grids in the room are marked by either 0 or 1.

0 means the cell is blocked, while 1 means the cell is accessible.

The robot initially starts at the position of row=1, col=3.

From the top left corner, its position is one row below and three columns right.

Notes:
The input is only given to initialize the room and the robot's position internally. You must solve this problem ""blindfolded"". In other words, you must control the robot using only the mentioned 4 APIs, without knowing the room layout and the initial robot's position.

The robot's initial position will always be in an accessible cell.

The initial direction of the robot will be facing up.

All accessible cells are connected, which means the all cells marked as 1 will be accessible by the robot.

Assume all four edges of the grid are all surrounded by wall.",1,/articles/robot-room-cleaner,72.9,53.7,https://leetcode.com/problems/robot-room-cleaner,269,76.5K,105K,"Facebook,Google,Amazon",Depth-first Search,1478,85,95,1,"[Walls and Gates, /problems/walls-and-gates/, Medium], [Shortest Path in a Hidden Grid, /problems/shortest-path-in-a-hidden-grid/, Medium], [Minimum Path Cost in a Hidden Grid, /problems/minimum-path-cost-in-a-hidden-grid/, Medium]"
94,493,Reverse Pairs,"Given an array `nums`, we call `(i, j)` an important reverse pair if `i < j` and `nums[i] > 2*nums[j]`.

You need to return the number of important reverse pairs in the given array.


Example1:
Input: [1,3,2,3,1]
Output: 2

Example2:
Input: [2,4,3,5,1]
Output: 3
Note:
The length of the given array will not exceed `50,000`.

All the numbers in the input array are in the range of 32-bit integer.",0,/articles/reverse-pairs,27.1,51.0,https://leetcode.com/problems/reverse-pairs,291,53.2K,196K,"ByteDance,Amazon,Google","Binary Search,Divide and Conquer,Sort,Binary Indexed Tree,Segment Tree",1330,140,90,1,"[Count of Smaller Numbers After Self, /problems/count-of-smaller-numbers-after-self/, Hard], [Count of Range Sum, /problems/count-of-range-sum/, Hard]"
95,499,The Maze III,"There is a ball in a `maze` with empty spaces (represented as `0`) and walls (represented as `1`). The ball can go through the empty spaces by rolling up, down, left or right, but it won't stop rolling until hitting a wall. When the ball stops, it could choose the next direction. There is also a hole in this maze. The ball will drop into the hole if it rolls onto the hole.

Given the `m x n` `maze`, the ball's position `ball` and the hole's position `hole`, where `ball = [ballrow, ballcol]` and `hole = [holerow, holecol]`, return a string `instructions` of all the instructions that the ball should follow to drop in the hole with the shortest distance possible. If there are multiple valid instructions, return the lexicographically minimum one. If the ball can't drop in the hole, return `""impossible""`.

If there is a way for the ball to drop in the hole, the answer `instructions` should contain the characters `'u'` (i.e., up), `'d'` (i.e., down), `'l'` (i.e., left), and `'r'` (i.e., right).

The distance is the number of empty spaces traveled by the ball from the start position (excluded) to the destination (included).

You may assume that the borders of the maze are all walls (see examples).


Example 1:
Input: maze = [[0,0,0,0,0],[1,1,0,0,1],[0,0,0,0,0],[0,1,0,0,1],[0,1,0,0,0]], ball = [4,3], hole = [0,1]
Output: ""lul""
Explanation: There are two shortest ways for the ball to drop into the hole.

The first way is left -> up -> left, represented by ""lul"".

The second way is up -> left, represented by 'ul'.

Both ways have shortest distance 6, but the first way is lexicographically smaller because 'l' < 'u'. So the output is ""lul"".


Example 2:
Input: maze = [[0,0,0,0,0],[1,1,0,0,1],[0,0,0,0,0],[0,1,0,0,1],[0,1,0,0,0]], ball = [4,3], hole = [3,0]
Output: ""impossible""
Explanation: The ball cannot reach the hole.


Example 3:
Input: maze = [[0,0,0,0,0,0,0],[0,0,1,0,0,1,0],[0,0,0,0,1,0,0],[0,0,0,0,0,0,1]], ball = [0,4], hole = [3,5]
Output: ""dldr""

Constraints:
`m == maze.length`
`n == maze[i].length`
`1 <= m, n <= 100`
`maze[i][j]` is `0` or `1`.

`ball.length == 2`
`hole.length == 2`
`0 <= ballrow, holerow <= m`
`0 <= ballcol, holecol <= n`
Both the ball and the hole exist in an empty space, and they will not be in the same position initially.

The maze contains at least 2 empty spaces.",1,,42.6,0.0,https://leetcode.com/problems/the-maze-iii,144,17.5K,41.2K,Google,"Depth-first Search,Breadth-first Search",241,47,84,1,"[The Maze, /problems/the-maze/, Medium], [The Maze II, /problems/the-maze-ii/, Medium]"
96,502,IPO,"Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most k distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most k distinct projects. 
You are given several projects. For each project i, it has a pure profit Pi and a minimum capital of Ci is needed to start the corresponding project. Initially, you have W capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.

To sum up, pick a list of at most k distinct projects from given projects to maximize your final capital, and output your final maximized capital.


Example 1:
Input: k=2, W=0, Profits=[1,2,3], Capital=[0,1,1].
Output: 4
Explanation: Since your initial capital is 0, you can only start the project indexed 0.

             After finishing it you will obtain profit 1 and your capital becomes 1.

             With capital 1, you can either start the project indexed 1 or the project indexed 2.

             Since you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital.

             Therefore, output the final maximized capital, which is 0 + 1 + 3 = 4.

Note:
You may assume all numbers in the input are non-negative integers.

The length of Profits array and Capital array will not exceed 50,000.

The answer is guaranteed to fit in a 32-bit signed integer.",0,/articles/ipo,41.8,23.1,https://leetcode.com/problems/ipo,177,22.6K,53.9K,Amazon,"Heap,Greedy",502,49,91,1,
97,514,Freedom Trail,"In the video game Fallout 4, the quest ""Road to Freedom"" requires players to reach a metal dial called the ""Freedom Trail Ring"", and use the dial to spell a specific keyword in order to open the door.

Given a string ring, which represents the code engraved on the outer ring and another string key, which represents the keyword needs to be spelled. You need to find the minimum number of steps in order to spell all the characters in the keyword.

Initially, the first character of the ring is aligned at 12:00 direction. You need to spell all the characters in the string key one by one by rotating the ring clockwise or anticlockwise to make each character of the string key aligned at 12:00 direction and then by pressing the center button.

At the stage of rotating the ring to spell the key character key[i]:
You can rotate the ring clockwise or anticlockwise one place, which counts as 1 step. The final purpose of the rotation is to align one of the string ring's characters at the 12:00 direction, where this character must equal to the character key[i].

If the character key[i] has been aligned at the 12:00 direction, you need to press the center button to spell, which also counts as 1 step. After the pressing, you could begin to spell the next character in the key (next stage), otherwise, you've finished all the spelling.


Example:
Input: ring = ""godding"", key = ""gd""
Output: 4
Explanation:
For the first key character 'g', since it is already in place, we just need 1 step to spell this character. 
For the second key character 'd', we need to rotate the ring ""godding"" anticlockwise by two steps to make it become ""ddinggo"".

Also, we need 1 more step for spelling.

So the final output is 4.

Note:
Length of both ring and key will be in range 1 to 100.

There are only lowercase letters in both strings and might be some duplcate characters in both strings.

It's guaranteed that string key could always be spelled by rotating the string ring.",0,,45.0,0.0,https://leetcode.com/problems/freedom-trail,187,22.4K,49.7K,DE Shaw,"Divide and Conquer,Dynamic Programming,Depth-first Search",522,27,95,0,
98,517,Super Washing Machines,"You have n super washing machines on a line. Initially, each washing machine has some dresses or is empty. 
For each move, you could choose any m (1 ≤ m ≤ n) washing machines, and pass one dress of each washing machine to one of its adjacent washing machines  at the same time .  
Given an integer array representing the number of dresses in each washing machine from left to right on the line, you should find the minimum number of moves to make all the washing machines have the same number of dresses. If it is not possible to do it, return -1.


Example1
Input: [1,0,5]
Output: 3
Explanation: 
1st move:    1     0 <-- 5    =>    1     1     4
2nd move:    1 <-- 1 <-- 4    =>    2     1     3    
3rd move:    2     1 <-- 3    =>    2     2     2   

Example2
Input: [0,3,0]
Output: 2
Explanation: 
1st move:    0 <-- 3     0    =>    1     2     0    
2nd move:    1     2 --> 0    =>    1     1     1     

Example3
Input: [0,2,0]
Output: -1
Explanation: 
It's impossible to make all the three washing machines have the same number of dresses. 
Note:
The range of n is [1, 10000].

The range of dresses number in a super washing machine is [0, 1e5].",0,/articles/super-washing-machines,38.7,9.6,https://leetcode.com/problems/super-washing-machines,85,18.8K,48.6K,Amazon,"Math,Dynamic Programming",405,163,71,1,
99,527,Word Abbreviation,"Given an array of n distinct non-empty strings, you need to generate minimal possible abbreviations for every word following rules below.

Begin with the first character and then the number of characters abbreviated, which followed by the last character.

If there are any conflict, that is more than one words share the same abbreviation, a longer prefix is used instead of only the first character until making the map from word to abbreviation become unique. In other words, a final abbreviation cannot map to more than one original words.

 If the abbreviation doesn't make the word shorter, then keep it as original.


Example:
Input: [""like"", ""god"", ""internal"", ""me"", ""internet"", ""interval"", ""intension"", ""face"", ""intrusion""]
Output: [""l2e"",""god"",""internal"",""me"",""i6t"",""interval"",""inte4n"",""f2e"",""intr4n""]
Note:
 Both n and the length of each word will not exceed 400.

 The length of each word is greater than 1.

 The words consist of lowercase English letters only.

 The return answers should be in the same order as the original array.",1,/articles/word-abbreviation,56.4,0.0,https://leetcode.com/problems/word-abbreviation,121,19K,33.8K,Google,"String,Sort",248,163,60,1,"[Valid Word Abbreviation, /problems/valid-word-abbreviation/, Easy], [Minimum Unique Word Abbreviation, /problems/minimum-unique-word-abbreviation/, Hard]"
100,546,Remove Boxes,"You are given several `boxes` with different colors represented by different positive numbers.

You may experience several rounds to remove boxes until there is no box left. Each time you can choose some continuous boxes with the same color (i.e., composed of `k` boxes, `k >= 1`), remove them and get `k * k` points.

Return the maximum points you can get.


Example 1:
Input: boxes = [1,3,2,2,2,3,4,3,1]
Output: 23
Explanation:
[1, 3, 2, 2, 2, 3, 4, 3, 1] 
----> [1, 3, 3, 4, 3, 1] (3*3=9 points) 
----> [1, 3, 3, 3, 1] (1*1=1 points) 
----> [1, 1] (3*3=9 points) 
----> [] (2*2=4 points)

Example 2:
Input: boxes = [1,1,1]
Output: 9

Example 3:
Input: boxes = [1]
Output: 1

Constraints:
`1 <= boxes.length <= 100`
`1 <= boxes[i] <= 100`",0,/articles/remove-boxes,44.1,11.7,https://leetcode.com/problems/remove-boxes,75,18.7K,42.5K,"Apple,Amazon","Dynamic Programming,Depth-first Search",847,58,94,1,"[Strange Printer, /problems/strange-printer/, Hard]"
101,552,Student Attendance Record II,"An attendance record for a student can be represented as a string where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters:
`'A'`: Absent.

`'L'`: Late.

`'P'`: Present.

Any student is eligible for an attendance award if they meet both of the following criteria:
The student was absent (`'A'`) for strictly fewer than 2 days total.

The student was never late (`'L'`) for 3 or more consecutive days.

Given an integer `n`, return the number of possible attendance records of length `n` that make a student eligible for an attendance award. The answer may be very large, so return it modulo `109 + 7`.


Example 1:
Input: n = 2
Output: 8
Explanation: There are 8 records with length 2 that are eligible for an award:
""PP"", ""AP"", ""PA"", ""LP"", ""PL"", ""AL"", ""LA"", ""LL""
Only ""AA"" is not eligible because there are 2 absences (there need to be fewer than 2).


Example 2:
Input: n = 1
Output: 3

Example 3:
Input: n = 10101
Output: 183236316

Constraints:
`1 <= n <= 105`",0,/articles/student-attendance-record-ii,37.7,25.9,https://leetcode.com/problems/student-attendance-record-ii,208,29.8K,79K,Google,Dynamic Programming,719,129,85,1,"[Student Attendance Record I, /problems/student-attendance-record-i/, Easy]"
102,564,Find the Closest Palindrome,"Given an integer n, find the closest integer (not including itself), which is a palindrome. 
The 'closest' is defined as absolute difference minimized between two integers.


Example 1:
Input: ""123""
Output: ""121""
Note:
The input n is a positive integer represented by string, whose length will not exceed 18.

If there is a tie, return the smaller one as answer.",0,/articles/find-the-closest-palindrome,20.3,57.4,https://leetcode.com/problems/find-the-closest-palindrome,169,25.3K,124.5K,"Microsoft,Amazon",String,352,967,27,1,
103,568,Maximum Vacation Days,"LeetCode wants to give one of its best employees the option to travel among N cities to collect algorithm problems. But all work and no play makes Jack a dull boy, you could take vacations in some particular cities and weeks. Your job is to schedule the traveling to maximize the number of vacation days you could take, but there are certain rules and restrictions you need to follow.

Rules and restrictions:
You can only travel among N cities, represented by indexes from 0 to N-1. Initially, you are in the city indexed 0 on Monday.

The cities are connected by flights. The flights are represented as a N*N matrix (not necessary symmetrical), called flights representing the airline status from the city i to the city j. If there is no flight from the city i to the city j, flights[i][j] = 0; Otherwise, flights[i][j] = 1. Also, flights[i][i] = 0 for all i.

You totally have K weeks (each week has 7 days) to travel. You can only take flights at most once per day and can only take flights on each week's Monday morning. Since flight time is so short, we don't consider the impact of flight time.

For each city, you can only have restricted vacation days in different weeks, given an N*K matrix called days representing this relationship. For the value of days[i][j], it represents the maximum days you could take vacation in the city i in the week j.

You're given the flights matrix and days matrix, and you need to output the maximum vacation days you could take during K weeks.


Example 1:
Input:flights = [[0,1,1],[1,0,1],[1,1,0]], days = [[1,3,1],[6,0,3],[3,3,3]]
Output: 12
Explanation: Ans = 6 + 3 + 3 = 12. 
One of the best strategies is:
1st week : fly from city 0 to city 1 on Monday, and play 6 days and work 1 day. (Although you start at city 0, we could also fly to and start at other cities since it is Monday.) 
2nd week : fly from city 1 to city 2 on Monday, and play 3 days and work 4 days.

3rd week : stay at city 2, and play 3 days and work 4 days.


Example 2:
Input:flights = [[0,0,0],[0,0,0],[0,0,0]], days = [[1,1,1],[7,7,7],[7,7,7]]
Output: 3
Explanation: Ans = 1 + 1 + 1 = 3. 
Since there is no flights enable you to move to another city, you have to stay at city 0 for the whole 3 weeks. For each week, you only have one day to play and six days to work. So the maximum number of vacation days is 3.


Example 3:
Input:flights = [[0,1,1],[1,0,1],[1,1,0]], days = [[7,0,0],[0,7,0],[0,0,7]]
Output: 21
Explanation:Ans = 7 + 7 + 7 = 21
One of the best strategies is:
1st week : stay at city 0, and play 7 days. 
2nd week : fly from city 0 to city 1 on Monday, and play 7 days.

3rd week : fly from city 1 to city 2 on Monday, and play 7 days.

Note:
N and K are positive integers, which are in the range of [1, 100].

In the matrix flights, all the values are integers in the range of [0, 1].

In the matrix days, all the values are integers in the range [0, 7].

You could stay at a city beyond the number of vacation days, but you should work on the extra days, which won't be counted as vacation days.

If you fly from the city A to the city B and take the vacation on that day, the deduction towards vacation days will count towards the vacation days of city B in that week.

We don't consider the impact of flight hours towards the calculation of vacation days.",1,/articles/maximum-vacation-days,41.7,0.0,https://leetcode.com/problems/maximum-vacation-days,140,27.6K,66.1K,"Google,Facebook",Dynamic Programming,365,61,86,1,"[Cheapest Flights Within K Stops, /problems/cheapest-flights-within-k-stops/, Medium]"
104,569,Median Employee Salary,SQL Schema,1,/articles/median-employee-salary,62.3,2.1,https://leetcode.com/problems/median-employee-salary,260,16K,25.7K,Google,,131,78,63,1,
105,571,Find Median Given Frequency of Numbers,SQL Schema,1,,45.6,4.6,https://leetcode.com/problems/find-median-given-frequency-of-numbers,146,11.8K,25.9K,Pinterest,,138,48,74,0,
106,579,Find Cumulative Salary of an Employee,SQL Schema,1,/articles/find-cumulative-salary-of-an-employee,38.5,3.1,https://leetcode.com/problems/find-cumulative-salary-of-an-employee,329,17.6K,45.8K,Amazon,,126,278,31,1,
107,587,Erect the Fence,"There are some trees, where each tree is represented by (x,y) coordinate in a two-dimensional garden. Your job is to fence the entire garden using the minimum length of rope as it is expensive. The garden is well fenced only if all the trees are enclosed. Your task is to help find the coordinates of trees which are exactly located on the fence perimeter.


Example 1:
Input: [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]
Output: [[1,1],[2,0],[4,2],[3,3],[2,4]]
Explanation:

Example 2:
Input: [[1,2],[2,2],[4,2]]
Output: [[1,2],[2,2],[4,2]]
Explanation:
Even you only have trees in a line, you need to use rope to enclose them. 
Note:
All trees should be enclosed together. You cannot cut the rope to enclose trees that will separate them in more than one group.

All input integers will range from 0 to 100.

The garden has at least one tree.

All coordinates are distinct.

Input points have NO order. No order required for output.
input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.",0,/articles/erect-the-fence,36.6,6.8,https://leetcode.com/problems/erect-the-fence,74,10.9K,29.7K,Google,Geometry,284,198,59,1,
108,588,Design In-Memory File System,"Design an in-memory file system to simulate the following functions:
`ls`: Given a path in string format. If it is a file path, return a list that only contains this file's name. If it is a directory path, return the list of file and directory names in this directory. Your output (file and directory names together) should in lexicographic order.

`mkdir`: Given a directory path that does not exist, you should make a new directory according to the path. If the middle directories in the path don't exist either, you should create them as well. This function has void return type.

`addContentToFile`: Given a file path and file content in string format. If the file doesn't exist, you need to create that file containing given content. If the file already exists, you need to append given content to original content. This function has void return type.

`readContentFromFile`: Given a file path, return its content in string format.


Example:
Input: 
[""FileSystem"",""ls"",""mkdir"",""addContentToFile"",""ls"",""readContentFromFile""]
[[],[""/""],[""/a/b/c""],[""/a/b/c/d"",""hello""],[""/""],[""/a/b/c/d""]]
Output:
[null,[],null,null,[""a""],""hello""]
Explanation:
Note:
You can assume all file or directory paths are absolute paths which begin with `/` and do not end with `/` except that the path is just `""/""`.

You can assume that all operations will be passed valid parameters and users will not attempt to retrieve file content or list a directory or file that does not exist.

You can assume that all directory names and file names only contain lower-case letters, and same names won't exist in the same directory.",1,/articles/design-in-memory-file-system,46.7,87.0,https://leetcode.com/problems/design-in-memory-file-system,239,31.3K,67K,"Amazon,Microsoft,Citadel,Google",Design,562,74,88,1,"[LRU Cache, /problems/lru-cache/, Medium], [LFU Cache, /problems/lfu-cache/, Hard], [Design Log Storage System, /problems/design-log-storage-system/, Medium]"
109,591,Tag Validator,"Given a string representing a code snippet, you need to implement a tag validator to parse the code and return whether it is valid. A code snippet is valid if all the following rules hold:
The code must be wrapped in a valid closed tag. Otherwise, the code is invalid.

A closed tag (not necessarily valid) has exactly the following format : `<TAG_NAME>TAG_CONTENT</TAG_NAME>`. Among them, `<TAG_NAME>` is the start tag, and `</TAG_NAME>` is the end tag. The TAG_NAME in start and end tags should be the same. A closed tag is valid if and only if the TAG_NAME and TAG_CONTENT are valid.

A valid `TAG_NAME` only contain upper-case letters, and has length in range [1,9]. Otherwise, the `TAG_NAME` is invalid.

A valid `TAG_CONTENT` may contain other valid closed tags, cdata and any characters (see note1) EXCEPT unmatched `<`, unmatched start and end tag, and unmatched or closed tags with invalid TAG_NAME. Otherwise, the `TAG_CONTENT` is invalid.

A start tag is unmatched if no end tag exists with the same TAG_NAME, and vice versa. However, you also need to consider the issue of unbalanced when tags are nested.

A `<` is unmatched if you cannot find a subsequent `>`. And when you find a `<` or `</`, all the subsequent characters until the next `>` should be parsed as TAG_NAME  (not necessarily valid).

The cdata has the following format : `<![CDATA[CDATA_CONTENT]]>`. The range of `CDATA_CONTENT` is defined as the characters between `<![CDATA[` and the first subsequent `]]>`. 
`CDATA_CONTENT` may contain any characters. The function of cdata is to forbid the validator to parse `CDATA_CONTENT`, so even it has some characters that can be parsed as tag (no matter valid or invalid), you should treat it as regular characters. 

Valid Code Examples:
Input: ""<DIV>This is the first line <![CDATA[<div>]]></DIV>""
Output: True
Explanation: 
The code is wrapped in a closed tag : <DIV> and </DIV>. 
The TAG_NAME is valid, the TAG_CONTENT consists of some characters and cdata. 
Although CDATA_CONTENT has unmatched start tag with invalid TAG_NAME, it should be considered as plain text, not parsed as tag.

So TAG_CONTENT is valid, and then the code is valid. Thus return true.

Input: ""<DIV>>>  ![cdata[]] <![CDATA[<div>]>]]>]]>>]</DIV>""
Output: True
Explanation:
We first separate the code into : start_tag|tag_content|end_tag.

start_tag -> ""<DIV>""
end_tag -> ""</DIV>""
tag_content could also be separated into : text1|cdata|text2.

text1 -> "">>  ![cdata[]] ""
cdata -> ""<![CDATA[<div>]>]]>"", where the CDATA_CONTENT is ""<div>]>""
text2 -> ""]]>>]""
The reason why start_tag is NOT ""<DIV>>>"" is because of the rule 6.

The reason why cdata is NOT ""<![CDATA[<div>]>]]>]]>"" is because of the rule 7.


Invalid Code Examples:
Input: ""<A>  <B> </A>   </B>""
Output: False
Explanation: Unbalanced. If ""<A>"" is closed, then ""<B>"" must be unmatched, and vice versa.

Input: ""<DIV>  div tag is not closed  <DIV>""
Output: False
Input: ""<DIV>  unmatched <  </DIV>""
Output: False
Input: ""<DIV> closed tags with invalid tag name  <b>123</b> </DIV>""
Output: False
Input: ""<DIV> unmatched tags with invalid tag name  </1234567890> and <CDATA[[]]>  </DIV>""
Output: False
Input: ""<DIV>  unmatched start tag <B>  and unmatched end tag </C>  </DIV>""
Output: False
Note:
For simplicity, you could assume the input code (including the any characters mentioned above) only contain `letters`, `digits`, `'<'`,`'>'`,`'/'`,`'!'`,`'['`,`']'` and `' '`.",0,/articles/tag-validator,34.8,15.9,https://leetcode.com/problems/tag-validator,66,8.8K,25.1K,Microsoft,"String,Stack",102,458,18,0,"[Add Bold Tag in String, /problems/add-bold-tag-in-string/, Medium]"
110,600,Non-negative Integers without Consecutive Ones,"Given a positive integer n, find the number of non-negative integers less than or equal to n, whose binary representations do NOT contain consecutive ones.


Example 1:
Input: 5
Output: 5
Explanation: 
Here are the non-negative integers <= 5 with their corresponding binary representations:
0 : 0
1 : 1
2 : 10
3 : 11
4 : 100
5 : 101
Among them, only integer 3 disobeys the rule (two consecutive ones) and the other 5 satisfy the rule. 
Note:
1 <= n <= 109",0,/articles/non-negative-integers-without-consecutive-ones,34.3,6.0,https://leetcode.com/problems/non-negative-integers-without-consecutive-ones,111,14.6K,42.4K,Pocket Gems,Dynamic Programming,528,77,87,0,"[House Robber, /problems/house-robber/, Medium], [House Robber II, /problems/house-robber-ii/, Medium], [Ones and Zeroes, /problems/ones-and-zeroes/, Medium]"
111,601,Human Traffic of Stadium,SQL Schema,0,/articles/human-traffic-of-stadium,45.7,14.3,https://leetcode.com/problems/human-traffic-of-stadium,502,41.1K,89.8K,Amazon,,231,415,36,1,
112,615,Average Salary: Departments VS Company,SQL Schema,1,/articles/average-salary-departments-vs-company,53.1,1.9,https://leetcode.com/problems/average-salary-departments-vs-company,270,16K,30.2K,Amazon,,119,38,76,1,
113,618,Students Report By Geography,SQL Schema,1,/articles/students-report-by-geography,60.6,0.0,https://leetcode.com/problems/students-report-by-geography,98,10.8K,17.8K,Amazon,,84,98,46,1,
114,629,K Inverse Pairs Array,"Given two integers `n` and `k`, find how many different arrays consist of numbers from `1` to `n` such that there are exactly `k` inverse pairs.

We define an inverse pair as following: For `ith` and `jth` element in the array, if `i` < `j` and `a[i]` > `a[j]` then it's an inverse pair; Otherwise, it's not.

Since the answer may be very large, the answer should be modulo 109 + 7.


Example 1:
Input: n = 3, k = 0
Output: 1
Explanation: 
Only the array [1,2,3] which consists of numbers from 1 to 3 has exactly 0 inverse pair.


Example 2:
Input: n = 3, k = 1
Output: 2
Explanation: 
The array [1,3,2] and [2,1,3] have exactly 1 inverse pair.

Note:
The integer `n` is in the range [1, 1000] and `k` is in the range [0, 1000].",0,/articles/k-inverse-pairs-array,31.7,0.0,https://leetcode.com/problems/k-inverse-pairs-array,71,12.8K,40.3K,Works Applications,Dynamic Programming,393,77,84,0,
115,630,Course Schedule III,"There are `n` different online courses numbered from `1` to `n`. Each course has some duration(course length) `t` and closed on `dth` day. A course should be taken continuously for `t` days and must be finished before or on the `dth` day. You will start at the `1st` day.

Given `n` online courses represented by pairs `(t,d)`, your task is to find the maximal number of courses that can be taken.


Example:
Input: [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]]
Output: 3
Explanation: 
There're totally 4 courses, but you can take 3 courses at most:
First, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day.

Second, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day. 
Third, take the 2nd course, it costs 200 days so you will finish it on the 1300th day. 
The 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date.

Note:
The integer 1 <= d, t, n <= 10,000.

You can't take two courses simultaneously.",0,/articles/course-schedule-iii,33.8,8.9,https://leetcode.com/problems/course-schedule-iii,84,27.9K,82.5K,"Google,Microsoft",Greedy,1015,39,96,1,"[Course Schedule, /problems/course-schedule/, Medium], [Course Schedule II, /problems/course-schedule-ii/, Medium]"
116,631,Design Excel Sum Formula,"Your task is to design the basic function of Excel and implement the function of sum formula.  Specifically, you need to implement the following functions:
`Excel(int H, char W):` This is the constructor. The inputs represents the height and width of the Excel form. H is a positive integer, range from 1 to 26. It represents the height. W is a character range from 'A' to 'Z'. It represents that the width is the number of characters from 'A' to W. The Excel form content is represented by a height * width 2D integer array `C`, it should be initialized to zero. You should assume that the first row of `C` starts from 1, and the first column of `C` starts from 'A'.

`void Set(int row, char column, int val):` Change the value at `C(row, column)` to be val.

`int Get(int row, char column):` Return the value at `C(row, column)`.

`int Sum(int row, char column, List of Strings : numbers):` This function calculate and set the value at `C(row, column)`, where the value should be the sum of cells represented by `numbers`. This function return the sum result at `C(row, column)`. This sum formula should exist until this cell is overlapped by another value or another sum formula.

`numbers` is a list of strings that each string represent a cell or a range of cells. If the string represent a single cell, then it has the following format : `ColRow`. For example, ""F7"" represents the cell at (7, F). 
If the string represent a range of cells, then it has the following format : `ColRow1:ColRow2`. The range will always be a rectangle, and ColRow1 represent the position of the top-left cell, and ColRow2 represents the position of the bottom-right cell. 

Example 1:
Excel(3,""C""); 
// construct a 3*3 2D array with all zero.

//   A B C
// 1 0 0 0
// 2 0 0 0
// 3 0 0 0
Set(1, ""A"", 2);
// set C(1,""A"") to be 2.

//   A B C
// 1 2 0 0
// 2 0 0 0
// 3 0 0 0
Sum(3, ""C"", [""A1"", ""A1:B2""]);
// set C(3,""C"") to be the sum of value at C(1,""A"") and the values sum of the rectangle range whose top-left cell is C(1,""A"") and bottom-right cell is C(2,""B""). Return 4. 
//   A B C
// 1 2 0 0
// 2 0 0 0
// 3 0 0 4
Set(2, ""B"", 2);
// set C(2,""B"") to be 2. Note C(3, ""C"") should also be changed.

//   A B C
// 1 2 0 0
// 2 0 2 0
// 3 0 0 6
Note:
You could assume that there won't be any circular sum reference. For example, A1 = sum(B1) and B1 = sum(A1).

 The test cases are using double-quotes to represent a character.

Please remember to RESET your class variables declared in class Excel, as static/class variables are persisted across multiple test cases. Please see here for more details.",1,/articles/design-excel-sum-formula,32.2,53.9,https://leetcode.com/problems/design-excel-sum-formula,58,4.8K,14.7K,Opendoor,Design,99,106,48,0,
117,632,Smallest Range Covering Elements from K Lists,"You have `k` lists of sorted integers in non-decreasing order. Find the smallest range that includes at least one number from each of the `k` lists.

We define the range `[a, b]` is smaller than range `[c, d]` if `b - a < d - c` or `a < c` if `b - a == d - c`.


Example 1:
Input: nums = [[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]
Output: [20,24]
Explanation: 
List 1: [4, 10, 15, 24,26], 24 is in range [20,24].

List 2: [0, 9, 12, 20], 20 is in range [20,24].

List 3: [5, 18, 22, 30], 22 is in range [20,24].


Example 2:
Input: nums = [[1,2,3],[1,2,3],[1,2,3]]
Output: [1,1]

Example 3:
Input: nums = [[10,10],[11,11]]
Output: [10,11]

Example 4:
Input: nums = [[10],[11]]
Output: [10,11]

Example 5:
Input: nums = [[1],[2],[3],[4],[5],[6],[7]]
Output: [1,7]

Constraints:
`nums.length == k`
`1 <= k <= 3500`
`1 <= nums[i].length <= 50`
`-105 <= nums[i][j] <= 105`
`nums[i]` is sorted in non-decreasing order.",0,/articles/smallest-range,54.5,29.7,https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists,323,46.2K,84.9K,Amazon,"Hash Table,Two Pointers,String",1384,26,98,1,"[Minimum Window Substring, /problems/minimum-window-substring/, Hard]"
118,639,Decode Ways II,"A message containing letters from `A-Z` can be encoded into numbers using the following mapping:
'A' -> ""1""
'B' -> ""2""
...

'Z' -> ""26""
To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, `""11106""` can be mapped into:
`""AAJF""` with the grouping `(1 1 10 6)`
`""KJF""` with the grouping `(11 10 6)`
Note that the grouping `(1 11 06)` is invalid because `""06""` cannot be mapped into `'F'` since `""6""` is different from `""06""`.

In addition to the mapping above, an encoded message may contain the `'*'` character, which can represent any digit from `'1'` to `'9'` (`'0'` is excluded). For example, the encoded message `""1*""` may represent any of the encoded messages `""11""`, `""12""`, `""13""`, `""14""`, `""15""`, `""16""`, `""17""`, `""18""`, or `""19""`. Decoding `""1*""` is equivalent to decoding any of the encoded messages it can represent.

Given a string `s` containing digits and the `'*'` character, return the number of ways to decode it.

Since the answer may be very large, return it modulo `109 + 7`.


Example 1:
Input: s = ""*""
Output: 9
Explanation: The encoded message can represent any of the encoded messages ""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8"", or ""9"".

Each of these can be decoded to the strings ""A"", ""B"", ""C"", ""D"", ""E"", ""F"", ""G"", ""H"", and ""I"" respectively.

Hence, there are a total of 9 ways to decode ""*"".


Example 2:
Input: s = ""1*""
Output: 18
Explanation: The encoded message can represent any of the encoded messages ""11"", ""12"", ""13"", ""14"", ""15"", ""16"", ""17"", ""18"", or ""19"".

Each of these encoded messages have 2 ways to be decoded (e.g. ""11"" can be decoded to ""AA"" or ""K"").

Hence, there are a total of 9 * 2 = 18 ways to decode ""1*"".


Example 3:
Input: s = ""2*""
Output: 15
Explanation: The encoded message can represent any of the encoded messages ""21"", ""22"", ""23"", ""24"", ""25"", ""26"", ""27"", ""28"", or ""29"".

""21"", ""22"", ""23"", ""24"", ""25"", and ""26"" have 2 ways of being decoded, but ""27"", ""28"", and ""29"" only have 1 way.

Hence, there are a total of (6 * 2) + (3 * 1) = 12 + 3 = 15 ways to decode ""2*"".


Constraints:
`1 <= s.length <= 105`
`s[i]` is a digit or `'*'`.",0,/articles/decode-ways-ii,27.7,1.6,https://leetcode.com/problems/decode-ways-ii,250,38.5K,138.9K,"Google,Facebook",Dynamic Programming,583,592,50,1,"[Decode Ways, /problems/decode-ways/, Medium]"
119,642,Design Search Autocomplete System,"Design a search autocomplete system for a search engine. Users may input a sentence (at least one word and end with a special character `'#'`). For each character they type except '#', you need to return the top 3 historical hot sentences that have prefix the same as the part of sentence already typed. Here are the specific rules:
The hot degree for a sentence is defined as the number of times a user typed the exactly same sentence before.

The returned top 3 hot sentences should be sorted by hot degree (The first is the hottest one). If several sentences have the same degree of hot, you need to use ASCII-code order (smaller one appears first).

If less than 3 hot sentences exist, then just return as many as you can.

When the input is a special character, it means the sentence ends, and in this case, you need to return an empty list.

Your job is to implement the following functions:
The constructor function:
`AutocompleteSystem(String[] sentences, int[] times):` This is the constructor. The input is historical data. `Sentences` is a string array consists of previously typed sentences. `Times` is the corresponding times a sentence has been typed. Your system should record these historical data.

Now, the user wants to input a new sentence. The following function will provide the next character the user types:
`List<String> input(char c):` The input `c` is the next character typed by the user. The character will only be lower-case letters (`'a'` to `'z'`), blank space (`' '`) or a special character (`'#'`). Also, the previously typed sentence should be recorded in your system. The output will be the top 3 historical hot sentences that have prefix the same as the part of sentence already typed.


Example:
Operation: AutocompleteSystem([""i love you"", ""island"",""ironman"", ""i love leetcode""], [5,3,2,2])
The system have already tracked down the following sentences and their corresponding times:
`""i love you""` : `5` times
`""island""` : `3` times
`""ironman""` : `2` times
`""i love leetcode""` : `2` times
Now, the user begins another search:
Operation: input('i')
Output: [""i love you"", ""island"",""i love leetcode""]
Explanation:
There are four sentences that have prefix `""i""`. Among them, ""ironman"" and ""i love leetcode"" have same hot degree. Since `' '` has ASCII code 32 and `'r'` has ASCII code 114, ""i love leetcode"" should be in front of ""ironman"". Also we only need to output top 3 hot sentences, so ""ironman"" will be ignored.

Operation: input(' ')
Output: [""i love you"",""i love leetcode""]
Explanation:
There are only two sentences that have prefix `""i ""`.

Operation: input('a')
Output: []
Explanation:
There are no sentences that have prefix `""i a""`.

Operation: input('#')
Output: []
Explanation:
The user finished the input, the sentence `""i a""` should be saved as a historical sentence in system. And the following input will be counted as a new search.

Note:
The input sentence will always start with a letter and end with '#', and only one blank space will exist between two words.

The number of complete sentences that to be searched won't exceed 100. The length of each sentence including those in the historical data won't exceed 100.

Please use double-quote instead of single-quote when you write test cases even for a character input.

Please remember to RESET your class variables declared in class AutocompleteSystem, as static/class variables are persisted across multiple test cases. Please see here for more details.",1,/articles/design-search-autocomplete-system,46.5,64.7,https://leetcode.com/problems/design-search-autocomplete-system,438,79.7K,171.5K,"Microsoft,Amazon,Lyft,Google","Design,Trie",1268,91,93,1,"[Implement Trie (Prefix Tree), /problems/implement-trie-prefix-tree/, Medium]"
120,644,Maximum Average Subarray II,"You are given an integer array `nums` consisting of `n` elements, and an integer `k`.

Find a contiguous subarray whose length is greater than or equal to `k` that has the maximum average value and return this value. Any answer with a calculation error less than `10-5` will be accepted.


Example 1:
Input: nums = [1,12,-5,-6,50,3], k = 4
Output: 12.75000
Explanation:
- When the length is 4, averages are [0.5, 12.75, 10.5] and the maximum average is 12.75
- When the length is 5, averages are [10.4, 10.8] and the maximum average is 10.8
- When the length is 6, averages are [9.16667] and the maximum average is 9.16667
The maximum average is when we choose a subarray of length 4 (i.e., the sub array [12, -5, -6, 50]) which has the max average 12.75, so we return 12.75
Note that we do not consider the subarrays of length < 4.


Example 2:
Input: nums = [5], k = 1
Output: 5.00000

Constraints:
`n == nums.length`
`1 <= k <= n <= 104`
`-104 <= nums[i] <= 104`",1,/articles/maximum-average-subarray-ii,34.2,0.0,https://leetcode.com/problems/maximum-average-subarray-ii,50,15.4K,45.2K,Google,"Array,Binary Search",480,52,90,1,"[Maximum Average Subarray I, /problems/maximum-average-subarray-i/, Easy]"
121,656,Coin Path,"Given an array `A` (index starts at `1`) consisting of N integers: A1, A2, ..., AN and an integer `B`. The integer `B` denotes that from any place (suppose the index is `i`) in the array `A`, you can jump to any one of the place in the array `A` indexed `i+1`, `i+2`, ..., `i+B` if this place can be jumped to. Also, if you step on the index `i`, you have to pay Ai coins. If Ai is -1, it means you can’t jump to the place indexed `i` in the array.

Now, you start from the place indexed `1` in the array `A`, and your aim is to reach the place indexed `N` using the minimum coins. You need to return the path of indexes (starting from 1 to N) in the array you should take to get to the place indexed `N` using minimum coins.

If there are multiple paths with the same cost, return the lexicographically smallest such path.

If it's not possible to reach the place indexed N then you need to return an empty array.


Example 1:
Input: [1,2,4,-1,2], 2
Output: [1,3,5]

Example 2:
Input: [1,2,4,-1,2], 1
Output: []
Note:
Path Pa1, Pa2, ..., Pan is lexicographically smaller than Pb1, Pb2, ..., Pbm, if and only if at the first `i` where Pai and Pbi differ, Pai < Pbi; when no such `i` exists, then `n` < `m`.

A1 >= 0. A2, ..., AN (if exist) will in the range of [-1, 100].

Length of A is in the range of [1, 1000].

B is in the range of [1, 100].",1,/articles/coin-path,29.7,0.0,https://leetcode.com/problems/coin-path,56,10.6K,35.6K,Google,Dynamic Programming,184,89,67,1,"[House Robber, /problems/house-robber/, Medium], [House Robber II, /problems/house-robber-ii/, Medium]"
122,660,Remove 9,"Start from integer 1, remove any integer that contains 9 such as 9, 19, 29...

So now, you will have a new integer sequence: 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, ...

Given a positive integer `n`, you need to return the n-th integer after removing. Note that 1 will be the first integer.


Example 1:
Input: n = 9
Output: 10

Constraints:
`1 <= n <= 8 x 10^8`",1,/articles/remove-9,54.3,0.0,https://leetcode.com/problems/remove-9,48,7.5K,13.9K,Houzz,Math,114,149,43,0,
123,664,Strange Printer,"There is a strange printer with the following two special requirements:
The printer can only print a sequence of the same character each time.

At each turn, the printer can print new characters starting from and ending at any places, and will cover the original existing characters.

Given a string consists of lower English letters only, your job is to count the minimum number of turns the printer needed in order to print it.


Example 1:
Input: ""aaabbb""
Output: 2
Explanation: Print ""aaa"" first and then print ""bbb"".


Example 2:
Input: ""aba""
Output: 2
Explanation: Print ""aaa"" first and then print ""b"" from the second place of the string, which will cover the existing character 'a'.

Hint: Length of the given string will not exceed 100.",0,/articles/strange-printer,41.6,22.4,https://leetcode.com/problems/strange-printer,88,17.8K,42.8K,NetEase,"Dynamic Programming,Depth-first Search",561,54,91,0,"[Remove Boxes, /problems/remove-boxes/, Hard], [Strange Printer II, /problems/strange-printer-ii/, Hard]"
124,668,Kth Smallest Number in Multiplication Table,"Nearly every one have used the Multiplication Table. But could you find out the `k-th` smallest number quickly from the multiplication table?
Given the height `m` and the length `n` of a `m * n` Multiplication Table, and a positive integer `k`, you need to return the `k-th` smallest number in this table.


Example 1:
Input: m = 3, n = 3, k = 5
Output: 
Explanation: 
The Multiplication Table:
1	2	3
2	4	6
3	6	9
The 5-th smallest number is 3 (1, 2, 2, 3, 3).


Example 2:
Input: m = 2, n = 3, k = 6
Output: 
Explanation: 
The Multiplication Table:
1	2	3
2	4	6
The 6-th smallest number is 6 (1, 2, 2, 3, 4, 6).

Note:
The `m` and `n` will be in the range [1, 30000].

The `k` will be in the range [1, m * n]",0,/articles/kth-smallest-number-in-multiplication-table,47.9,0.0,https://leetcode.com/problems/kth-smallest-number-in-multiplication-table,112,26K,54.2K,"Uber,Google",Binary Search,695,25,97,1,"[Kth Smallest Element in a Sorted Matrix, /problems/kth-smallest-element-in-a-sorted-matrix/, Medium], [Find K-th Smallest Pair Distance, /problems/find-k-th-smallest-pair-distance/, Hard], [K-th Smallest Prime Fraction, /problems/k-th-smallest-prime-fraction/, Hard]"
125,675,Cut Off Trees for Golf Event,"You are asked to cut off all the trees in a forest for a golf event. The forest is represented as an `m x n` matrix. In this matrix:
`0` means the cell cannot be walked through.

`1` represents an empty cell that can be walked through.

A number greater than `1` represents a tree in a cell that can be walked through, and this number is the tree's height.

In one step, you can walk in any of the four directions: north, east, south, and west. If you are standing in a cell with a tree, you can choose whether to cut it off.

You must cut off the trees in order from shortest to tallest. When you cut off a tree, the value at its cell becomes `1` (an empty cell).

Starting from the point `(0, 0)`, return the minimum steps you need to walk to cut off all the trees. If you cannot cut off all the trees, return `-1`.

You are guaranteed that no two trees have the same height, and there is at least one tree needs to be cut off.


Example 1:
Input: forest = [[1,2,3],[0,0,4],[7,6,5]]
Output: 6
Explanation: Following the path above allows you to cut off the trees from shortest to tallest in 6 steps.


Example 2:
Input: forest = [[1,2,3],[0,0,0],[7,6,5]]
Output: -1
Explanation: The trees in the bottom row cannot be accessed as the middle row is blocked.


Example 3:
Input: forest = [[2,3,4],[0,0,5],[8,7,6]]
Output: 6

Explanation: You can follow the same path as Example 1 to cut off all the trees.

Note that you can cut off the first tree at (0, 0) before making any steps.


Constraints:
`m == forest.length`
`n == forest[i].length`
`1 <= m, n <= 50`
`0 <= forest[i][j] <= 109`",0,/articles/cutoff-trees-for-golf-event,35.4,15.4,https://leetcode.com/problems/cut-off-trees-for-golf-event,223,42.3K,119.4K,"Amazon,Apple",Breadth-first Search,664,388,63,1,
126,679,24 Game,"You have 4 cards each containing a number from 1 to 9.  You need to judge whether they could operated through `*`, `/`, `+`, `-`, `(`, `)` to get the value of 24.


Example 1:
Input: [4, 1, 8, 7]
Output: True
Explanation: (8-4) * (7-1) = 24

Example 2:
Input: [1, 2, 1, 2]
Output: False
Note:
The division operator `/` represents real division, not integer division.  For example, 4 / (1 - 2/3) = 12.

Every operation done is between two numbers.  In particular, we cannot use `-` as a unary operator.  For example, with `[1, 1, 1, 1]` as input, the expression `-1 - 1 - 1 - 1` is not allowed.

You cannot concatenate numbers together.  For example, if the input is `[1, 2, 1, 2]`, we cannot write this as 12 + 12.",0,/articles/24-game,47.3,40.7,https://leetcode.com/problems/24-game,254,49.1K,103.9K,Amazon,Depth-first Search,902,180,83,1,
127,683,K Empty Slots,"You have `n` bulbs in a row numbered from `1` to `n`. Initially, all the bulbs are turned off. We turn on exactly one bulb every day until all bulbs are on after `n` days.

You are given an array `bulbs` of length `n` where `bulbs[i] = x` means that on the `(i+1)th` day, we will turn on the bulb at position `x` where `i` is 0-indexed and `x` is 1-indexed.

Given an integer `k`, return the minimum day number such that there exists two turned on bulbs that have exactly `k` bulbs between them that are all turned off. If there isn't such day, return `-1`.


Example 1:
Input: bulbs = [1,3,2], k = 1
Output: 2
Explanation:
On the first day: bulbs[0] = 1, first bulb is turned on: [1,0,0]
On the second day: bulbs[1] = 3, third bulb is turned on: [1,0,1]
On the third day: bulbs[2] = 2, second bulb is turned on: [1,1,1]
We return 2 because on the second day, there were two on bulbs with one off bulb between them.


Example 2:
Input: bulbs = [1,2,3], k = 1
Output: -1

Constraints:
`n == bulbs.length`
`1 <= n <= 2 * 104`
`1 <= bulbs[i] <= n`
`bulbs` is a permutation of numbers from `1` to `n`.

`0 <= k <= 2 * 104`",1,/articles/k-empty-slots,36.1,0.0,https://leetcode.com/problems/k-empty-slots,249,50.6K,140.1K,Google,Ordered Map,651,613,52,1,
128,685,Redundant Connection II,"In this problem, a rooted tree is a directed graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.

The given input is a directed graph that started as a rooted tree with `n` nodes (with distinct values from `1` to `n`), with one additional directed edge added. The added edge has two different vertices chosen from `1` to `n`, and was not an edge that already existed.

The resulting graph is given as a 2D-array of `edges`. Each element of `edges` is a pair `[ui, vi]` that represents a directed edge connecting nodes `ui` and `vi`, where `ui` is a parent of child `vi`.

Return an edge that can be removed so that the resulting graph is a rooted tree of `n` nodes. If there are multiple answers, return the answer that occurs last in the given 2D-array.


Example 1:
Input: edges = [[1,2],[1,3],[2,3]]
Output: [2,3]

Example 2:
Input: edges = [[1,2],[2,3],[3,4],[4,1],[1,5]]
Output: [4,1]

Constraints:
`n == edges.length`
`3 <= n <= 1000`
`edges[i].length == 2`
`1 <= ui, vi <= n`",0,/articles/redundant-connection-ii,33.2,7.0,https://leetcode.com/problems/redundant-connection-ii,233,42K,126.8K,Amazon,"Tree,Depth-first Search,Union Find,Graph",1061,243,81,1,"[Redundant Connection, /problems/redundant-connection/, Medium]"
129,689,Maximum Sum of 3 Non-Overlapping Subarrays,"In a given array `nums` of positive integers, find three non-overlapping subarrays with maximum sum.

Each subarray will be of size `k`, and we want to maximize the sum of all `3*k` entries.

Return the result as a list of indices representing the starting position of each interval (0-indexed). If there are multiple answers, return the lexicographically smallest one.


Example:
Input: [1,2,1,2,6,7,5,1], 2
Output: [0, 3, 5]
Explanation: Subarrays [1, 2], [2, 6], [7, 5] correspond to the starting indices [0, 3, 5].

We could have also taken [2, 1], but an answer of [1, 3, 5] would be lexicographically larger.

Note:
`nums.length` will be between 1 and 20000.

`nums[i]` will be between 1 and 65535.

`k` will be between 1 and floor(nums.length / 3).",0,/articles/maximum-sum-of-3-non-overlapping-intervals,47.3,32.3,https://leetcode.com/problems/maximum-sum-of-3-non-overlapping-subarrays,251,53.2K,112.4K,Facebook,"Array,Dynamic Programming",1214,81,94,1,"[Best Time to Buy and Sell Stock III, /problems/best-time-to-buy-and-sell-stock-iii/, Hard]"
130,691,Stickers to Spell Word,"We are given N different types of stickers.  Each sticker has a lowercase English word on it.

You would like to spell out the given `target` string by cutting individual letters from your collection of stickers and rearranging them.

You can use each sticker more than once if you want, and you have infinite quantities of each sticker.

What is the minimum number of stickers that you need to spell out the `target`?  If the task is impossible, return -1.


Example 1:
Input:[""with"", ""example"", ""science""], ""thehat""
Output:3
Explanation:We can use 2 ""with"" stickers, and 1 ""example"" sticker.

After cutting and rearrange the letters of those stickers, we can form the target ""thehat"".

Also, this is the minimum number of stickers necessary to form the target string.


Example 2:
Input:[""notice"", ""possible""], ""basicbasic""
Output:-1
Explanation:We can't form the target ""basicbasic"" from cutting letters from the given stickers.

Note:
`stickers` has length in the range `[1, 50]`.

`stickers` consists of lowercase English words (without apostrophes).

`target` has length in the range `[1, 15]`, and consists of lowercase English letters.

In all test cases, all words were chosen randomly from the 1000 most common US English words, and the target was chosen as a concatenation of two random words.

The time limit may be more challenging than usual.  It is expected that a 50 sticker test case can be solved within 35ms on average.",0,/articles/stickers-to-spell-word,45.1,11.0,https://leetcode.com/problems/stickers-to-spell-word,97,20K,44.3K,Facebook,"Dynamic Programming,Backtracking",499,46,92,1,"[Ransom Note, /problems/ransom-note/, Easy]"
131,699,Falling Squares,"On an infinite number line (x-axis), we drop given squares in the order they are given.

The `i`-th square dropped (`positions[i] = (left, side_length)`) is a square with the left-most point being `positions[i][0]` and sidelength `positions[i][1]`.

The square is dropped with the bottom edge parallel to the number line, and from a higher height than all currently landed squares. We wait for each square to stick before dropping the next.

The squares are infinitely sticky on their bottom edge, and will remain fixed to any positive length surface they touch (either the number line or another square). Squares dropped adjacent to each other will not stick together prematurely.

Return a list `ans` of heights. Each height `ans[i]` represents the current highest height of any square we have dropped, after dropping squares represented by `positions[0], positions[1], ..., positions[i]`.


Example 1:
Input: [[1, 2], [2, 3], [6, 1]]
Output: [2, 5, 5]
Explanation:
After the first drop of `positions[0] = [1, 2]: _aa _aa ------- `The maximum height of any square is 2.

After the second drop of `positions[1] = [2, 3]: __aaa __aaa __aaa _aa__ _aa__ -------------- `The maximum height of any square is 5. The larger square stays on top of the smaller square despite where its center of gravity is, because squares are infinitely sticky on their bottom edge.

After the third drop of `positions[1] = [6, 1]: __aaa __aaa __aaa _aa _aa___a -------------- `The maximum height of any square is still 5. Thus, we return an answer of `[2, 5, 5]`.


Example 2:
Input: [[100, 100], [200, 100]]
Output: [100, 100]
Explanation: Adjacent squares don't get stuck prematurely - only their bottom edge can stick to surfaces.

Note:
`1 <= positions.length <= 1000`.

`1 <= positions[i][0] <= 10^8`.

`1 <= positions[i][1] <= 10^6`.",0,/articles/falling-squares,43.2,2.1,https://leetcode.com/problems/falling-squares,103,16K,37K,"Amazon,Uber,Square","Segment Tree,Ordered Map",330,65,84,1,"[The Skyline Problem, /problems/the-skyline-problem/, Hard]"
132,710,Random Pick with Blacklist,"Given a blacklist `B` containing unique integers from `[0, N)`, write a function to return a uniform random integer from `[0, N)` which is NOT in `B`.

Optimize it such that it minimizes the call to system’s `Math.random()`.

Note:
`1 <= N <= 1000000000`
`0 <= B.length < min(100000, N)`
`[0, N)` does NOT include N. See interval notation.


Example 1:
Input: 
[""Solution"",""pick"",""pick"",""pick""]
[[1,[]],[],[],[]]
Output: [null,0,0,0]

Example 2:
Input: 
[""Solution"",""pick"",""pick"",""pick""]
[[2,[]],[],[],[]]
Output: [null,1,1,1]

Example 3:
Input: 
[""Solution"",""pick"",""pick"",""pick""]
[[3,[1]],[],[],[]]
Output: [null,0,0,2]

Example 4:
Input: 
[""Solution"",""pick"",""pick"",""pick""]
[[4,[2]],[],[],[]]
Output: [null,1,3,1]
Explanation of Input Syntax:
The input is two lists: the subroutines called and their arguments. `Solution`'s constructor has two arguments, `N` and the blacklist `B`. `pick` has no arguments. Arguments are always wrapped with a list, even if there aren't any.",0,/articles/random-pick-with-blacklist,33.1,20.7,https://leetcode.com/problems/random-pick-with-blacklist,123,18.1K,54.6K,Two Sigma,"Hash Table,Binary Search,Sort,Random",420,75,85,0,"[Random Pick Index, /problems/random-pick-index/, Medium], [Random Pick with Weight, /problems/random-pick-with-weight/, Medium]"
133,711,Number of Distinct Islands II,"Given a non-empty 2D array `grid` of 0's and 1's, an island is a group of `1`'s (representing land) connected 4-directionally (horizontal or vertical.)  You may assume all four edges of the grid are surrounded by water.

Count the number of distinct islands.  An island is considered to be the same as another if they have the same shape, or have the same shape after rotation (90, 180, or 270 degrees only) or reflection (left/right direction or up/down direction).


Example 1:
11000
10000
00001
00011
Given the above grid map, return `1`.

Notice that:
11
1
and
 1
11
are considered same island shapes. Because if we make a 180 degrees clockwise rotation on the first island, then two islands will have the same shapes.


Example 2:
11100
10001
01001
01110
Given the above grid map, return `2`.

Here are the two distinct islands:
111
1
and
1
1
Notice that:
111
1
and
1
111
are considered same island shapes. Because if we flip the first array in the up/down direction, then they have the same shapes.

Note:
The length of each dimension in the given `grid` does not exceed 50.",1,/articles/number-of-distinct-islands-ii,49.6,0.0,https://leetcode.com/problems/number-of-distinct-islands-ii,48,6.9K,14K,Amazon,"Hash Table,Depth-first Search",177,192,48,1,"[Number of Distinct Islands, /problems/number-of-distinct-islands/, Medium]"
134,715,Range Module,"A Range Module is a module that tracks ranges of numbers. Your task is to design and implement the following interfaces in an efficient manner.

`addRange(int left, int right)` Adds the half-open interval `[left, right)`, tracking every real number in that interval.  Adding an interval that partially overlaps with currently tracked numbers should add any numbers in the interval `[left, right)` that are not already tracked.

`queryRange(int left, int right)` Returns true if and only if every real number in the interval `[left, right)`
 is currently being tracked.

`removeRange(int left, int right)` Stops tracking every real number currently being tracked in the interval `[left, right)`.


Example 1:
addRange(10, 20): null
removeRange(14, 16): null
queryRange(10, 14): true (Every number in [10, 14) is being tracked)
queryRange(13, 15): false (Numbers like 14, 14.03, 14.17 in [13, 15) are not being tracked)
queryRange(16, 17): true (The number 16 in [16, 17) is still being tracked, despite the remove operation)
Note:
A half open interval `[left, right)` denotes all real numbers `left <= x < right`.

`0 < left < right < 10^9` in all calls to `addRange, queryRange, removeRange`.

The total number of calls to `addRange` in a single test case is at most `1000`.

The total number of calls to `queryRange` in a single test case is at most `5000`.

The total number of calls to `removeRange` in a single test case is at most `1000`.",0,/articles/range-module,40.7,46.0,https://leetcode.com/problems/range-module,124,27.3K,67.2K,"Google,Amazon","Segment Tree,Ordered Map",627,51,92,1,"[Merge Intervals, /problems/merge-intervals/, Medium], [Insert Interval, /problems/insert-interval/, Medium], [Data Stream as Disjoint Intervals, /problems/data-stream-as-disjoint-intervals/, Hard]"
135,719,Find K-th Smallest Pair Distance,"Given an integer array, return the k-th smallest distance among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B. 

Example 1:
Input:
nums = [1,3,1]
k = 1
Output: 0 
Explanation:
Here are all the pairs:
(1,3) -> 2
(1,1) -> 0
(3,1) -> 2
Then the 1st smallest distance pair is (1,1), and its distance is 0.

Note:
`2 <= len(nums) <= 10000`.

`0 <= nums[i] < 1000000`.

`1 <= k <= len(nums) * (len(nums) - 1) / 2`.",0,/articles/find-k-th-smallest-pair-distance,32.6,14.7,https://leetcode.com/problems/find-k-th-smallest-pair-distance,147,42.6K,130.4K,"Google,Amazon","Array,Binary Search,Heap",1304,49,96,1,"[Find K Pairs with Smallest Sums, /problems/find-k-pairs-with-smallest-sums/, Medium], [Kth Smallest Element in a Sorted Matrix, /problems/kth-smallest-element-in-a-sorted-matrix/, Medium], [Find K Closest Elements, /problems/find-k-closest-elements/, Medium], [Kth Smallest Number in Multiplication Table, /problems/kth-smallest-number-in-multiplication-table/, Hard], [K-th Smallest Prime Fraction, /problems/k-th-smallest-prime-fraction/, Hard]"
136,726,Number of Atoms,"Given a chemical `formula` (given as a string), return the count of each atom.

The atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name.

One or more digits representing that element's count may follow if the count is greater than 1. If the count is 1, no digits will follow. For example, H2O and H2O2 are possible, but H1O2 is impossible.

Two formulas concatenated together to produce another formula. For example, H2O2He3Mg4 is also a formula.

A formula placed in parentheses, and a count (optionally added) is also a formula. For example, (H2O2) and (H2O2)3 are formulas.

Given a `formula`, return the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than 1), followed by the second name (in sorted order), followed by its count (if that count is more than 1), and so on.


Example 1:
Input: formula = ""H2O""
Output: ""H2O""
Explanation: The count of elements are {'H': 2, 'O': 1}.


Example 2:
Input: formula = ""Mg(OH)2""
Output: ""H2MgO2""
Explanation: The count of elements are {'H': 2, 'Mg': 1, 'O': 2}.


Example 3:
Input: formula = ""K4(ON(SO3)2)2""
Output: ""K4N2O14S4""
Explanation: The count of elements are {'K': 4, 'N': 2, 'O': 14, 'S': 4}.


Example 4:
Input: formula = ""Be32""
Output: ""Be32""

Constraints:
`1 <= formula.length <= 1000`
`formula` consists of English letters, digits, `'('`, and `')'`.

`formula` is always valid.",0,/articles/number-of-atoms,51.0,60.4,https://leetcode.com/problems/number-of-atoms,302,32.2K,63.2K,"ByteDance,Amazon,Pinterest,Microsoft","Hash Table,Stack,Recursion",622,161,79,1,"[Decode String, /problems/decode-string/, Medium], [Encode String with Shortest Length, /problems/encode-string-with-shortest-length/, Hard], [Parse Lisp Expression, /problems/parse-lisp-expression/, Hard]"
137,727,Minimum Window Subsequence,"Given strings `S` and `T`, find the minimum (contiguous) substring `W` of `S`, so that `T` is a subsequence of `W`.

If there is no such window in `S` that covers all characters in `T`, return the empty string `""""`. If there are multiple such minimum-length windows, return the one with the left-most starting index.


Example 1:
Input: 
S = ""abcdebdde"", T = ""bde""
Output: ""bcde""
Explanation: 
""bcde"" is the answer because it occurs before ""bdde"" which has the same length.

""deb"" is not a smaller window because the elements of T in the window must occur in order.

Note:
All the strings in the input will only contain lowercase letters.

The length of `S` will be in the range `[1, 20000]`.

The length of `T` will be in the range `[1, 100]`.",1,/articles/minimum-window-subsequence,42.4,39.0,https://leetcode.com/problems/minimum-window-subsequence,268,56.9K,134K,"Google,Amazon,Facebook","Dynamic Programming,Sliding Window",915,55,94,1,
138,730,Count Different Palindromic Subsequences,"Given a string S, find the number of different non-empty palindromic subsequences in S, and return that number modulo `10^9 + 7`.

A subsequence of a string S is obtained by deleting 0 or more characters from S.

A sequence is palindromic if it is equal to the sequence reversed.

Two sequences `A_1, A_2, ...` and `B_1, B_2, ...` are different if there is some `i` for which `A_i != B_i`.


Example 1:
Input: 
S = 'bccb'
Output: 6
Explanation: 
The 6 different non-empty palindromic subsequences are 'b', 'c', 'bb', 'cc', 'bcb', 'bccb'.

Note that 'bcb' is counted only once, even though it occurs twice.


Example 2:
Input: 
S = 'abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba'
Output: 104860361
Explanation: 
There are 3104860382 different non-empty palindromic subsequences, which is 104860361 modulo 10^9 + 7.

Note:
The length of `S` will be in the range `[1, 1000]`.

Each character `S[i]` will be in the set `{'a', 'b', 'c', 'd'}`.",0,/articles/count-different-palindromic-subsequences,43.4,18.5,https://leetcode.com/problems/count-different-palindromic-subsequences,82,19.4K,44.6K,"LinkedIn,Google,Facebook","String,Dynamic Programming",762,50,94,1,"[Longest Palindromic Subsequence, /problems/longest-palindromic-subsequence/, Medium]"
139,732,My Calendar III,"A `k`-booking happens when `k` events have some non-empty intersection (i.e., there is some time that is common to all `k` events.)
You are given some events `[start, end)`, after each given event, return an integer `k` representing the maximum `k`-booking between all the previous events.

Implement the `MyCalendarThree` class:
`MyCalendarThree()` Initializes the object.

`int book(int start, int end)` Returns an integer `k` representing the largest integer such that there exists a `k`-booking in the calendar.


Example 1:
Input
[""MyCalendarThree"", ""book"", ""book"", ""book"", ""book"", ""book"", ""book""]
[[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]
Output
[null, 1, 1, 2, 3, 3, 3]
Explanation
MyCalendarThree myCalendarThree = new MyCalendarThree();
myCalendarThree.book(10, 20); // return 1, The first event can be booked and is disjoint, so the maximum k-booking is a 1-booking.

myCalendarThree.book(50, 60); // return 1, The second event can be booked and is disjoint, so the maximum k-booking is a 1-booking.

myCalendarThree.book(10, 40); // return 2, The third event [10, 40) intersects the first event, and the maximum k-booking is a 2-booking.

myCalendarThree.book(5, 15); // return 3, The remaining events cause the maximum K-booking to be only a 3-booking.

myCalendarThree.book(5, 10); // return 3
myCalendarThree.book(25, 55); // return 3

Constraints:
`0 <= start < end <= 109`
At most `400` calls will be made to `book`.",0,/articles/my-calendar-iii,62.2,5.4,https://leetcode.com/problems/my-calendar-iii,150,26.6K,42.8K,Google,"Segment Tree,Ordered Map",461,107,81,1,"[My Calendar I, /problems/my-calendar-i/, Medium], [My Calendar II, /problems/my-calendar-ii/, Medium]"
140,736,Parse Lisp Expression,"You are given a string `expression` representing a Lisp-like expression to return the integer value of.

The syntax for these expressions is given as follows.

An expression is either an integer, a let-expression, an add-expression, a mult-expression, or an assigned variable.  Expressions always evaluate to a single integer.

(An integer could be positive or negative.)
A let-expression takes the form `(let v1 e1 v2 e2 ... vn en expr)`, where `let` is always the string `""let""`, then there are 1 or more pairs of alternating variables and expressions, meaning that the first variable `v1` is assigned the value of the expression `e1`, the second variable `v2` is assigned the value of the expression `e2`, and so on sequentially; and then the value of this let-expression is the value of the expression `expr`.

An add-expression takes the form `(add e1 e2)` where `add` is always the string `""add""`, there are always two expressions `e1, e2`, and this expression evaluates to the addition of the evaluation of `e1` and the evaluation of `e2`.

A mult-expression takes the form `(mult e1 e2)` where `mult` is always the string `""mult""`, there are always two expressions `e1, e2`, and this expression evaluates to the multiplication of the evaluation of `e1` and the evaluation of `e2`.

For the purposes of this question, we will use a smaller subset of variable names.  A variable starts with a lowercase letter, then zero or more lowercase letters or digits.  Additionally for your convenience, the names ""add"", ""let"", or ""mult"" are protected and will never be used as variable names.

Finally, there is the concept of scope.  When an expression of a variable name is evaluated, within the context of that evaluation, the innermost scope (in terms of parentheses) is checked first for the value of that variable, and then outer scopes are checked sequentially.  It is guaranteed that every expression is legal.  Please see the examples for more details on scope.


Evaluation Examples:
Input: (add 1 2)
Output: 3
Input: (mult 3 (add 2 3))
Output: 15
Input: (let x 2 (mult x 5))
Output: 10
Input: (let x 2 (mult x (let x 3 y 4 (add x y))))
Output: 14
Explanation: In the expression (add x y), when checking for the value of the variable x,
we check from the innermost scope to the outermost in the context of the variable we are trying to evaluate.

Since x = 3 is found first, the value of x is 3.

Input: (let x 3 x 2 x)
Output: 2
Explanation: Assignment in let statements is processed sequentially.

Input: (let x 1 y 2 x (add x y) (add x y))
Output: 5
Explanation: The first (add x y) evaluates as 3, and is assigned to x.

The second (add x y) evaluates as 3+2 = 5.

Input: (let x 2 (add (let x 3 (let x 4 x)) x))
Output: 6
Explanation: Even though (let x 4 x) has a deeper scope, it is outside the context
of the final x in the add-expression.  That final x will equal 2.

Input: (let a1 3 b2 (add a1 1) b2) 
Output 4
Explanation: Variable names can contain digits after the first character.

Note:
The given string `expression` is well formatted: There are no leading or trailing spaces, there is only a single space separating different components of the string, and no space between adjacent parentheses.  The expression is guaranteed to be legal and evaluate to an integer.

The length of `expression` is at most 2000.  (It is also non-empty, as that would not be a legal expression.)
The answer and all intermediate calculations of that answer are guaranteed to fit in a 32-bit integer.",0,/articles/parse-lisp-expression,49.7,6.5,https://leetcode.com/problems/parse-lisp-expression,134,14.9K,30K,Google,String,323,239,57,1,"[Ternary Expression Parser, /problems/ternary-expression-parser/, Medium], [Number of Atoms, /problems/number-of-atoms/, Hard], [Basic Calculator IV, /problems/basic-calculator-iv/, Hard]"
141,741,Cherry Pickup,"You are given an `n x n` `grid` representing a field of cherries, each cell is one of three possible integers.

`0` means the cell is empty, so you can pass through,
`1` means the cell contains a cherry that you can pick up and pass through, or
`-1` means the cell contains a thorn that blocks your way.

Return the maximum number of cherries you can collect by following the rules below:
Starting at the position `(0, 0)` and reaching `(n - 1, n - 1)` by moving right or down through valid path cells (cells with value `0` or `1`).

After reaching `(n - 1, n - 1)`, returning to `(0, 0)` by moving left or up through valid path cells.

When passing through a path cell containing a cherry, you pick it up, and the cell becomes an empty cell `0`.

If there is no valid path between `(0, 0)` and `(n - 1, n - 1)`, then no cherries can be collected.


Example 1:
Input: grid = [[0,1,-1],[1,0,-1],[1,1,1]]
Output: 5
Explanation: The player started at (0, 0) and went down, down, right right to reach (2, 2).

4 cherries were picked up during this single trip, and the matrix becomes [[0,1,-1],[0,0,-1],[0,0,0]].

Then, the player went left, up, up, left to return home, picking up one more cherry.

The total number of cherries picked up is 5, and this is the maximum possible.


Example 2:
Input: grid = [[1,1,-1],[1,-1,1],[-1,1,1]]
Output: 0

Constraints:
`n == grid.length`
`n == grid[i].length`
`1 <= n <= 50`
`grid[i][j]` is `-1`, `0`, or `1`.

`grid[0][0] != -1`
`grid[n - 1][n - 1] != -1`",0,/articles/cherry-pickup,35.2,61.6,https://leetcode.com/problems/cherry-pickup,181,37.1K,105.5K,"Swiggy,Facebook,Mathworks",Dynamic Programming,1562,93,94,1,"[Minimum Path Sum, /problems/minimum-path-sum/, Medium], [Dungeon Game, /problems/dungeon-game/, Hard]"
142,745,Prefix and Suffix Search,"Design a special dictionary which has some words and allows you to search the words in it by a prefix and a suffix.

Implement the `WordFilter` class:
`WordFilter(string[] words)` Initializes the object with the `words` in the dictionary.

`f(string prefix, string suffix)` Returns the index of the word in the dictionary which has the prefix `prefix` and the suffix `suffix`. If there is more than one valid index, return the largest of them. If there is no such word in the dictionary, return `-1`.


Example 1:
Input
[""WordFilter"", ""f""]
[[[""apple""]], [""a"", ""e""]]
Output
[null, 0]
Explanation
WordFilter wordFilter = new WordFilter([""apple""]);
wordFilter.f(""a"", ""e""); // return 0, because the word at index 0 has prefix = ""a"" and suffix = 'e"".


Constraints:
`1 <= words.length <= 15000`
`1 <= words[i].length <= 10`
`1 <= prefix.length, suffix.length <= 10`
`words[i]`, `prefix` and `suffix` consist of lower-case English letters only.

At most `15000` calls will be made to the function `f`.",0,/articles/prefix-and-suffix-search,35.5,3.3,https://leetcode.com/problems/prefix-and-suffix-search,167,22.3K,62.7K,"Amazon,Facebook",Trie,461,234,66,1,"[Design Add and Search Words Data Structure, /problems/design-add-and-search-words-data-structure/, Medium]"
143,749,Contain Virus,"A virus is spreading rapidly, and your task is to quarantine the infected area by installing walls.

The world is modeled as a 2-D array of cells, where `0` represents uninfected cells, and `1` represents cells contaminated with the virus.  A wall (and only one wall) can be installed between any two 4-directionally adjacent cells, on the shared boundary.

Every night, the virus spreads to all neighboring cells in all four directions unless blocked by a wall.

Resources are limited. Each day, you can install walls around only one region -- the affected area (continuous block of infected cells) that threatens the most uninfected cells the following night. There will never be a tie.

Can you save the day? If so, what is the number of walls required? If not, and the world becomes fully infected, return the number of walls used.


Example 1:
Input: grid = 
[[0,1,0,0,0,0,0,1],
 [0,1,0,0,0,0,0,1],
 [0,0,0,0,0,0,0,1],
 [0,0,0,0,0,0,0,0]]
Output: 10
Explanation:
There are 2 contaminated regions.

On the first day, add 5 walls to quarantine the viral region on the left. The board after the virus spreads is:
[[0,1,0,0,0,0,1,1],
 [0,1,0,0,0,0,1,1],
 [0,0,0,0,0,0,1,1],
 [0,0,0,0,0,0,0,1]]
On the second day, add 5 walls to quarantine the viral region on the right. The virus is fully contained.


Example 2:
Input: grid = 
[[1,1,1],
 [1,0,1],
 [1,1,1]]
Output: 4
Explanation: Even though there is only one cell saved, there are 4 walls built.

Notice that walls are only built on the shared boundary of two different cells.


Example 3:
Input: grid = 
[[1,1,1,0,0,0,0,0,0],
 [1,0,1,0,1,1,1,1,1],
 [1,1,1,0,0,0,0,0,0]]
Output: 13
Explanation: The region on the left only builds two new walls.

Note:
The number of rows and columns of `grid` will each be in the range `[1, 50]`.

Each `grid[i][j]` will be either `0` or `1`.

Throughout the described process, there is always a contiguous viral region that will infect strictly more uncontaminated squares in the next round.",0,/articles/contain-virus,48.3,23.5,https://leetcode.com/problems/contain-virus,74,6.4K,13.3K,Accolite,Depth-first Search,138,308,31,0,
144,753,Cracking the Safe,"There is a box protected by a password. The password is a sequence of `n` digits where each digit can be one of the first `k` digits `0, 1, ..., k-1`.

While entering a password, the last `n` digits entered will automatically be matched against the correct password.

For example, assuming the correct password is `""345""`, if you type `""012345""`, the box will open because the correct password matches the suffix of the entered password.

Return any password of minimum length that is guaranteed to open the box at some point of entering it.


Example 1:
Input: n = 1, k = 2
Output: ""01""
Note: ""10"" will be accepted too.


Example 2:
Input: n = 2, k = 2
Output: ""00110""
Note: ""01100"", ""10011"", ""11001"" will be accepted too.

Note:
`n` will be in the range `[1, 4]`.

`k` will be in the range `[1, 10]`.

`k^n` will be at most `4096`.",0,/articles/cracking-the-safe,52.5,29.4,https://leetcode.com/problems/cracking-the-safe,133,35.6K,67.9K,Google,"Math,Depth-first Search",548,807,40,1,
145,757,Set Intersection Size At Least Two,"An integer interval `[a, b]` (for integers `a < b`) is a set of all consecutive integers from `a` to `b`, including `a` and `b`.

Find the minimum size of a set S such that for every integer interval A in `intervals`, the intersection of S with A has a size of at least two.


Example 1:
Input: intervals = [[1,3],[1,4],[2,5],[3,5]]
Output: 3
Explanation: Consider the set S = {2, 3, 4}.  For each interval, there are at least 2 elements from S in the interval.

Also, there isn't a smaller size set that fulfills the above condition.

Thus, we output the size of this set, which is 3.


Example 2:
Input: intervals = [[1,2],[2,3],[2,4],[4,5]]
Output: 5
Explanation: An example of a minimum sized set is {1, 2, 3, 4, 5}.


Constraints:
`1 <= intervals.length <= 3000`
`intervals[i].length == 2`
`0 <= ai < bi <= 108`",0,/articles/set-intersection-size-at-least-two,42.5,14.5,https://leetcode.com/problems/set-intersection-size-at-least-two,74,12.4K,29.1K,Uber,Greedy,356,44,89,0,
146,759,Employee Free Time,"We are given a list `schedule` of employees, which represents the working time for each employee.

Each employee has a list of non-overlapping `Intervals`, and these intervals are in sorted order.

Return the list of finite intervals representing common, positive-length free time for all employees, also in sorted order.

(Even though we are representing `Intervals` in the form `[x, y]`, the objects inside are `Intervals`, not lists or arrays. For example, `schedule[0][0].start = 1`, `schedule[0][0].end = 2`, and `schedule[0][0][0]` is not defined).  Also, we wouldn't include intervals like [5, 5] in our answer, as they have zero length.


Example 1:
Input: schedule = [[[1,2],[5,6]],[[1,3]],[[4,10]]]
Output: [[3,4]]
Explanation: There are a total of three employees, and all common
free time intervals would be [-inf, 1], [3, 4], [10, inf].

We discard any intervals that contain inf as they aren't finite.


Example 2:
Input: schedule = [[[1,3],[6,7]],[[2,4]],[[2,5],[9,12]]]
Output: [[5,6],[7,9]]

Constraints:
`1 <= schedule.length , schedule[i].length <= 50`
`0 <= schedule[i].start < schedule[i].end <= 10^8`",1,/articles/employee-free-time,68.5,74.9,https://leetcode.com/problems/employee-free-time,396,61.5K,89.9K,"DoorDash,Pinterest,Amazon,Intuit,Oracle,Bloomberg,Wayfair","Heap,Greedy",815,54,94,1,"[Merge Intervals, /problems/merge-intervals/, Medium], [Interval List Intersections, /problems/interval-list-intersections/, Medium]"
147,761,Special Binary String,"Special binary strings are binary strings with the following two properties:
The number of 0's is equal to the number of 1's.

Every prefix of the binary string has at least as many 1's as 0's.

Given a special string `S`, a move consists of choosing two consecutive, non-empty, special substrings of `S`, and swapping them.  (Two strings are consecutive if the last character of the first string is exactly one index before the first character of the second string.)
At the end of any number of moves, what is the lexicographically largest resulting string possible?

Example 1:
Input: S = ""11011000""
Output: ""11100100""
Explanation:
The strings ""10"" [occuring at S[1]] and ""1100"" [at S[3]] are swapped.

This is the lexicographically largest string possible after some number of swaps.

Note:
`S` has length at most `50`.

`S` is guaranteed to be a special binary string as defined above.",0,/articles/special-binary-string,58.7,55.1,https://leetcode.com/problems/special-binary-string,54,11.1K,18.8K,Citrix,"String,Recursion",401,134,75,0,"[Valid Parenthesis String, /problems/valid-parenthesis-string/, Medium]"
148,765,Couples Holding Hands,"N couples sit in 2N seats arranged in a row and want to hold hands.  We want to know the minimum number of swaps so that every couple is sitting side by side.  A swap consists of choosing any two people, then they stand up and switch seats. 
The people and seats are represented by an integer from `0` to `2N-1`, the couples are numbered in order, the first couple being `(0, 1)`, the second couple being `(2, 3)`, and so on with the last couple being `(2N-2, 2N-1)`.

The couples' initial seating is given by `row[i]` being the value of the person who is initially sitting in the i-th seat.


Example 1:Input: row = [0, 2, 1, 3]
Output: 1
Explanation: We only need to swap the second (row[1]) and third (row[2]) person.


Example 2:Input: row = [3, 2, 0, 1]
Output: 0
Explanation: All couples are already seated side by side.

Note:
 `len(row)` is even and in the range of `[4, 60]`.

 `row` is guaranteed to be a permutation of `0...len(row)-1`.",0,/articles/couples-holding-hands,55.6,20.0,https://leetcode.com/problems/couples-holding-hands,364,33K,59.4K,Google,"Greedy,Union Find,Graph",1026,68,94,1,"[First Missing Positive, /problems/first-missing-positive/, Hard], [Missing Number, /problems/missing-number/, Easy], [K-Similar Strings, /problems/k-similar-strings/, Hard]"
149,768,Max Chunks To Make Sorted II,"This question is the same as ""Max Chunks to Make Sorted"" except the integers of the given array are not necessarily distinct, the input array could be up to length `2000`, and the elements could be up to `10**8`.

Given an array `arr` of integers (not necessarily distinct), we split the array into some number of ""chunks"" (partitions), and individually sort each chunk.  After concatenating them, the result equals the sorted array.

What is the most number of chunks we could have made?

Example 1:
Input: arr = [5,4,3,2,1]
Output: 1
Explanation:
Splitting into two or more chunks will not return the required result.

For example, splitting into [5, 4], [3, 2, 1] will result in [4, 5, 1, 2, 3], which isn't sorted.


Example 2:
Input: arr = [2,1,3,4,4]
Output: 4
Explanation:
We can split into two chunks, such as [2, 1], [3, 4, 4].

However, splitting into [2, 1], [3], [4], [4] is the highest number of chunks possible.

Note:
`arr` will have length in range `[1, 2000]`.

`arr[i]` will be an integer in range `[0, 10**8]`.",0,/articles/max-chunks-to-make-sorted-ii,49.8,7.6,https://leetcode.com/problems/max-chunks-to-make-sorted-ii,204,26K,52.2K,"Microsoft,Google",Array,562,23,96,1,"[Max Chunks To Make Sorted, /problems/max-chunks-to-make-sorted/, Medium]"
150,770,Basic Calculator IV,"Given an `expression` such as `expression = ""e + 8 - a + 5""` and an evaluation map such as `{""e"": 1}` (given in terms of `evalvars = [""e""]` and `evalints = [1]`), return a list of tokens representing the simplified expression, such as `[""-1*a"",""14""]`
An expression alternates chunks and symbols, with a space separating each chunk and symbol.

A chunk is either an expression in parentheses, a variable, or a non-negative integer.

A variable is a string of lowercase letters (not including digits.) Note that variables can be multiple letters, and note that variables never have a leading coefficient or unary operator like `""2x""` or `""-x""`.

Expressions are evaluated in the usual order: brackets first, then multiplication, then addition and subtraction. For example, `expression = ""1 + 2 * 3""` has an answer of `[""7""]`.

The format of the output is as follows:
For each term of free variables with non-zero coefficient, we write the free variables within a term in sorted order lexicographically. For example, we would never write a term like `""b*a*c""`, only `""a*b*c""`.

Terms have degree equal to the number of free variables being multiplied, counting multiplicity. (For example, `""a*a*b*c""` has degree 4.) We write the largest degree terms of our answer first, breaking ties by lexicographic order ignoring the leading coefficient of the term.

The leading coefficient of the term is placed directly to the left with an asterisk separating it from the variables (if they exist.)  A leading coefficient of 1 is still printed.

An example of a well formatted answer is `[""-2*a*a*a"", ""3*a*a*b"", ""3*b*b"", ""4*a"", ""5*c"", ""-6""]` 
Terms (including constant terms) with coefficient 0 are not included.  For example, an expression of ""0"" has an output of [].


Examples:
Input: expression = ""e + 8 - a + 5"", evalvars = [""e""], evalints = [1]
Output: [""-1*a"",""14""]
Input: expression = ""e - 8 + temperature - pressure"",
evalvars = [""e"", ""temperature""], evalints = [1, 12]
Output: [""-1*pressure"",""5""]
Input: expression = ""(e + 8) * (e - 8)"", evalvars = [], evalints = []
Output: [""1*e*e"",""-64""]
Input: expression = ""7 - 7"", evalvars = [], evalints = []
Output: []
Input: expression = ""a * b * c + b * a * c * 4"", evalvars = [], evalints = []
Output: [""5*a*b*c""]
Input: expression = ""((a - b) * (b - c) + (c - a)) * ((a - b) + (b - c) * (c - a))"",
evalvars = [], evalints = []
Output: [""-1*a*a*b*b"",""2*a*a*b*c"",""-1*a*a*c*c"",""1*a*b*b*b"",""-1*a*b*b*c"",""-1*a*b*c*c"",""1*a*c*c*c"",""-1*b*b*b*c"",""2*b*b*c*c"",""-1*b*c*c*c"",""2*a*a*b"",""-2*a*a*c"",""-2*a*b*b"",""2*a*c*c"",""1*b*b*b"",""-1*b*b*c"",""1*b*c*c"",""-1*c*c*c"",""-1*a*a"",""1*a*b"",""1*a*c"",""-1*b*c""]
Note:
`expression` will have length in range `[1, 250]`.

`evalvars, evalints` will have equal lengths in range `[0, 100]`.",0,/articles/basic-calculator-iv,54.4,62.5,https://leetcode.com/problems/basic-calculator-iv,62,6.2K,11.4K,Roblox,"Hash Table,String,Stack",91,785,10,0,"[Parse Lisp Expression, /problems/parse-lisp-expression/, Hard], [Basic Calculator III, /problems/basic-calculator-iii/, Hard]"
151,772,Basic Calculator III,"Implement a basic calculator to evaluate a simple expression string.

The expression string contains only non-negative integers, `'+'`, `'-'`, `'*'`, `'/'` operators, and open `'('` and closing parentheses `')'`. The integer division should truncate toward zero.

You may assume that the given expression is always valid. All intermediate results will be in the range of `[-231, 231 - 1]`.


Example 1:
Input: s = ""1+1""
Output: 2

Example 2:
Input: s = ""6-4/2""
Output: 4

Example 3:
Input: s = ""2*(5+5*2)/3+(6/2+8)""
Output: 21

Example 4:
Input: s = ""(2+6*3+5-(3*14/7+2)*5)+3""
Output: -12

Example 5:
Input: s = ""0""
Output: 0

Constraints:
`1 <= s <= 104`
`s` consists of digits, `'+'`, `'-'`, `'*'`, `'/'`, `'('`, and `')'`.

`s` is a valid expression.

Follow up: Could you solve the problem without using built-in library functions?",1,,44.0,43.5,https://leetcode.com/problems/basic-calculator-iii,283,55K,125K,"Facebook,Amazon,ByteDance","String,Stack",584,221,73,1,"[Basic Calculator, /problems/basic-calculator/, Hard], [Basic Calculator II, /problems/basic-calculator-ii/, Medium], [Basic Calculator IV, /problems/basic-calculator-iv/, Hard], [Build Binary Expression Tree From Infix Expression, /problems/build-binary-expression-tree-from-infix-expression/, Hard]"
152,773,Sliding Puzzle,"On a 2x3 `board`, there are 5 tiles represented by the integers 1 through 5, and an empty square represented by 0.

A move consists of choosing `0` and a 4-directionally adjacent number and swapping it.

The state of the board is solved if and only if the `board` is `[[1,2,3],[4,5,0]].`
Given a puzzle board, return the least number of moves required so that the state of the board is solved. If it is impossible for the state of the board to be solved, return -1.


Examples:
Input: board = [[1,2,3],[4,0,5]]
Output: 1
Explanation: Swap the 0 and the 5 in one move.

Input: board = [[1,2,3],[5,4,0]]
Output: -1
Explanation: No number of moves will make the board solved.

Input: board = [[4,1,2],[5,0,3]]
Output: 5
Explanation: 5 is the smallest number of moves that solves the board.

An example path:
After move 0: [[4,1,2],[5,0,3]]
After move 1: [[4,1,2],[0,5,3]]
After move 2: [[0,1,2],[4,5,3]]
After move 3: [[1,0,2],[4,5,3]]
After move 4: [[1,2,0],[4,5,3]]
After move 5: [[1,2,3],[4,5,0]]
Input: board = [[3,2,4],[1,5,0]]
Output: 14
Note:
`board` will be a 2 x 3 array as described above.

`board[i][j]` will be a permutation of `[0, 1, 2, 3, 4, 5]`.",0,/articles/sliding-puzzle,61.2,46.8,https://leetcode.com/problems/sliding-puzzle,331,52.1K,85.1K,"Uber,Airbnb,Facebook",Breadth-first Search,941,30,97,1,
153,774,Minimize Max Distance to Gas Station,"You are given an integer array `stations` that represents the positions of the gas stations on the x-axis. You are also given an integer `k`.

You should add `k` new gas stations. You can add the stations anywhere on the x-axis, and not necessarily on an integer position.

Let `penalty()` be the maximum distance between adjacent gas stations after adding the `k` new stations.

Return the smallest possible value of `penalty()`. Answers within `10-6` of the actual answer will be accepted.


Example 1:
Input: stations = [1,2,3,4,5,6,7,8,9,10], k = 9
Output: 0.50000

Example 2:
Input: stations = [23,24,36,39,46,56,57,65,84,98], k = 1
Output: 14.00000

Constraints:
`10 <= stations.length <= 2000`
`0 <= stations[i] <= 108`
`stations` is sorted in a strictly increasing order.

`1 <= k <= 106`",1,/articles/minimize-max-distance-to-gas-station,48.6,0.0,https://leetcode.com/problems/minimize-max-distance-to-gas-station,53,19K,39.1K,Google,Binary Search,426,64,87,1,"[Koko Eating Bananas, /problems/koko-eating-bananas/, Medium]"
154,778,Swim in Rising Water,"On an N x N `grid`, each square `grid[i][j]` represents the elevation at that point `(i,j)`.

Now rain starts to fall. At time `t`, the depth of the water everywhere is `t`. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most `t`. You can swim infinite distance in zero time. Of course, you must stay within the boundaries of the grid during your swim.

You start at the top left square `(0, 0)`. What is the least time until you can reach the bottom right square `(N-1, N-1)`?

Example 1:
Input: [[0,2],[1,3]]
Output: 3
Explanation:
At time `0`, you are in grid location `(0, 0)`.

You cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.

You cannot reach point `(1, 1)` until time `3`.

When the depth of water is `3`, we can swim anywhere inside the grid.


Example 2:
Input: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]
Output: 16
Explanation:
 0  1  2  3  4
24 23 22 21  5
12 13 14 15 16
11 17 18 19 20
10  9  8  7  6
The final route is marked in bold.

We need to wait until time 16 so that (0, 0) and (4, 4) are connected.

Note:
`2 <= N <= 50`.

grid[i][j] is a permutation of [0, ..., N*N - 1].",0,/articles/swim-in-rising-water,54.9,15.7,https://leetcode.com/problems/swim-in-rising-water,271,33.7K,61.4K,Facebook,"Binary Search,Heap,Depth-first Search,Union Find",868,66,93,1,
155,780,Reaching Points,"A move consists of taking a point `(x, y)` and transforming it to either `(x, x+y)` or `(x+y, y)`.

Given a starting point `(sx, sy)` and a target point `(tx, ty)`, return `True` if and only if a sequence of moves exists to transform the point `(sx, sy)` to `(tx, ty)`. Otherwise, return `False`.


Examples:
Input: sx = 1, sy = 1, tx = 3, ty = 5
Output: True
Explanation:
One series of moves that transforms the starting point to the target is:
(1, 1) -> (1, 2)
(1, 2) -> (3, 2)
(3, 2) -> (3, 5)
Input: sx = 1, sy = 1, tx = 2, ty = 2
Output: False
Input: sx = 1, sy = 1, tx = 1, ty = 1
Output: True
Note:
`sx, sy, tx, ty` will all be integers in the range `[1, 10^9]`.",0,/articles/reaching-points,30.4,64.1,https://leetcode.com/problems/reaching-points,110,31K,101.9K,"Twitter,Goldman Sachs",Math,713,128,85,0,
156,782,Transform to Chessboard,"An N x N `board` contains only `0`s and `1`s. In each move, you can swap any 2 rows with each other, or any 2 columns with each other.

What is the minimum number of moves to transform the board into a ""chessboard"" - a board where no `0`s and no `1`s are 4-directionally adjacent? If the task is impossible, return -1.


Examples:
Input: board = [[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]]
Output: 2
Explanation:
One potential sequence of moves is shown below, from left to right:
0110     1010     1010
0110 --> 1010 --> 0101
1001     0101     1010
1001     0101     0101
The first move swaps the first and second column.

The second move swaps the second and third row.

Input: board = [[0, 1], [1, 0]]
Output: 0
Explanation:
Also note that the board with 0 in the top left corner,
01
10
is also a valid chessboard.

Input: board = [[1, 0], [1, 0]]
Output: -1
Explanation:
No matter what sequence of moves you make, you cannot end with a valid chessboard.

Note:
`board` will have the same number of rows and columns, a number in the range `[2, 30]`.

`board[i][j]` will be only `0`s or `1`s.",0,/articles/transform-to-chessboard,47.0,21.7,https://leetcode.com/problems/transform-to-chessboard,29,6.6K,14K,Google,"Array,Math",149,152,50,1,
157,786,K-th Smallest Prime Fraction,"You are given a sorted integer array `arr` containing `1` and prime numbers, where all the integers of `arr` are unique. You are also given an integer `k`.

For every `i` and `j` where `0 <= i < j < arr.length`, we consider the fraction `arr[i] / arr[j]`.

Return the `kth` smallest fraction considered. Return your answer as an array of integers of size `2`, where `answer[0] == arr[i]` and `answer[1] == arr[j]`.


Example 1:
Input: arr = [1,2,3,5], k = 3
Output: [2,5]
Explanation: The fractions to be considered in sorted order are:
1/5, 1/3, 2/5, 1/2, 3/5, and 2/3.

The third fraction is 2/5.


Example 2:
Input: arr = [1,7], k = 1
Output: [1,7]

Constraints:
`2 <= arr.length <= 1000`
`1 <= arr[i] <= 3 * 104`
`arr[0] == 1`
`arr[i]` is a prime number for `i > 0`.

All the numbers of `arr` are unique and sorted in strictly increasing order.

`1 <= k <= arr.length * (arr.length - 1) / 2`",0,/articles/k-th-smallest-prime-fraction,43.3,21.2,https://leetcode.com/problems/k-th-smallest-prime-fraction,92,18.2K,42.1K,Robinhood,"Binary Search,Heap",507,29,95,0,"[Kth Smallest Element in a Sorted Matrix, /problems/kth-smallest-element-in-a-sorted-matrix/, Medium], [Kth Smallest Number in Multiplication Table, /problems/kth-smallest-number-in-multiplication-table/, Hard], [Find K-th Smallest Pair Distance, /problems/find-k-th-smallest-pair-distance/, Hard]"
158,793,Preimage Size of Factorial Zeroes Function,"Let `f(x)` be the number of zeroes at the end of `x!`. (Recall that `x! = 1 * 2 * 3 * ... * x`, and by convention, `0! = 1`.)
For example, `f(3) = 0` because 3! = 6 has no zeroes at the end, while `f(11) = 2` because 11! = 39916800 has 2 zeroes at the end. Given `K`, find how many non-negative integers `x` have the property that `f(x) = K`.


Example 1:
Input: K = 0
Output: 5
Explanation: 0!, 1!, 2!, 3!, and 4! end with K = 0 zeroes.


Example 2:
Input: K = 5
Output: 0
Explanation: There is no x such that x! ends in K = 5 zeroes.

Note:
`K` will be an integer in the range `[0, 10^9]`.",0,/articles/preimage-size-of-factorial-zeroes-function,40.6,0.0,https://leetcode.com/problems/preimage-size-of-factorial-zeroes-function,91,9.5K,23.4K,Adobe,Binary Search,217,62,78,0,"[Factorial Trailing Zeroes, /problems/factorial-trailing-zeroes/, Easy]"
159,798,Smallest Rotation with Highest Score," Given an array `A`, we may rotate it by a non-negative integer `K` so that the array becomes `A[K], A[K+1], A{K+2], ... A[A.length - 1], A[0], A[1], ..., A[K-1]`.  Afterward, any entries that are less than or equal to their index are worth 1 point. 
For example, if we have `[2, 4, 1, 3, 0]`, and we rotate by `K = 2`, it becomes `[1, 3, 0, 2, 4]`.  This is worth 3 points because 1 > 0 [no points], 3 > 1 [no points], 0 <= 2 [one point], 2 <= 3 [one point], 4 <= 4 [one point].

Over all possible rotations, return the rotation index K that corresponds to the highest score we could receive.  If there are multiple answers, return the smallest such index K.


Example 1:
Input: [2, 3, 1, 4, 0]
Output: 3
Explanation:  
Scores for each K are listed below: 
K = 0,  A = [2,3,1,4,0],    score 2
K = 1,  A = [3,1,4,0,2],    score 3
K = 2,  A = [1,4,0,2,3],    score 3
K = 3,  A = [4,0,2,3,1],    score 4
K = 4,  A = [0,2,3,1,4],    score 3
So we should choose K = 3, which has the highest score.


Example 2:
Input: [1, 3, 0, 2, 4]
Output: 0
Explanation:  A will always have 3 points no matter how it shifts.

So we will choose the smallest K, which is 0.

Note:
`A` will have length at most `20000`.

`A[i]` will be in the range `[0, A.length]`.",0,/articles/smallest-rotation-with-highest-score,45.0,0.0,https://leetcode.com/problems/smallest-rotation-with-highest-score,51,6.9K,15.4K,,,262,17,94,0,
160,803,Bricks Falling When Hit,"You are given an `m x n` binary `grid`, where each `1` represents a brick and `0` represents an empty space. A brick is stable if:
It is directly connected to the top of the grid, or
At least one other brick in its four adjacent cells is stable.

You are also given an array `hits`, which is a sequence of erasures we want to apply. Each time we want to erase the brick at the location `hits[i] = (rowi, coli)`. The brick on that location (if it exists) will disappear. Some other bricks may no longer be stable because of that erasure and will fall. Once a brick falls, it is immediately erased from the `grid` (i.e., it does not land on other stable bricks).

Return an array `result`, where each `result[i]` is the number of bricks that will fall after the `ith` erasure is applied.

Note that an erasure may refer to a location with no brick, and if it does, no bricks drop.


Example 1:
Input: grid = [[1,0,0,0],[1,1,1,0]], hits = [[1,0]]
Output: [2]
Explanation: Starting with the grid:
[[1,0,0,0],
 [1,1,1,0]]
We erase the underlined brick at (1,0), resulting in the grid:
[[1,0,0,0],
 [0,1,1,0]]
The two underlined bricks are no longer stable as they are no longer connected to the top nor adjacent to another stable brick, so they will fall. The resulting grid is:
[[1,0,0,0],
 [0,0,0,0]]
Hence the result is [2].


Example 2:
Input: grid = [[1,0,0,0],[1,1,0,0]], hits = [[1,1],[1,0]]
Output: [0,0]
Explanation: Starting with the grid:
[[1,0,0,0],
 [1,1,0,0]]
We erase the underlined brick at (1,1), resulting in the grid:
[[1,0,0,0],
 [1,0,0,0]]
All remaining bricks are still stable, so no bricks fall. The grid remains the same:
[[1,0,0,0],
 [1,0,0,0]]
Next, we erase the underlined brick at (1,0), resulting in the grid:
[[1,0,0,0],
 [0,0,0,0]]
Once again, all remaining bricks are still stable, so no bricks fall.

Hence the result is [0,0].


Constraints:
`m == grid.length`
`n == grid[i].length`
`1 <= m, n <= 200`
`grid[i][j]` is `0` or `1`.

`1 <= hits.length <= 4 * 104`
`hits[i].length == 2`
`0 <= xi <= m - 1`
`0 <= yi <= n - 1`
All `(xi, yi)` are unique.",0,/articles/bricks-falling-when-hit,31.8,2.4,https://leetcode.com/problems/bricks-falling-when-hit,57,17.8K,55.9K,Google,Union Find,534,151,78,1,
161,805,Split Array With Same Average,"You are given an integer array `nums`.

You should move each element of `nums` into one of the two arrays `A` and `B` such that `A` and `B` are non-empty, and `average(A) == average(B)`.

Return `true` if it is possible to achieve that and `false` otherwise.

Note that for an array `arr`, `average(arr)` is the sum of all the elements of `arr` over the length of `arr`.


Example 1:
Input: nums = [1,2,3,4,5,6,7,8]
Output: true
Explanation: We can split the array into [1,4,5,8] and [2,3,6,7], and both of them have an average of 4.5.


Example 2:
Input: nums = [3,1]
Output: false

Constraints:
`1 <= nums.length <= 30`
`0 <= nums[i] <= 104`",0,/articles/split-array-with-same-average,26.9,7.9,https://leetcode.com/problems/split-array-with-same-average,127,19.3K,71.7K,Apple,Math,506,94,84,1,
162,810,Chalkboard XOR Game,"We are given non-negative integers nums[i] which are written on a chalkboard.  Alice and Bob take turns erasing exactly one number from the chalkboard, with Alice starting first.  If erasing a number causes the bitwise XOR of all the elements of the chalkboard to become 0, then that player loses.  (Also, we'll say the bitwise XOR of one element is that element itself, and the bitwise XOR of no elements is 0.)
Also, if any player starts their turn with the bitwise XOR of all the elements of the chalkboard equal to 0, then that player wins.

Return True if and only if Alice wins the game, assuming both players play optimally.


Example:
Input: nums = [1, 1, 2]
Output: false
Explanation: 
Alice has two choices: erase 1 or erase 2. 
If she erases 1, the nums array becomes [1, 2]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 2 = 3. Now Bob can remove any element he wants, because Alice will be the one to erase the last element and she will lose. 
If Alice erases 2 first, now nums becomes [1, 1]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 1 = 0. Alice will lose.

Notes: 
`1 <= N <= 1000`. 
`0 <= nums[i] <= 2^16`.",0,/articles/chalkboard-xor-game,50.2,4.8,https://leetcode.com/problems/chalkboard-xor-game,41,5K,9.9K,Garena,Math,80,197,29,0,
163,815,Bus Routes,"You are given an array `routes` representing bus routes where `routes[i]` is a bus route that the `ith` bus repeats forever.

For example, if `routes[0] = [1, 5, 7]`, this means that the `0th` bus travels in the sequence `1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ...` forever.

You will start at the bus stop `source` (You are not on any bus initially), and you want to go to the bus stop `target`. You can travel between bus stops by buses only.

Return the least number of buses you must take to travel from `source` to `target`. Return `-1` if it is not possible.


Example 1:
Input: routes = [[1,2,7],[3,6,7]], source = 1, target = 6
Output: 2
Explanation: The best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6.


Example 2:
Input: routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12
Output: -1

Constraints:
`1 <= routes.length <= 500`.

`1 <= routes[i].length <= 105`
All the values of `routes[i]` are unique.

`sum(routes[i].length) <= 105`
`0 <= routes[i][j] < 106`
`0 <= source, target < 106`",0,/articles/bus-routes,43.6,42.7,https://leetcode.com/problems/bus-routes,234,48.4K,111.1K,"Amazon,Square,Uber",Breadth-first Search,1072,33,97,1,
164,818,Race Car,"Your car starts at position 0 and speed +1 on an infinite number line.  (Your car can go into negative positions.)
Your car drives automatically according to a sequence of instructions A (accelerate) and R (reverse).

When you get an instruction ""A"", your car does the following: `position += speed, speed *= 2`.

When you get an instruction ""R"", your car does the following: if your speed is positive then `speed = -1` , otherwise `speed = 1`.  (Your position stays the same.)
For example, after commands ""AAR"", your car goes to positions 0->1->3->3, and your speed goes to 1->2->4->-1.

Now for some target position, say the length of the shortest sequence of instructions to get there.


Example 1:
Input: 
target = 3
Output: 2
Explanation: 
The shortest instruction sequence is ""AA"".

Your position goes from 0->1->3.


Example 2:
Input: 
target = 6
Output: 5
Explanation: 
The shortest instruction sequence is ""AAARA"".

Your position goes from 0->1->3->7->7->6.

Note: 
`1 <= target <= 10000`.",0,/articles/race-car,40.3,13.5,https://leetcode.com/problems/race-car,102,24.4K,60.5K,Google,"Dynamic Programming,Heap",632,69,90,1,
165,827,Making A Large Island,"You are given an `n x n` binary matrix `grid`. You are allowed to change at most one `0` to be `1`.

Return the size of the largest island in `grid` after applying this operation.

An island is a 4-directionally connected group of `1`s.


Example 1:
Input: grid = [[1,0],[0,1]]
Output: 3
Explanation: Change one 0 to 1 and connect two 1s, then we get an island with area = 3.


Example 2:
Input: grid = [[1,1],[1,0]]
Output: 4
Explanation: Change the 0 to 1 and make the island bigger, only one island with area = 4.


Example 3:
Input: grid = [[1,1],[1,1]]
Output: 4
Explanation: Can't change any 0 to 1, only one island with area = 4.


Constraints:
`n == grid.length`
`n == grid[i].length`
`1 <= n <= 500`
`grid[i][j]` is either `0` or `1`.",0,/articles/making-a-large-island,47.3,36.3,https://leetcode.com/problems/making-a-large-island,290,31.1K,65.9K,"Facebook,Google,Amazon","Depth-first Search,Breadth-first Search",712,22,97,1,
166,828,Count Unique Characters of All Substrings of a Given String,"Let's define a function `countUniqueChars(s)` that returns the number of unique characters on `s`, for example if `s = ""LEETCODE""` then `""L""`, `""T""`,`""C""`,`""O""`,`""D""` are the unique characters since they appear only once in `s`, therefore `countUniqueChars(s) = 5`.

On this problem given a string `s` we need to return the sum of `countUniqueChars(t)` where `t` is a substring of `s`. Notice that some substrings can be repeated so on this case you have to count the repeated ones too.

Since the answer can be very large, return the answer modulo `10 ^ 9 + 7`.


Example 1:
Input: s = ""ABC""
Output: 10
Explanation: All possible substrings are: ""A"",""B"",""C"",""AB"",""BC"" and ""ABC"".

Evey substring is composed with only unique letters.

Sum of lengths of all substring is 1 + 1 + 1 + 2 + 2 + 3 = 10

Example 2:
Input: s = ""ABA""
Output: 8
Explanation: The same as example 1, except `countUniqueChars`(""ABA"") = 1.


Example 3:
Input: s = ""LEETCODE""
Output: 92

Constraints:
`0 <= s.length <= 10^4`
`s` contain upper-case English letters only.",0,/articles/unique-letter-string,46.9,27.7,https://leetcode.com/problems/count-unique-characters-of-all-substrings-of-a-given-string,127,15.2K,32.4K,Microsoft,Two Pointers,608,61,91,0,
167,829,Consecutive Numbers Sum,"Given a positive integer `N`, how many ways can we write it as a sum of consecutive positive integers?

Example 1:
Input: 5
Output: 2
Explanation: 5 = 5 = 2 + 3

Example 2:
Input: 9
Output: 3
Explanation: 9 = 9 = 4 + 5 = 2 + 3 + 4

Example 3:
Input: 15
Output: 4
Explanation: 15 = 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5
Note: `1 <= N <= 10 ^ 9`.",0,/articles/consecutive-numbers-sum,39.3,86.1,https://leetcode.com/problems/consecutive-numbers-sum,236,44.9K,114.3K,"Citadel,Visa,Amazon,Nvidia",Math,598,750,44,1,
168,834,Sum of Distances in Tree,"An undirected, connected tree with `N` nodes labelled `0...N-1` and `N-1` `edges` are given.

The `i`th edge connects nodes `edges[i][0] `and` edges[i][1]` together.

Return a list `ans`, where `ans[i]` is the sum of the distances between node `i` and all other nodes.


Example 1:
Input: N = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]]
Output: [8,12,6,10,10,10]
Explanation: 
Here is a diagram of the given tree:
  0
 / \
1   2
   /|\
  3 4 5
We can see that dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5)
equals 1 + 1 + 2 + 2 + 2 = 8.  Hence, answer[0] = 8, and so on.

Note: `1 <= N <= 10000`",0,/articles/sum-of-distances-in-tree,46.5,19.4,https://leetcode.com/problems/sum-of-distances-in-tree,115,19.9K,42.7K,Google,"Tree,Depth-first Search",1218,46,96,1,"[Distribute Coins in Binary Tree, /problems/distribute-coins-in-binary-tree/, Medium]"
169,839,Similar String Groups,"Two strings `X` and `Y` are similar if we can swap two letters (in different positions) of `X`, so that it equals `Y`. Also two strings `X` and `Y` are similar if they are equal.

For example, `""tars""` and `""rats""` are similar (swapping at positions `0` and `2`), and `""rats""` and `""arts""` are similar, but `""star""` is not similar to `""tars""`, `""rats""`, or `""arts""`.

Together, these form two connected groups by similarity: `{""tars"", ""rats"", ""arts""}` and `{""star""}`.  Notice that `""tars""` and `""arts""` are in the same group even though they are not similar.  Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group.

We are given a list `strs` of strings where every string in `strs` is an anagram of every other string in `strs`. How many groups are there?

Example 1:
Input: strs = [""tars"",""rats"",""arts"",""star""]
Output: 2

Example 2:
Input: strs = [""omv"",""ovm""]
Output: 1

Constraints:
`1 <= strs.length <= 300`
`1 <= strs[i].length <= 300`
`strs[i]` consists of lowercase letters only.

All words in `strs` have the same length and are anagrams of each other.",0,/articles/similar-string-groups,41.6,14.6,https://leetcode.com/problems/similar-string-groups,266,35.2K,84.7K,Facebook,"Depth-first Search,Union Find,Graph",514,148,78,1,
170,843,Guess the Word,"This is an interactive problem.

You are given an array of unique strings `wordlist` where `wordlist[i]` is `6` letters long, and one word in this list is chosen as `secret`.

You may call `Master.guess(word)` to guess a word. The guessed word should have type `string` and must be from the original list with `6` lowercase letters.

This function returns an `integer` type, representing the number of exact matches (value and position) of your guess to the `secret` word. Also, if your guess is not in the given wordlist, it will return `-1` instead.

For each test case, you have exactly `10` guesses to guess the word. At the end of any number of calls, if you have made `10` or fewer calls to `Master.guess` and at least one of these guesses was `secret`, then you pass the test case.


Example 1:
Input: secret = ""acckzz"", wordlist = [""acckzz"",""ccbazz"",""eiowzz"",""abcczz""], numguesses = 10
Output: You guessed the secret word correctly.
Explanation:
master.guess(""aaaaaa"") returns -1, because ""aaaaaa"" is not in wordlist.

master.guess(""acckzz"") returns 6, because ""acckzz"" is secret and has all 6 matches.

master.guess(""ccbazz"") returns 3, because ""ccbazz"" has 3 matches.

master.guess(""eiowzz"") returns 2, because ""eiowzz"" has 2 matches.

master.guess(""abcczz"") returns 4, because ""abcczz"" has 4 matches.

We made 5 calls to master.guess and one of them was the secret, so we pass the test case.


Example 2:
Input: secret = ""hamada"", wordlist = [""hamada"",""khaled""], numguesses = 10
Output: You guessed the secret word correctly.

Constraints:
`1 <= wordlist.length <= 100`
`wordlist[i].length == 6`
`wordlist[i]` consist of lowercase English letters.

All the strings of `wordlist` are unique.

`secret` exists in `wordlist`.

`numguesses == 10`",0,/articles/guess-the-word,46.4,67.2,https://leetcode.com/problems/guess-the-word,237,71.6K,154.3K,Google,Minimax,778,789,50,1,
171,847,Shortest Path Visiting All Nodes,"An undirected, connected graph of N nodes (labeled `0, 1, 2, ..., N-1`) is given as `graph`.

`graph.length = N`, and `j != i` is in the list `graph[i]` exactly once, if and only if nodes `i` and `j` are connected.

Return the length of the shortest path that visits every node. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.


Example 1:
Input: [[1,2,3],[0],[0],[0]]
Output: 4
Explanation: One possible path is [1,0,2,0,3]

Example 2:
Input: [[1],[0,2,4],[1,3,4],[2],[1,2]]
Output: 4
Explanation: One possible path is [0,1,4,2,3]
Note:
`1 <= graph.length <= 12`
`0 <= graph[i].length < graph.length`",0,/articles/shortest-path-visiting-all-nodes,54.1,19.8,https://leetcode.com/problems/shortest-path-visiting-all-nodes,136,21.7K,40.1K,Google,"Dynamic Programming,Breadth-first Search",787,84,90,1,
172,850,Rectangle Area II,"We are given a list of (axis-aligned) `rectangles`. Each `rectangle[i] = [xi1, yi1, xi2, yi2] `, where `(xi1, yi1)` are the coordinates of the bottom-left corner, and `(xi2, yi2)` are the coordinates of the top-right corner of the `ith` rectangle.

Find the total area covered by all `rectangles` in the plane. Since the answer may be too large, return it modulo `109 + 7`.


Example 1:
Input: rectangles = [[0,0,2,2],[1,0,2,3],[1,0,3,1]]
Output: 6
Explanation: As illustrated in the picture.


Example 2:
Input: rectangles = [[0,0,1000000000,1000000000]]
Output: 49
Explanation: The answer is 1018 modulo (109 + 7), which is (109)2 = (-7)2 = 49.


Constraints:
`1 <= rectangles.length <= 200`
`rectanges[i].length = 4`
`0 <= rectangles[i][j] <= 109`
The total area covered by all rectangles will never exceed `263 - 1` and thus will fit in a 64-bit signed integer.",0,/articles/rectangle-area-ii,48.4,29.4,https://leetcode.com/problems/rectangle-area-ii,84,15.3K,31.6K,Sumologic,"Segment Tree,Line Sweep",449,32,93,0,
173,854,K-Similar Strings,"Strings `s1` and `s2` are `k`-similar (for some non-negative integer `k`) if we can swap the positions of two letters in `s1` exactly `k` times so that the resulting string equals `s2`.

Given two anagrams `s1` and `s2`, return the smallest `k` for which `s1` and `s2` are `k`-similar.


Example 1:
Input: s1 = ""ab"", s2 = ""ba""
Output: 1

Example 2:
Input: s1 = ""abc"", s2 = ""bca""
Output: 2

Example 3:
Input: s1 = ""abac"", s2 = ""baca""
Output: 2

Example 4:
Input: s1 = ""aabc"", s2 = ""abca""
Output: 2

Constraints:
`1 <= s1.length <= 20`
`s2.length == s1.length`
`s1` and `s2` contain only lowercase letters from the set `{'a', 'b', 'c', 'd', 'e', 'f'}`.

`s2` is an anagram of `s1`.",0,/articles/k-similar-strings,38.8,4.4,https://leetcode.com/problems/k-similar-strings,143,23.5K,60.5K,Amazon,"Breadth-first Search,Graph",567,43,93,1,"[Couples Holding Hands, /problems/couples-holding-hands/, Hard]"
174,857,Minimum Cost to Hire K Workers,"There are `N` workers.  The `i`-th worker has a `quality[i]` and a minimum wage expectation `wage[i]`.

Now we want to hire exactly `K` workers to form a paid group.  When hiring a group of K workers, we must pay them according to the following rules:
Every worker in the paid group should be paid in the ratio of their quality compared to other workers in the paid group.

Every worker in the paid group must be paid at least their minimum wage expectation.

Return the least amount of money needed to form a paid group satisfying the above conditions.


Example 1:
Input: quality = [10,20,5], wage = [70,50,30], K = 2
Output: 105.00000
Explanation: We pay 70 to 0-th worker and 35 to 2-th worker.


Example 2:
Input: quality = [3,1,10,10,1], wage = [4,8,2,2,7], K = 3
Output: 30.66667
Explanation: We pay 4 to 0-th worker, 13.33333 to 2-th and 3-th workers seperately. 
Note:
`1 <= K <= N <= 10000`, where `N = quality.length = wage.length`
`1 <= quality[i] <= 10000`
`1 <= wage[i] <= 10000`
Answers within `10^-5` of the correct answer will be considered correct.",0,/articles/minimum-cost-to-hire-k-workers,50.5,23.6,https://leetcode.com/problems/minimum-cost-to-hire-k-workers,132,37.8K,74.8K,Google,Heap,1142,134,89,1,
175,862,Shortest Subarray with Sum at Least K,"Return the length of the shortest, non-empty, contiguous subarray of `A` with sum at least `K`.

If there is no non-empty subarray with sum at least `K`, return `-1`.


Example 1:
Input: A = [1], K = 1
Output: 1

Example 2:
Input: A = [1,2], K = 4
Output: -1

Example 3:
Input: A = [2,-1,2], K = 3
Output: 3
Note:
`1 <= A.length <= 50000`
`-10 ^ 5 <= A[i] <= 10 ^ 5`
`1 <= K <= 10 ^ 9`",0,/articles/shortest-subarray-with-sum-at-least-k,25.3,46.6,https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k,179,45.1K,178.2K,Goldman Sachs,"Binary Search,Queue",1714,39,98,0,
176,864,Shortest Path to Get All Keys,"We are given a 2-dimensional `grid`. `"".""` is an empty cell, `""#""` is a wall, `""@""` is the starting point, (`""a""`, `""b""`, ...) are keys, and (`""A""`, `""B""`, ...) are locks.

We start at the starting point, and one move consists of walking one space in one of the 4 cardinal directions.  We cannot walk outside the grid, or walk into a wall.  If we walk over a key, we pick it up.  We can't walk over a lock unless we have the corresponding key.

For some 1 <= K <= 6, there is exactly one lowercase and one uppercase letter of the first `K` letters of the English alphabet in the grid.  This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.

Return the lowest number of moves to acquire all keys.  If it's impossible, return `-1`.


Example 1:
Input: [""@.a.#"",""###.#"",""b.A.B""]
Output: 8

Example 2:
Input: [""@..aA"",""..B#."",""....b""]
Output: 6
Note:
`1 <= grid.length <= 30`
`1 <= grid[0].length <= 30`
`grid[i][j]` contains only` '.'`, `'#'`, `'@'`, `'a'-``'f``'` and `'A'-'F'`
The number of keys is in `[1, 6]`.  Each key has a different letter and opens exactly one lock.",0,/articles/shortest-path-to-get-all-keys,42.4,36.8,https://leetcode.com/problems/shortest-path-to-get-all-keys,139,15.6K,36.7K,"ByteDance,Airbnb","Heap,Breadth-first Search",543,19,97,0,
177,871,Minimum Number of Refueling Stops,"A car travels from a starting position to a destination which is `target` miles east of the starting position.

Along the way, there are gas stations.  Each `station[i]` represents a gas station that is `station[i][0]` miles east of the starting position, and has `station[i][1]` liters of gas.

The car starts with an infinite tank of gas, which initially has `startFuel` liters of fuel in it.  It uses 1 liter of gas per 1 mile that it drives.

When the car reaches a gas station, it may stop and refuel, transferring all the gas from the station into the car.

What is the least number of refueling stops the car must make in order to reach its destination?  If it cannot reach the destination, return `-1`.

Note that if the car reaches a gas station with 0 fuel left, the car can still refuel there.  If the car reaches the destination with 0 fuel left, it is still considered to have arrived.


Example 1:
Input: target = 1, startFuel = 1, stations = []
Output: 0
Explanation: We can reach the target without refueling.


Example 2:
Input: target = 100, startFuel = 1, stations = [[10,100]]
Output: -1
Explanation: We can't reach the target (or even the first gas station).


Example 3:
Input: target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]]
Output: 2
Explanation: 
We start with 10 liters of fuel.

We drive to position 10, expending 10 liters of fuel.  We refuel from 0 liters to 60 liters of gas.

Then, we drive from position 10 to position 60 (expending 50 liters of fuel),
and refuel from 10 liters to 50 liters of gas.  We then drive to and reach the target.

We made 2 refueling stops along the way, so we return 2.

Note:
`1 <= target, startFuel, stations[i][1] <= 10^9`
`0 <= stations.length <= 500`
`0 < stations[0][0] < stations[1][0] < ... < stations[stations.length-1][0] < target`",0,/articles/minimum-number-of-refueling-stops,32.4,62.5,https://leetcode.com/problems/minimum-number-of-refueling-stops,173,28K,86.4K,"Flipkart,Google","Dynamic Programming,Heap",1143,26,98,1,
178,878,Nth Magical Number,"A positive integer is magical if it is divisible by either `a` or `b`.

Given the three integers `n`, `a`, and `b`, return the `nth` magical number. Since the answer may be very large, return it modulo `109 + 7`.


Example 1:
Input: n = 1, a = 2, b = 3
Output: 2

Example 2:
Input: n = 4, a = 2, b = 3
Output: 6

Example 3:
Input: n = 5, a = 2, b = 4
Output: 10

Example 4:
Input: n = 3, a = 6, b = 4
Output: 8

Constraints:
`1 <= n <= 109`
`2 <= a, b <= 4 * 104`",0,/articles/nth-magical-number,28.9,7.3,https://leetcode.com/problems/nth-magical-number,97,11.7K,40.4K,,,265,67,80,0,
179,879,Profitable Schemes,"There is a group of `n` members, and a list of various crimes they could commit. The `ith` crime generates a `profit[i]` and requires `group[i]` members to participate in it. If a member participates in one crime, that member can't participate in another crime.

Let's call a profitable scheme any subset of these crimes that generates at least `minProfit` profit, and the total number of members participating in that subset of crimes is at most `n`.

Return the number of schemes that can be chosen. Since the answer may be very large, return it modulo `109 + 7`.


Example 1:
Input: n = 5, minProfit = 3, group = [2,2], profit = [2,3]
Output: 2
Explanation: To make a profit of at least 3, the group could either commit crimes 0 and 1, or just crime 1.

In total, there are 2 schemes.


Example 2:
Input: n = 10, minProfit = 5, group = [2,3,5], profit = [6,7,8]
Output: 7
Explanation: To make a profit of at least 5, the group could commit any crimes, as long as they commit one.

There are 7 possible schemes: (0), (1), (2), (0,1), (0,2), (1,2), and (0,1,2).


Constraints:
`1 <= n <= 100`
`0 <= minProfit <= 100`
`1 <= group.length <= 100`
`1 <= group[i] <= 100`
`profit.length == group.length`
`0 <= profit[i] <= 100`",0,/articles/profitable-schemes,39.9,9.7,https://leetcode.com/problems/profitable-schemes,68,11.4K,28.5K,Google,Dynamic Programming,297,32,90,1,
180,882,Reachable Nodes In Subdivided Graph,"You are given an undirected graph (the ""original graph"") with `n` nodes labeled from `0` to `n - 1`. You decide to subdivide each edge in the graph into a chain of nodes, with the number of new nodes varying between each edge.

The graph is given as a 2D array of `edges` where `edges[i] = [ui, vi, cnti]` indicates that there is an edge between nodes `ui` and `vi` in the original graph, and `cnti` is the total number of new nodes that you will subdivide the edge into. Note that `cnti == 0` means you will not subdivide the edge.

To subdivide the edge `[ui, vi]`, replace it with `(cnti + 1)` new edges and `cnti` new nodes. The new nodes are `x1`, `x2`, ..., `xcnti`, and the new edges are `[ui, x1]`, `[x1, x2]`, `[x2, x3]`, ..., `[xcnti+1, xcnti]`, `[xcnti, vi]`.

In this new graph, you want to know how many nodes are reachable from the node `0`, where a node is reachable if the distance is `maxMoves` or less.

Given the original graph and `maxMoves`, return the number of nodes that are reachable from node `0` in the new graph.


Example 1:
Input: edges = [[0,1,10],[0,2,1],[1,2,2]], maxMoves = 6, n = 3
Output: 13
Explanation: The edge subdivisions are shown in the image above.

The nodes that are reachable are highlighted in yellow.


Example 2:
Input: edges = [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], maxMoves = 10, n = 4
Output: 23

Example 3:
Input: edges = [[1,2,4],[1,4,5],[1,3,1],[2,3,4],[3,4,5]], maxMoves = 17, n = 5
Output: 1
Explanation: Node 0 is disconnected from the rest of the graph, so only node 0 is reachable.


Constraints:
`0 <= edges.length <= min(n * (n - 1) / 2, 104)`
`edges[i].length == 3`
`0 <= ui < vi < n`
There are no multiple edges in the graph.

`0 <= cnti <= 104`
`0 <= maxMoves <= 109`
`1 <= n <= 3000`",0,/articles/reachable-nodes-in-subdivided-graph,43.1,14.3,https://leetcode.com/problems/reachable-nodes-in-subdivided-graph,53,7.3K,17K,Amazon,"Heap,Breadth-first Search",183,155,54,1,
181,887,Super Egg Drop,"You are given `k` identical eggs and you have access to a building with `n` floors labeled from `1` to `n`.

You know that there exists a floor `f` where `0 <= f <= n` such that any egg dropped at a floor higher than `f` will break, and any egg dropped at or below floor `f` will not break.

Each move, you may take an unbroken egg and drop it from any floor `x` (where `1 <= x <= n`). If the egg breaks, you can no longer use it. However, if the egg does not break, you may reuse it in future moves.

Return the minimum number of moves that you need to determine with certainty what the value of `f` is.


Example 1:
Input: k = 1, n = 2
Output: 2
Explanation: 
Drop the egg from floor 1. If it breaks, we know that f = 0.

Otherwise, drop the egg from floor 2. If it breaks, we know that f = 1.

If it does not break, then we know f = 2.

Hence, we need at minimum 2 moves to determine with certainty what the value of f is.


Example 2:
Input: k = 2, n = 6
Output: 3

Example 3:
Input: k = 3, n = 14
Output: 4

Constraints:
`1 <= k <= 100`
`1 <= n <= 104`",0,/articles/super-egg-drop,27.0,42.2,https://leetcode.com/problems/super-egg-drop,121,28.8K,106.7K,Amazon,"Math,Binary Search,Dynamic Programming",1332,96,93,1,
182,891,Sum of Subsequence Widths,"Given an array of integers `A`, consider all non-empty subsequences of `A`.

For any sequence S, let the width of S be the difference between the maximum and minimum element of S.

Return the sum of the widths of all subsequences of A. 
As the answer may be very large, return the answer modulo 10^9 + 7.


Example 1:
Input: [2,1,3]
Output: 6
Explanation:
Subsequences are [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3].

The corresponding widths are 0, 0, 0, 1, 1, 2, 2.

The sum of these widths is 6.

Note:
`1 <= A.length <= 20000`
`1 <= A[i] <= 20000`",0,/articles/sum-of-subsequence-widths,33.1,3.3,https://leetcode.com/problems/sum-of-subsequence-widths,59,10.5K,31.7K,Sapient,"Array,Math",319,110,74,0,
183,895,Maximum Frequency Stack,"Design a stack-like data structure to push elements to the stack and pop the most frequent element from the stack.

Implement the `FreqStack` class:
`FreqStack()` constructs an empty frequency stack.

`void push(int val)` pushes an integer `val` onto the top of the stack.

`int pop()` removes and returns the most frequent element in the stack.

	
If there is a tie for the most frequent element, the element closest to the stack's top is removed and returned.


Example 1:
Input
[""FreqStack"", ""push"", ""push"", ""push"", ""push"", ""push"", ""push"", ""pop"", ""pop"", ""pop"", ""pop""]
[[], [5], [7], [5], [7], [4], [5], [], [], [], []]
Output
[null, null, null, null, null, null, null, 5, 7, 5, 4]
Explanation
FreqStack freqStack = new FreqStack();
freqStack.push(5); // The stack is [5]
freqStack.push(7); // The stack is [5,7]
freqStack.push(5); // The stack is [5,7,5]
freqStack.push(7); // The stack is [5,7,5,7]
freqStack.push(4); // The stack is [5,7,5,7,4]
freqStack.push(5); // The stack is [5,7,5,7,4,5]
freqStack.pop();   // return 5, as 5 is the most frequent. The stack becomes [5,7,5,7,4].

freqStack.pop();   // return 7, as 5 and 7 is the most frequent, but 7 is closest to the top. The stack becomes [5,7,5,4].

freqStack.pop();   // return 5, as 5 is the most frequent. The stack becomes [5,7,4].

freqStack.pop();   // return 4, as 4, 5 and 7 is the most frequent, but 4 is closest to the top. The stack becomes [5,7].


Constraints:
`0 <= val <= 109`
At most `2 * 104` calls will be made to `push` and `pop`.

It is guaranteed that there will be at least one element in the stack before calling `pop`.",0,/articles/maximum-frequency-stack,63.2,52.7,https://leetcode.com/problems/maximum-frequency-stack,359,66.6K,105.3K,"Amazon,Microsoft,Bloomberg,Adobe","Hash Table,Stack",1768,37,98,1,
184,899,Orderly Queue,"A string `S` of lowercase letters is given.  Then, we may make any number of moves.

In each move, we choose one of the first `K` letters (starting from the left), remove it, and place it at the end of the string.

Return the lexicographically smallest string we could have after any number of moves.


Example 1:
Input: S = ""cba"", K = 1
Output: ""acb""
Explanation: 
In the first move, we move the 1st character (""c"") to the end, obtaining the string ""bac"".

In the second move, we move the 1st character (""b"") to the end, obtaining the final result ""acb"".


Example 2:
Input: S = ""baaca"", K = 3
Output: ""aaabc""
Explanation: 
In the first move, we move the 1st character (""b"") to the end, obtaining the string ""aacab"".

In the second move, we move the 3rd character (""c"") to the end, obtaining the final result ""aaabc"".

Note:
`1 <= K <= S.length <= 1000`
`S` consists of lowercase letters only.",0,/articles/orderly-queue,53.4,4.2,https://leetcode.com/problems/orderly-queue,57,9.5K,17.7K,Amazon,"Math,String",251,225,53,1,
185,902,Numbers At Most N Given Digit Set,"Given an array of `digits` which is sorted in non-decreasing order. You can write numbers using each `digits[i]` as many times as we want. For example, if `digits = ['1','3','5']`, we may write numbers such as `'13'`, `'551'`, and `'1351315'`.

Return the number of positive integers that can be generated that are less than or equal to a given integer `n`.


Example 1:
Input: digits = [""1"",""3"",""5"",""7""], n = 100
Output: 20
Explanation: 
The 20 numbers that can be written are:
1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.


Example 2:
Input: digits = [""1"",""4"",""9""], n = 1000000000
Output: 29523
Explanation: 
We can write 3 one digit numbers, 9 two digit numbers, 27 three digit numbers,
81 four digit numbers, 243 five digit numbers, 729 six digit numbers,
2187 seven digit numbers, 6561 eight digit numbers, and 19683 nine digit numbers.

In total, this is 29523 integers that can be written using the digits array.


Example 3:
Input: digits = [""7""], n = 8
Output: 1

Constraints:
`1 <= digits.length <= 9`
`digits[i].length == 1`
`digits[i]` is a digit from `'1'` to `'9'`.

All the values in `digits` are unique.

`digits` is sorted in non-decreasing order.

`1 <= n <= 109`",0,/articles/numbers-at-most-n-given-digit-set,36.1,20.2,https://leetcode.com/problems/numbers-at-most-n-given-digit-set,183,20.3K,56.2K,Amazon,"Math,Dynamic Programming",492,68,88,1,
186,903,Valid Permutations for DI Sequence,"We are given `S`, a length `n` string of characters from the set `{'D', 'I'}`. (These letters stand for ""decreasing"" and ""increasing"".)
A valid permutation is a permutation `P[0], P[1], ..., P[n]` of integers `{0, 1, ..., n}`, such that for all `i`:
If `S[i] == 'D'`, then `P[i] > P[i+1]`, and;
If `S[i] == 'I'`, then `P[i] < P[i+1]`.

How many valid permutations are there?  Since the answer may be large, return your answer modulo `10^9 + 7`.


Example 1:
Input: ""DID""
Output: 5
Explanation: 
The 5 valid permutations of (0, 1, 2, 3) are:
(1, 0, 3, 2)
(2, 0, 3, 1)
(2, 1, 3, 0)
(3, 0, 2, 1)
(3, 1, 2, 0)
Note:
`1 <= S.length <= 200`
`S` consists only of characters from the set `{'D', 'I'}`.",0,/articles/valid-permutations-for-di-sequence,54.2,21.0,https://leetcode.com/problems/valid-permutations-for-di-sequence,50,8.2K,15.1K,,,351,30,92,0,
187,906,Super Palindromes,"Let's say a positive integer is a super-palindrome if it is a palindrome, and it is also the square of a palindrome.

Given two positive integers `left` and `right` represented as strings, return the number of super-palindromes integers in the inclusive range `[left, right]`.


Example 1:
Input: left = ""4"", right = ""1000""
Output: 4
Explanation: 4, 9, 121, and 484 are superpalindromes.

Note that 676 is not a superpalindrome: 26 * 26 = 676, but 26 is not a palindrome.


Example 2:
Input: left = ""1"", right = ""2""
Output: 1

Constraints:
`1 <= left.length, right.length <= 18`
`left` and `right` consist of only digits.

`left` and `right` cannot have leading zeros.

`left` and `right` represent integers in the range `[1, 1018]`.

`left` is less than or equal to `right`.",0,/articles/super-palindromes,32.7,6.4,https://leetcode.com/problems/super-palindromes,57,6.5K,19.8K,Google,Math,98,176,36,1,
188,913,Cat and Mouse,"A game on an undirected graph is played by two players, Mouse and Cat, who alternate turns.

The graph is given as follows: `graph[a]` is a list of all nodes `b` such that `ab` is an edge of the graph.

The mouse starts at node `1` and goes first, the cat starts at node `2` and goes second, and there is a hole at node `0`.

During each player's turn, they must travel along one edge of the graph that meets where they are.  For example, if the Mouse is at node 1, it must travel to any node in `graph[1]`.

Additionally, it is not allowed for the Cat to travel to the Hole (node 0.)
Then, the game can end in three ways:
If ever the Cat occupies the same node as the Mouse, the Cat wins.

If ever the Mouse reaches the Hole, the Mouse wins.

If ever a position is repeated (i.e., the players are in the same position as a previous turn, and it is the same player's turn to move), the game is a draw.

Given a `graph`, and assuming both players play optimally, return
`1` if the mouse wins the game,
`2` if the cat wins the game, or
`0` if the game is a draw.


Example 1:
Input: graph = [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]
Output: 0

Example 2:
Input: graph = [[1,3],[0],[3],[0,2]]
Output: 1

Constraints:
`3 <= graph.length <= 50`
`1 <= graph[i].length < graph.length`
`0 <= graph[i][j] < graph.length`
`graph[i][j] != i`
`graph[i]` is unique.

The mouse and the cat can always move.",0,/articles/cat-and-mouse-game,34.8,28.4,https://leetcode.com/problems/cat-and-mouse,92,11.5K,33.1K,Google,"Breadth-first Search,Minimax",439,88,83,1,"[Cat and Mouse II, /problems/cat-and-mouse-ii/, Hard]"
189,920,Number of Music Playlists,"Your music player contains `N` different songs and she wants to listen to `L` (not necessarily different) songs during your trip.  You create a playlist so that:
Every song is played at least once
A song can only be played again only if `K` other songs have been played
Return the number of possible playlists.  As the answer can be very large, return it modulo `10^9 + 7`.


Example 1:
Input: N = 3, L = 3, K = 1
Output: 6
Explanation: There are 6 possible playlists. [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1].


Example 2:
Input: N = 2, L = 3, K = 0
Output: 6
Explanation: There are 6 possible playlists. [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2, 1], [2, 1, 2], [1, 2, 2]

Example 3:
Input: N = 2, L = 3, K = 1
Output: 2
Explanation: There are 2 possible playlists. [1, 2, 1], [2, 1, 2]
Note:
`0 <= K < N <= L <= 100`",0,/articles/number-of-music-playlists,48.0,35.4,https://leetcode.com/problems/number-of-music-playlists,74,14.2K,29.6K,"Salesforce,Facebook",Dynamic Programming,542,56,91,1,
190,924,Minimize Malware Spread,"You are given a network of `n` nodes represented as an `n x n` adjacency matrix `graph`, where the `ith` node is directly connected to the `jth` node if `graph[i][j] == 1`.

Some nodes `initial` are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.

Suppose `M(initial)` is the final number of nodes infected with malware in the entire network after the spread of malware stops. We will remove exactly one node from `initial`.

Return the node that, if removed, would minimize `M(initial)`. If multiple nodes could be removed to minimize `M(initial)`, return such a node with the smallest index.

Note that if a node was removed from the `initial` list of infected nodes, it might still be infected later due to the malware spread.


Example 1:
Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
Output: 0

Example 2:
Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
Output: 0

Example 3:
Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
Output: 1

Constraints:
`n == graph.length`
`n == graph[i].length`
`2 <= n <= 300`
`graph[i][j]` is `0` or `1`.

`graph[i][j] == graph[j][i]`
`graph[i][i] == 1`
`1 <= initial.length <= n`
`0 <= initial[i] <= n - 1`
All the integers in `initial` are unique.",0,/articles/minimize-malware-spread,41.9,14.4,https://leetcode.com/problems/minimize-malware-spread,207,30K,71.4K,ByteDance,"Depth-first Search,Union Find",411,307,57,0,
191,927,Three Equal Parts,"You are given an array `arr` which consists of only zeros and ones, divide the array into three non-empty parts such that all of these parts represent the same binary value.

If it is possible, return any `[i, j]` with `i + 1 < j`, such that:
`arr[0], arr[1], ..., arr[i]` is the first part,
`arr[i + 1], arr[i + 2], ..., arr[j - 1]` is the second part, and
`arr[j], arr[j + 1], ..., arr[arr.length - 1]` is the third part.

All three parts have equal binary values.

If it is not possible, return `[-1, -1]`.

Note that the entire part is used when considering what binary value it represents. For example, `[1,1,0]` represents `6` in decimal, not `3`. Also, leading zeros are allowed, so `[0,1,1]` and `[1,1]` represent the same value.


Example 1:
Input: arr = [1,0,1,0,1]
Output: [0,3]

Example 2:
Input: arr = [1,1,0,1,1]
Output: [-1,-1]

Example 3:
Input: arr = [1,1,0,0,1]
Output: [0,2]

Constraints:
`3 <= arr.length <= 3 * 104`
`arr[i]` is `0` or `1`",0,/articles/three-equal-parts,34.7,5.5,https://leetcode.com/problems/three-equal-parts,131,9.2K,26.4K,"Netflix,Hotstar","Math,Binary Search,Greedy",296,63,82,1,
192,928,Minimize Malware Spread II,"You are given a network of `n` nodes represented as an `n x n` adjacency matrix `graph`, where the `ith` node is directly connected to the `jth` node if `graph[i][j] == 1`.

Some nodes `initial` are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.

Suppose `M(initial)` is the final number of nodes infected with malware in the entire network after the spread of malware stops.

We will remove exactly one node from `initial`, completely removing it and any connections from this node to any other node.

Return the node that, if removed, would minimize `M(initial)`. If multiple nodes could be removed to minimize `M(initial)`, return such a node with the smallest index.


Example 1:
Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
Output: 0

Example 2:
Input: graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]
Output: 1

Example 3:
Input: graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]
Output: 1

Constraints:
`n == graph.length`
`n == graph[i].length`
`2 <= n <= 300`
`graph[i][j]` is `0` or `1`.

`graph[i][j] == graph[j][i]`
`graph[i][i] == 1`
`1 <= initial.length < n`
`0 <= initial[i] <= n - 1`
All the integers in `initial` are unique.",0,/articles/minimize-malware-spread-ii,41.5,14.6,https://leetcode.com/problems/minimize-malware-spread-ii,107,12.2K,29.3K,Dropbox,"Depth-first Search,Union Find,Graph",278,60,82,0,
193,936,Stamping The Sequence,"You want to form a `target` string of lowercase letters.

At the beginning, your sequence is `target.length` `'?'` marks.  You also have a `stamp` of lowercase letters.

On each turn, you may place the stamp over the sequence, and replace every letter in the sequence with the corresponding letter from the stamp.  You can make up to `10 * target.length` turns.

For example, if the initial sequence is ""?????"", and your stamp is `""abc""`,  then you may make ""abc??"", ""?abc?"", ""??abc"" in the first turn.  (Note that the stamp must be fully contained in the boundaries of the sequence in order to stamp.)
If the sequence is possible to stamp, then return an array of the index of the left-most letter being stamped at each turn.  If the sequence is not possible to stamp, return an empty array.

For example, if the sequence is ""ababc"", and the stamp is `""abc""`, then we could return the answer `[0, 2]`, corresponding to the moves ""?????"" -> ""abc??"" -> ""ababc"".

Also, if the sequence is possible to stamp, it is guaranteed it is possible to stamp within `10 * target.length` moves.  Any answers specifying more than this number of moves will not be accepted.


Example 1:
Input: stamp = ""abc"", target = ""ababc""
Output: [0,2]
([1,0,2] would also be accepted as an answer, as well as some other answers.)

Example 2:
Input: stamp = ""abca"", target = ""aabcaca""
Output: [3,0,1]
Note:
`1 <= stamp.length <= target.length <= 1000`
`stamp` and `target` only contain lowercase letters.",0,/articles/stamping-the-sequence,53.4,0.5,https://leetcode.com/problems/stamping-the-sequence,105,21.8K,40.8K,Facebook,"String,Greedy",431,108,80,1,
194,940,Distinct Subsequences II,"Given a string `S`, count the number of distinct, non-empty subsequences of `S` .

Since the result may be large, return the answer modulo `10^9 + 7`.


Example 1:
Input: ""abc""
Output: 7
Explanation: The 7 distinct subsequences are ""a"", ""b"", ""c"", ""ab"", ""ac"", ""bc"", and ""abc"".


Example 2:
Input: ""aba""
Output: 6
Explanation: The 6 distinct subsequences are ""a"", ""b"", ""ab"", ""ba"", ""aa"" and ""aba"".


Example 3:
Input: ""aaa""
Output: 3
Explanation: The 3 distinct subsequences are ""a"", ""aa"" and ""aaa"".

Note:
`S` contains only lowercase letters.

`1 <= S.length <= 2000`",0,/articles/distinct-subsequences-ii,41.5,25.4,https://leetcode.com/problems/distinct-subsequences-ii,84,13.9K,33.4K,,,520,17,97,0,
195,943,Find the Shortest Superstring,"Given an array of strings `words`, return the smallest string that contains each string in `words` as a substring. If there are multiple valid strings of the smallest length, return any of them.

You may assume that no string in `words` is a substring of another string in `words`.


Example 1:
Input: words = [""alex"",""loves"",""leetcode""]
Output: ""alexlovesleetcode""
Explanation: All permutations of ""alex"",""loves"",""leetcode"" would also be accepted.


Example 2:
Input: words = [""catg"",""ctaagt"",""gcta"",""ttca"",""atgcatc""]
Output: ""gctaagttcatgcatc""

Constraints:
`1 <= words.length <= 12`
`1 <= words[i].length <= 20`
`words[i]` consists of lowercase English letters.

All the strings of `words` are unique.",0,/articles/find-the-shortest-superstring,43.4,10.3,https://leetcode.com/problems/find-the-shortest-superstring,81,12.7K,29.3K,"Amazon,Google",Dynamic Programming,515,78,87,1,
196,952,Largest Component Size by Common Factor,"Given a non-empty array of unique positive integers `A`, consider the following graph:
There are `A.length` nodes, labelled `A[0]` to `A[A.length - 1];`
There is an edge between `A[i]` and `A[j]` if and only if `A[i]` and `A[j]` share a common factor greater than 1.

Return the size of the largest connected component in the graph.


Example 1:
Input: [4,6,15,35]
Output: 4

Example 2:
Input: [20,50,9,63]
Output: 2

Example 3:
Input: [2,3,6,7,4,12,21,39]
Output: 8
Note:
`1 <= A.length <= 20000`
`1 <= A[i] <= 100000`",0,/articles/largest-component-size-by-common-factor,36.4,2.2,https://leetcode.com/problems/largest-component-size-by-common-factor,145,26.1K,71.8K,Google,"Math,Union Find",564,67,89,1,
197,956,Tallest Billboard,"You are installing a billboard and want it to have the largest height. The billboard will have two steel supports, one on each side. Each steel support must be an equal height.

You are given a collection of `rods` that can be welded together. For example, if you have rods of lengths `1`, `2`, and `3`, you can weld them together to make a support of length `6`.

Return the largest possible height of your billboard installation. If you cannot support the billboard, return `0`.


Example 1:
Input: rods = [1,2,3,6]
Output: 6
Explanation: We have two disjoint subsets {1,2,3} and {6}, which have the same sum = 6.


Example 2:
Input: rods = [1,2,3,4,5,6]
Output: 10
Explanation: We have two disjoint subsets {2,3,5} and {4,6}, which have the same sum = 10.


Example 3:
Input: rods = [1,2]
Output: 0
Explanation: The billboard cannot be supported, so we return 0.


Constraints:
`1 <= rods.length <= 20`
`1 <= rods[i] <= 1000`
`sum(rods[i]) <= 5000`",0,/articles/tallest-billboard,39.9,23.5,https://leetcode.com/problems/tallest-billboard,63,9.7K,24.4K,,,441,18,96,0,
198,960,Delete Columns to Make Sorted III,"You are given an array of `n` strings `strs`, all of the same length.

We may choose any deletion indices, and we delete all the characters in those indices for each string.

For example, if we have `strs = [""abcdef"",""uvwxyz""]` and deletion indices `{0, 2, 3}`, then the final array after deletions is `[""bef"", ""vyz""]`.

Suppose we chose a set of deletion indices `answer` such that after deletions, the final array has every string (row) in lexicographic order. (i.e., `(strs[0][0] <= strs[0][1] <= ... <= strs[0][strs[0].length - 1])`, and `(strs[1][0] <= strs[1][1] <= ... <= strs[1][strs[1].length - 1])`, and so on). Return the minimum possible value of `answer.length`.


Example 1:
Input: strs = [""babca"",""bbazb""]
Output: 3
Explanation: After deleting columns 0, 1, and 4, the final array is strs = [""bc"", ""az""].

Both these rows are individually in lexicographic order (ie. strs[0][0] <= strs[0][1] and strs[1][0] <= strs[1][1]).

Note that strs[0] > strs[1] - the array strs is not necessarily in lexicographic order.


Example 2:
Input: strs = [""edcba""]
Output: 4
Explanation: If we delete less than 4 columns, the only row will not be lexicographically sorted.


Example 3:
Input: strs = [""ghi"",""def"",""abc""]
Output: 0
Explanation: All rows are already lexicographically sorted.


Constraints:
`n == strs.length`
`1 <= n <= 100`
`1 <= strs[i].length <= 100`
`strs[i]` consists of lowercase English letters.",0,/articles/delete-columns-to-make-sorted-iii,55.1,7.0,https://leetcode.com/problems/delete-columns-to-make-sorted-iii,62,8.1K,14.8K,Google,Dynamic Programming,301,9,97,1,
199,964,Least Operators to Express Number,"Given a single positive integer `x`, we will write an expression of the form `x (op1) x (op2) x (op3) x ...` where each operator `op1`, `op2`, etc. is either addition, subtraction, multiplication, or division (`+`, `-`, `*`, or `/)`. For example, with `x = 3`, we might write `3 * 3 / 3 + 3 - 3` which is a value of 3.

When writing such an expression, we adhere to the following conventions:
The division operator (`/`) returns rational numbers.

There are no parentheses placed anywhere.

We use the usual order of operations: multiplication and division happen before addition and subtraction.

It is not allowed to use the unary negation operator (`-`). For example, ""`x - x`"" is a valid expression as it only uses subtraction, but ""`-x + x`"" is not because it uses negation.

We would like to write an expression with the least number of operators such that the expression equals the given `target`. Return the least number of operators used.


Example 1:
Input: x = 3, target = 19
Output: 5
Explanation: 3 * 3 + 3 * 3 + 3 / 3.

The expression contains 5 operations.


Example 2:
Input: x = 5, target = 501
Output: 8
Explanation: 5 * 5 * 5 * 5 - 5 * 5 * 5 + 5 / 5.

The expression contains 8 operations.


Example 3:
Input: x = 100, target = 100000000
Output: 3
Explanation: 100 * 100 * 100 * 100.

The expression contains 3 operations.


Constraints:
`2 <= x <= 100`
`1 <= target <= 2 * 108`",0,/articles/least-operators-to-express-number,45.2,11.4,https://leetcode.com/problems/least-operators-to-express-number,42,6.3K,13.9K,Snapchat,"Math,Dynamic Programming",207,54,79,0,
200,968,Binary Tree Cameras,"Given a binary tree, we install cameras on the nodes of the tree. 
Each camera at a node can monitor its parent, itself, and its immediate children.

Calculate the minimum number of cameras needed to monitor all nodes of the tree.


Example 1:
Input: [0,0,null,0,0]
Output: 1
Explanation: One camera is enough to monitor all nodes if placed as shown.


Example 2:
Input: [0,0,null,0,null,0,null,null,0]
Output: 2
Explanation: At least two cameras are needed to monitor all nodes of the tree. The above image shows one of the valid configurations of camera placement.

Note:
The number of nodes in the given tree will be in the range `[1, 1000]`.

Every node has value 0.",0,/articles/binary-tree-cameras,38.9,30.8,https://leetcode.com/problems/binary-tree-cameras,219,31.2K,80.1K,"Google,Microsoft,Bloomberg,Flipkart","Dynamic Programming,Tree,Depth-first Search",1244,19,98,1,"[Distribute Coins in Binary Tree, /problems/distribute-coins-in-binary-tree/, Medium]"
201,972,Equal Rational Numbers,"Given two strings `s` and `t`, each of which represents a non-negative rational number, return `true` if and only if they represent the same number. The strings may use parentheses to denote the repeating part of the rational number.

A rational number can be represented using up to three parts: `<IntegerPart>`, `<NonRepeatingPart>`, and a `<RepeatingPart>`. The number will be represented in one of the following three ways:
`<IntegerPart>`
	
For example, `12`, `0`, and `123`.

`<IntegerPart><.><NonRepeatingPart>`
	
For example, `0.5`, `1.`, `2.12`, and `123.0001`.

`<IntegerPart><.><NonRepeatingPart><(><RepeatingPart><)>`
	
For example, `0.1(6)`, `1.(9)`, `123.00(1212)`.

The repeating portion of a decimal expansion is conventionally denoted within a pair of round brackets. For example:
`1/6 = 0.16666666... = 0.1(6) = 0.1666(6) = 0.166(66)`.


Example 1:
Input: s = ""0.(52)"", t = ""0.5(25)""
Output: true
Explanation: Because ""0.(52)"" represents 0.52525252..., and ""0.5(25)"" represents 0.52525252525..... , the strings represent the same number.


Example 2:
Input: s = ""0.1666(6)"", t = ""0.166(66)""
Output: true

Example 3:
Input: s = ""0.9(9)"", t = ""1.""
Output: true
Explanation: ""0.9(9)"" represents 0.999999999... repeated forever, which equals 1.  [See this link for an explanation.]
""1."" represents the number 1, which is formed correctly: (IntegerPart) = ""1"" and (NonRepeatingPart) = """".


Constraints:
Each part consists only of digits.

The `<IntegerPart>` does not have leading zeros (except for the zero itself).

`1 <= <IntegerPart>.length <= 4`
`0 <= <NonRepeatingPart>.length <= 4`
`1 <= <RepeatingPart>.length <= 4`",0,/articles/equal-rational-numbers,42.1,0.0,https://leetcode.com/problems/equal-rational-numbers,60,4.6K,10.8K,Microsoft,Math,54,160,25,0,
202,975,Odd Even Jump,"You are given an integer array `arr`. From some starting index, you can make a series of jumps. The (1st, 3rd, 5th, ...) jumps in the series are called odd-numbered jumps, and the (2nd, 4th, 6th, ...) jumps in the series are called even-numbered jumps. Note that the jumps are numbered, not the indices.

You may jump forward from index `i` to index `j` (with `i < j`) in the following way:
During odd-numbered jumps (i.e., jumps 1, 3, 5, ...), you jump to the index `j` such that `arr[i] <= arr[j]` and `arr[j]` is the smallest possible value. If there are multiple such indices `j`, you can only jump to the smallest such index `j`.

During even-numbered jumps (i.e., jumps 2, 4, 6, ...), you jump to the index `j` such that `arr[i] >= arr[j]` and `arr[j]` is the largest possible value. If there are multiple such indices `j`, you can only jump to the smallest such index `j`.

It may be the case that for some index `i`, there are no legal jumps.

A starting index is good if, starting from that index, you can reach the end of the array (index `arr.length - 1`) by jumping some number of times (possibly 0 or more than once).

Return the number of good starting indices.


Example 1:
Input: arr = [10,13,12,14,15]
Output: 2
Explanation: 
From starting index i = 0, we can make our 1st jump to i = 2 (since arr[2] is the smallest among arr[1], arr[2], arr[3], arr[4] that is greater or equal to arr[0]), then we cannot jump any more.

From starting index i = 1 and i = 2, we can make our 1st jump to i = 3, then we cannot jump any more.

From starting index i = 3, we can make our 1st jump to i = 4, so we have reached the end.

From starting index i = 4, we have reached the end already.

In total, there are 2 different starting indices i = 3 and i = 4, where we can reach the end with some number of
jumps.


Example 2:
Input: arr = [2,3,1,1,4]
Output: 3
Explanation: 
From starting index i = 0, we make jumps to i = 1, i = 2, i = 3:
During our 1st jump (odd-numbered), we first jump to i = 1 because arr[1] is the smallest value in [arr[1], arr[2], arr[3], arr[4]] that is greater than or equal to arr[0].

During our 2nd jump (even-numbered), we jump from i = 1 to i = 2 because arr[2] is the largest value in [arr[2], arr[3], arr[4]] that is less than or equal to arr[1]. arr[3] is also the largest value, but 2 is a smaller index, so we can only jump to i = 2 and not i = 3
During our 3rd jump (odd-numbered), we jump from i = 2 to i = 3 because arr[3] is the smallest value in [arr[3], arr[4]] that is greater than or equal to arr[2].

We can't jump from i = 3 to i = 4, so the starting index i = 0 is not good.

In a similar manner, we can deduce that:
From starting index i = 1, we jump to i = 4, so we reach the end.

From starting index i = 2, we jump to i = 3, and then we can't jump anymore.

From starting index i = 3, we jump to i = 4, so we reach the end.

From starting index i = 4, we are already at the end.

In total, there are 3 different starting indices i = 1, i = 3, and i = 4, where we can reach the end with some
number of jumps.


Example 3:
Input: arr = [5,1,3,4,2]
Output: 3
Explanation: We can reach the end from starting indices 1, 2, and 4.


Constraints:
`1 <= arr.length <= 2 * 104`
`0 <= arr[i] < 105`",0,/articles/odd-even-jump,41.5,7.1,https://leetcode.com/problems/odd-even-jump,220,40.2K,97K,Google,"Dynamic Programming,Stack,Ordered Map",916,283,76,1,
203,980,Unique Paths III,"On a 2-dimensional `grid`, there are 4 types of squares:
`1` represents the starting square.  There is exactly one starting square.

`2` represents the ending square.  There is exactly one ending square.

`0` represents empty squares we can walk over.

`-1` represents obstacles that we cannot walk over.

Return the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once.


Example 1:
Input: [[1,0,0,0],[0,0,0,0],[0,0,2,-1]]
Output: 2
Explanation: We have the following two paths: 
1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)
2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)

Example 2:
Input: [[1,0,0,0],[0,0,0,0],[0,0,0,2]]
Output: 4
Explanation: We have the following four paths: 
1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)
2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)
3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)
4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)

Example 3:
Input: [[0,1],[2,0]]
Output: 0
Explanation: 
There is no path that walks over every empty square exactly once.

Note that the starting and ending square can be anywhere in the grid.

Note:
`1 <= grid.length * grid[0].length <= 20`",0,/articles/unique-paths-iii,77.0,26.6,https://leetcode.com/problems/unique-paths-iii,695,68.6K,89K,"Amazon,JPMorgan","Backtracking,Depth-first Search",1376,90,94,1,"[Sudoku Solver, /problems/sudoku-solver/, Hard], [Unique Paths II, /problems/unique-paths-ii/, Medium], [Word Search II, /problems/word-search-ii/, Hard]"
204,982,Triples with Bitwise AND Equal To Zero,"Given an array of integers `A`, find the number of triples of indices (i, j, k) such that:
`0 <= i < A.length`
`0 <= j < A.length`
`0 <= k < A.length`
`A[i] & A[j] & A[k] == 0`, where `&` represents the bitwise-AND operator.


Example 1:
Input: [2,1,3]
Output: 12
Explanation: We could choose the following i, j, k triples:
(i=0, j=0, k=1) : 2 & 2 & 1
(i=0, j=1, k=0) : 2 & 1 & 2
(i=0, j=1, k=1) : 2 & 1 & 1
(i=0, j=1, k=2) : 2 & 1 & 3
(i=0, j=2, k=1) : 2 & 3 & 1
(i=1, j=0, k=0) : 1 & 2 & 2
(i=1, j=0, k=1) : 1 & 2 & 1
(i=1, j=0, k=2) : 1 & 2 & 3
(i=1, j=1, k=0) : 1 & 1 & 2
(i=1, j=2, k=0) : 1 & 3 & 2
(i=2, j=0, k=1) : 3 & 2 & 1
(i=2, j=1, k=0) : 3 & 1 & 2
Note:
`1 <= A.length <= 1000`
`0 <= A[i] < 2^16`",0,,56.3,0.0,https://leetcode.com/problems/triples-with-bitwise-and-equal-to-zero,79,9.8K,17.3K,Flipkart,Dynamic Programming,148,156,49,0,
205,987,Vertical Order Traversal of a Binary Tree,"Given the `root` of a binary tree, calculate the vertical order traversal of the binary tree.

For each node at position `(row, col)`, its left and right children will be at positions `(row + 1, col - 1)` and `(row + 1, col + 1)` respectively. The root of the tree is at `(0, 0)`.

The vertical order traversal of a binary tree is a list of top-to-bottom orderings for each column index starting from the leftmost column and ending on the rightmost column. There may be multiple nodes in the same row and same column. In such a case, sort these nodes by their values.

Return the vertical order traversal of the binary tree.


Example 1:
Input: root = [3,9,20,null,null,15,7]
Output: [[9],[3,15],[20],[7]]
Explanation:
Column -1: Only node 9 is in this column.

Column 0: Nodes 3 and 15 are in this column in that order from top to bottom.

Column 1: Only node 20 is in this column.

Column 2: Only node 7 is in this column.


Example 2:
Input: root = [1,2,3,4,5,6,7]
Output: [[4],[2],[1,5,6],[3],[7]]
Explanation:
Column -2: Only node 4 is in this column.

Column -1: Only node 2 is in this column.

Column 0: Nodes 1, 5, and 6 are in this column.

          1 is at the top, so it comes first.

          5 and 6 are at the same position (2, 0), so we order them by their value, 5 before 6.

Column 1: Only node 3 is in this column.

Column 2: Only node 7 is in this column.


Example 3:
Input: root = [1,2,3,4,6,5,7]
Output: [[4],[2],[1,5,6],[3],[7]]
Explanation:
This case is the exact same as example 2, but with nodes 5 and 6 swapped.

Note that the solution remains the same since 5 and 6 are in the same location and should be ordered by their values.


Constraints:
The number of nodes in the tree is in the range `[1, 1000]`.

`0 <= Node.val <= 1000`",0,/articles/vertical-order-traversal-of-a-binary-tree,39.0,65.8,https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree,999,135.6K,347.6K,"Facebook,Bloomberg,Amazon,Microsoft,Apple,ByteDance","Hash Table,Tree,Depth-first Search,Breadth-first Search",1406,2382,37,1,
206,992,Subarrays with K Different Integers,"Given an array `A` of positive integers, call a (contiguous, not necessarily distinct) subarray of `A` good if the number of different integers in that subarray is exactly `K`.

(For example, `[1,2,3,1,2]` has `3` different integers: `1`, `2`, and `3`.)
Return the number of good subarrays of `A`.


Example 1:
Input: A = [1,2,1,2,3], K = 2
Output: 7
Explanation: Subarrays formed with exactly 2 different integers: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].


Example 2:
Input: A = [1,2,1,3,4], K = 3
Output: 3
Explanation: Subarrays formed with exactly 3 different integers: [1,2,1,3], [2,1,3], [1,3,4].

Note:
`1 <= A.length <= 20000`
`1 <= A[i] <= A.length`
`1 <= K <= A.length`",0,/articles/subarrays-with-k-different-integers,50.9,38.8,https://leetcode.com/problems/subarrays-with-k-different-integers,227,42.8K,84.1K,"Amazon,Google","Hash Table,Two Pointers,Sliding Window",1663,28,98,1,"[Longest Substring Without Repeating Characters, /problems/longest-substring-without-repeating-characters/, Medium], [Longest Substring with At Most Two Distinct Characters, /problems/longest-substring-with-at-most-two-distinct-characters/, Medium], [Longest Substring with At Most K Distinct Characters, /problems/longest-substring-with-at-most-k-distinct-characters/, Medium]"
207,995,Minimum Number of K Consecutive Bit Flips,"In an array `A` containing only 0s and 1s, a `K`-bit flip consists of choosing a (contiguous) subarray of length `K` and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0.

Return the minimum number of `K`-bit flips required so that there is no 0 in the array.  If it is not possible, return `-1`.


Example 1:
Input: A = [0,1,0], K = 1
Output: 2
Explanation: Flip A[0], then flip A[2].


Example 2:
Input: A = [1,1,0], K = 2
Output: -1
Explanation: No matter how we flip subarrays of size 2, we can't make the array become [1,1,1].


Example 3:
Input: A = [0,0,0,1,0,1,1,0], K = 3
Output: 3
Explanation:
Flip A[0],A[1],A[2]: A becomes [1,1,1,1,0,1,1,0]
Flip A[4],A[5],A[6]: A becomes [1,1,1,1,1,0,0,0]
Flip A[5],A[6],A[7]: A becomes [1,1,1,1,1,1,1,1]
Note:
`1 <= A.length <= 30000`
`1 <= K <= A.length`",0,/articles/minimum-number-of-k-consecutive-bit-flips,50.0,15.0,https://leetcode.com/problems/minimum-number-of-k-consecutive-bit-flips,111,19.4K,38.8K,"Google,Amazon","Greedy,Sliding Window",517,42,92,1,"[Bulb Switcher, /problems/bulb-switcher/, Medium]"
208,996,Number of Squareful Arrays,"Given an array `A` of non-negative integers, the array is squareful if for every pair of adjacent elements, their sum is a perfect square.

Return the number of permutations of A that are squareful.  Two permutations `A1` and `A2` differ if and only if there is some index `i` such that `A1[i] != A2[i]`.


Example 1:
Input: [1,17,8]
Output: 2
Explanation: 
[1,8,17] and [17,8,1] are the valid permutations.


Example 2:
Input: [2,2,2]
Output: 1
Note:
`1 <= A.length <= 12`
`0 <= A[i] <= 1e9`",0,/articles/number-of-squareful-arrays,48.6,12.2,https://leetcode.com/problems/number-of-squareful-arrays,208,18.6K,38.3K,"Apple,Codenation","Math,Backtracking,Graph",465,23,95,1,"[Permutations II, /problems/permutations-ii/, Medium]"
209,1000,Minimum Cost to Merge Stones,"There are `N` piles of stones arranged in a row.  The `i`-th pile has `stones[i]` stones.

A move consists of merging exactly `K` consecutive piles into one pile, and the cost of this move is equal to the total number of stones in these `K` piles.

Find the minimum cost to merge all piles of stones into one pile.  If it is impossible, return `-1`.


Example 1:
Input: stones = [3,2,4,1], K = 2
Output: 20
Explanation: 
We start with [3, 2, 4, 1].

We merge [3, 2] for a cost of 5, and we are left with [5, 4, 1].

We merge [4, 1] for a cost of 5, and we are left with [5, 5].

We merge [5, 5] for a cost of 10, and we are left with [10].

The total cost was 20, and this is the minimum possible.


Example 2:
Input: stones = [3,2,4,1], K = 3
Output: -1
Explanation: After any merge operation, there are 2 piles left, and we can't merge anymore.  So the task is impossible.


Example 3:
Input: stones = [3,5,1,2,6], K = 3
Output: 25
Explanation: 
We start with [3, 5, 1, 2, 6].

We merge [5, 1, 2] for a cost of 8, and we are left with [3, 8, 6].

We merge [3, 8, 6] for a cost of 17, and we are left with [17].

The total cost was 25, and this is the minimum possible.

Note:
`1 <= stones.length <= 30`
`2 <= K <= 30`
`1 <= stones[i] <= 100`",0,,40.5,20.6,https://leetcode.com/problems/minimum-cost-to-merge-stones,112,19.6K,48.4K,Amazon,Dynamic Programming,903,58,94,1,"[Burst Balloons, /problems/burst-balloons/, Hard], [Minimum Cost to Connect Sticks, /problems/minimum-cost-to-connect-sticks/, Medium]"
210,1001,Grid Illumination,"You are given a `grid` of size `N x N`, and each cell of this grid has a lamp that is initially turned off.

You are also given an array of lamp positions `lamps`, where `lamps[i] = [rowi, coli]` indicates that the lamp at `grid[rowi][coli]` is turned on. When a lamp is turned on, it illuminates its cell and all other cells in the same row, column, or diagonal.

Finally, you are given a query array `queries`, where `queries[i] = [rowi, coli]`. For the `ith` query, determine whether `grid[rowi][coli]` is illuminated or not. After answering the `ith` query, turn off the lamp at `grid[rowi][coli]` and its 8 adjacent lamps if they exist. A lamp is adjacent if its cell shares either a side or corner with `grid[rowi][coli]`.

Return an array of integers `ans`, where `ans[i]` should be `1` if the lamp in the `ith` query was illuminated, or `0` if the lamp was not.


Example 1:
Input: N = 5, lamps = [[0,0],[4,4]], queries = [[1,1],[1,0]]
Output: [1,0]
Explanation: We have the initial grid with all lamps turned off. In the above picture we see the grid after turning on the lamp at grid[0][0] then turning on the lamp at grid[4][4].

The 0th query asks if the lamp at grid[1][1] is illuminated or not (the blue square). It is illuminated, so set ans[0] = 1. Then, we turn off all lamps in the red square.

The 1st query asks if the lamp at grid[1][0] is illuminated or not (the blue square). It is not illuminated, so set ans[1] = 0. Then, we turn off all lamps in the red rectangle.


Example 2:
Input: N = 5, lamps = [[0,0],[4,4]], queries = [[1,1],[1,1]]
Output: [1,1]

Example 3:
Input: N = 5, lamps = [[0,0],[0,4]], queries = [[0,4],[0,1],[1,4]]
Output: [1,1,0]

Constraints:
`1 <= N <= 109`
`0 <= lamps.length <= 20000`
`lamps[i].length == 2`
`0 <= lamps[i][j] < N`
`0 <= queries.length <= 20000`
`queries[i].length == 2`
`0 <= queries[i][j] < N`",0,,36.0,32.9,https://leetcode.com/problems/grid-illumination,138,11.4K,31.5K,Dropbox,Hash Table,256,76,77,0,"[N-Queens, /problems/n-queens/, Hard]"
211,1012,Numbers With Repeated Digits,"Given a positive integer `N`, return the number of positive integers less than or equal to `N` that have at least 1 repeated digit.


Example 1:
Input: 20
Output: 1
Explanation: The only positive number (<= 20) with at least 1 repeated digit is 11.


Example 2:
Input: 100
Output: 10
Explanation: The positive numbers (<= 100) with atleast 1 repeated digit are 11, 22, 33, 44, 55, 66, 77, 88, 99, and 100.


Example 3:
Input: 1000
Output: 262
Note:
`1 <= N <= 10^9`",0,,37.8,21.3,https://leetcode.com/problems/numbers-with-repeated-digits,79,7K,18.5K,"Akuna Capital,IBM","Math,Dynamic Programming",281,52,84,0,
212,1028,Recover a Tree From Preorder Traversal,"We run a preorder depth-first search (DFS) on the `root` of a binary tree.

At each node in this traversal, we output `D` dashes (where `D` is the depth of this node), then we output the value of this node.  If the depth of a node is `D`, the depth of its immediate child is `D + 1`.  The depth of the `root` node is `0`.

If a node has only one child, that child is guaranteed to be the left child.

Given the output `S` of this traversal, recover the tree and return its `root`.


Example 1:
Input: S = ""1-2--3--4-5--6--7""
Output: [1,2,5,3,4,6,7]

Example 2:
Input: S = ""1-2--3---4-5--6---7""
Output: [1,2,5,3,null,6,null,4,null,7]

Example 3:
Input: S = ""1-401--349---90--88""
Output: [1,401,null,349,88,90]

Constraints:
The number of nodes in the original tree is in the range `[1, 1000]`.

`1 <= Node.val <= 109`",0,,71.0,13.1,https://leetcode.com/problems/recover-a-tree-from-preorder-traversal,402,25.4K,35.8K,"Amazon,LinkedIn","Tree,Depth-first Search",633,22,97,1,
213,1032,Stream of Characters,"Implement the `StreamChecker` class as follows:
`StreamChecker(words)`: Constructor, init the data structure with the given words.

`query(letter)`: returns true if and only if for some `k >= 1`, the last `k` characters queried (in order from oldest to newest, including this letter just queried) spell one of the words in the given list.


Example:
StreamChecker streamChecker = new StreamChecker([""cd"",""f"",""kl""]); // init the dictionary.

streamChecker.query('a');          // return false
streamChecker.query('b');          // return false
streamChecker.query('c');          // return false
streamChecker.query('d');          // return true, because 'cd' is in the wordlist
streamChecker.query('e');          // return false
streamChecker.query('f');          // return true, because 'f' is in the wordlist
streamChecker.query('g');          // return false
streamChecker.query('h');          // return false
streamChecker.query('i');          // return false
streamChecker.query('j');          // return false
streamChecker.query('k');          // return false
streamChecker.query('l');          // return true, because 'kl' is in the wordlist
Note:
`1 <= words.length <= 2000`
`1 <= words[i].length <= 2000`
Words will only consist of lowercase English letters.

Queries will only consist of lowercase English letters.

The number of queries is at most 40000.",0,/articles/stream-of-characters,48.6,16.3,https://leetcode.com/problems/stream-of-characters,381,46K,94.6K,Facebook,Trie,782,115,87,1,
214,1036,Escape a Large Maze,"There is a 1 million by 1 million grid on an XY-plane, and the coordinates of each grid square are `(x, y)`.

We start at the `source = [sx, sy]` square and want to reach the `target = [tx, ty]` square. There is also an array of `blocked` squares, where each `blocked[i] = [xi, yi]` represents a blocked square with coordinates `(xi, yi)`.

Each move, we can walk one square north, east, south, or west if the square is not in the array of `blocked` squares. We are also not allowed to walk outside of the grid.

Return `true` if and only if it is possible to reach the `target` square from the `source` square through a sequence of valid moves.


Example 1:
Input: blocked = [[0,1],[1,0]], source = [0,0], target = [0,2]
Output: false
Explanation: The target square is inaccessible starting from the source square because we cannot move.

We cannot move north or east because those squares are blocked.

We cannot move south or west because we cannot go outside of the grid.


Example 2:
Input: blocked = [], source = [0,0], target = [999999,999999]
Output: true
Explanation: Because there are no blocked cells, it is possible to reach the target square.


Constraints:
`0 <= blocked.length <= 200`
`blocked[i].length == 2`
`0 <= xi, yi < 106`
`source.length == target.length == 2`
`0 <= sx, sy, tx, ty < 106`
`source != target`
It is guaranteed that `source` and `target` are not blocked.",0,,34.3,21.9,https://leetcode.com/problems/escape-a-large-maze,89,12K,35.1K,"Uber,Google,Facebook,UiPath",Breadth-first Search,291,117,71,1,
215,1044,Longest Duplicate Substring,"Given a string `s`, consider all duplicated substrings: (contiguous) substrings of s that occur 2 or more times. The occurrences may overlap.

Return any duplicated substring that has the longest possible length. If `s` does not have a duplicated substring, the answer is `""""`.


Example 1:
Input: s = ""banana""
Output: ""ana""

Example 2:
Input: s = ""abcd""
Output: """"

Constraints:
`2 <= s.length <= 3 * 104`
`s` consists of lowercase English letters.",0,/articles/longest-duplicate-substring,31.4,13.5,https://leetcode.com/problems/longest-duplicate-substring,191,33.8K,107.7K,Amazon,"Hash Table,Binary Search,Suffix Array",802,248,76,1,
216,1063,Number of Valid Subarrays,"Given an array `A` of integers, return the number of non-empty continuous subarrays that satisfy the following condition:
The leftmost element of the subarray is not larger than other elements in the subarray.


Example 1:
Input: [1,4,2,5,3]
Output: 11
Explanation: There are 11 valid subarrays: [1],[4],[2],[5],[3],[1,4],[2,5],[1,4,2],[2,5,3],[1,4,2,5],[1,4,2,5,3].


Example 2:
Input: [3,2,1]
Output: 3
Explanation: The 3 valid subarrays are: [3],[2],[1].


Example 3:
Input: [2,2,2]
Output: 6
Explanation: There are 6 valid subarrays: [2],[2],[2],[2,2],[2,2],[2,2,2].

Note:
`1 <= A.length <= 50000`
`0 <= A[i] <= 100000`",1,,72.1,8.8,https://leetcode.com/problems/number-of-valid-subarrays,83,4.7K,6.5K,Hulu,Stack,126,8,94,0,
217,1067,Digit Count in Range,"Given an integer `d` between `0` and `9`, and two positive integers `low` and `high` as lower and upper bounds, respectively. Return the number of times that `d` occurs as a digit in all integers between `low` and `high`, including the bounds `low` and `high`.


Example 1:
Input: d = 1, low = 1, high = 13
Output: 6
Explanation: 
The digit `d=1` occurs `6` times in `1,10,11,12,13`. Note that the digit `d=1` occurs twice in the number `11`.


Example 2:
Input: d = 3, low = 100, high = 250
Output: 35
Explanation: 
The digit `d=3` occurs `35` times in `103,113,123,130,131,...,238,239,243`.

Note:
`0 <= d <= 9`
`1 <= low <= high <= 2×10^8`",1,,41.6,0.0,https://leetcode.com/problems/digit-count-in-range,32,2.2K,5.2K,"eBay,Amazon","Math,Dynamic Programming",48,13,79,1,"[Number of Digit One, /problems/number-of-digit-one/, Hard]"
218,1074,Number of Submatrices That Sum to Target,"Given a `matrix` and a `target`, return the number of non-empty submatrices that sum to target.

A submatrix `x1, y1, x2, y2` is the set of all cells `matrix[x][y]` with `x1 <= x <= x2` and `y1 <= y <= y2`.

Two submatrices `(x1, y1, x2, y2)` and `(x1', y1', x2', y2')` are different if they have some coordinate that is different: for example, if `x1 != x1'`.


Example 1:
Input: matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0
Output: 4
Explanation: The four 1x1 submatrices that only contain 0.


Example 2:
Input: matrix = [[1,-1],[-1,1]], target = 0
Output: 5
Explanation: The two 1x2 submatrices, plus the two 2x1 submatrices, plus the 2x2 submatrix.


Example 3:
Input: matrix = [[904]], target = 0
Output: 0

Constraints:
`1 <= matrix.length <= 100`
`1 <= matrix[0].length <= 100`
`-1000 <= matrix[i] <= 1000`
`-10^8 <= target <= 10^8`",0,/articles/number-of-submatrices-that-sum-to-target,62.0,27.3,https://leetcode.com/problems/number-of-submatrices-that-sum-to-target,134,25K,40.3K,Google,"Array,Dynamic Programming,Sliding Window",820,31,96,1,
219,1088,Confusing Number II,"We can rotate digits by 180 degrees to form new digits. When 0, 1, 6, 8, 9 are rotated 180 degrees, they become 0, 1, 9, 8, 6 respectively. When 2, 3, 4, 5 and 7 are rotated 180 degrees, they become invalid.

A confusing number is a number that when rotated 180 degrees becomes a different number with each digit valid.(Note that the rotated number can be greater than the original number.)
Given a positive integer `N`, return the number of confusing numbers between `1` and `N` inclusive.


Example 1:
Input: 20
Output: 6
Explanation: 
The confusing numbers are [6,9,10,16,18,19].

6 converts to 9.

9 converts to 6.

10 converts to 01 which is just 1.

16 converts to 91.

18 converts to 81.

19 converts to 61.


Example 2:
Input: 100
Output: 19
Explanation: 
The confusing numbers are [6,9,10,16,18,19,60,61,66,68,80,81,86,89,90,91,98,99,100].

Note:
`1 <= N <= 10^9`",1,,45.6,20.3,https://leetcode.com/problems/confusing-number-ii,127,21K,46K,Google,"Math,Backtracking",252,72,78,1,"[Confusing Number, /problems/confusing-number/, Easy]"
220,1092,Shortest Common Supersequence,"Given two strings `str1` and `str2`, return the shortest string that has both `str1` and `str2` as subsequences.  If multiple answers exist, you may return any of them.

(A string S is a subsequence of string T if deleting some number of characters from T (possibly 0, and the characters are chosen anywhere from T) results in the string S.)

Example 1:
Input: str1 = ""abac"", str2 = ""cab""
Output: ""cabac""
Explanation: 
str1 = ""abac"" is a subsequence of ""cabac"" because we can delete the first ""c"".

str2 = ""cab"" is a subsequence of ""cabac"" because we can delete the last ""ac"".

The answer provided is the shortest such string that satisfies these properties.

Note:
`1 <= str1.length, str2.length <= 1000`
`str1` and `str2` consist of lowercase English letters.",0,,53.2,22.4,https://leetcode.com/problems/shortest-common-supersequence,311,22.2K,41.7K,"Microsoft,Amazon",Dynamic Programming,941,25,97,1,"[Longest Common Subsequence, /problems/longest-common-subsequence/, Medium]"
221,1095,Find in Mountain Array,"(This problem is an interactive problem.)
You may recall that an array `A` is a mountain array if and only if:
`A.length >= 3`
There exists some `i` with `0 < i < A.length - 1` such that:
	
`A[0] < A[1] < ... A[i-1] < A[i]`
`A[i] > A[i+1] > ... > A[A.length - 1]`
Given a mountain array `mountainArr`, return the minimum `index` such that `mountainArr.get(index) == target`.  If such an `index` doesn't exist, return `-1`.

You can't access the mountain array directly.  You may only access the array using a `MountainArray` interface:
`MountainArray.get(k)` returns the element of the array at index `k` (0-indexed).

`MountainArray.length()` returns the length of the array.

Submissions making more than `100` calls to `MountainArray.get` will be judged Wrong Answer.  Also, any solutions that attempt to circumvent the judge will result in disqualification.


Example 1:
Input: array = [1,2,3,4,5,3,1], target = 3
Output: 2
Explanation: 3 exists in the array, at index=2 and index=5. Return the minimum index, which is 2.


Example 2:
Input: array = [0,1,2,4,2,1], target = 3
Output: -1
Explanation: 3 does not exist in `the array,` so we return -1.


Constraints:
`3 <= mountain_arr.length() <= 10000`
`0 <= target <= 10^9`
`0 <= mountain_arr.get(index) <= 10^9`",0,,36.1,34.4,https://leetcode.com/problems/find-in-mountain-array,301,25.5K,70.8K,"Apple,Bloomberg,Quora",Binary Search,491,38,93,1,"[Peak Index in a Mountain Array, /problems/peak-index-in-a-mountain-array/, Easy], [Minimum Number of Removals to Make Mountain Array, /problems/minimum-number-of-removals-to-make-mountain-array/, Hard]"
222,1096,Brace Expansion II,"Under a grammar given below, strings can represent a set of lowercase words.  Let's use `R(expr)` to denote the set of words the expression represents.

Grammar can best be understood through simple examples:
Single letters represent a singleton set containing that word.

	
`R(""a"") = {""a""}`
`R(""w"") = {""w""}`
When we take a comma delimited list of 2 or more expressions, we take the union of possibilities.

	
`R(""{a,b,c}"") = {""a"",""b"",""c""}`
`R(""{{a,b},{b,c}}"") = {""a"",""b"",""c""}` (notice the final set only contains each word at most once)
When we concatenate two expressions, we take the set of possible concatenations between two words where the first word comes from the first expression and the second word comes from the second expression.

	
`R(""{a,b}{c,d}"") = {""ac"",""ad"",""bc"",""bd""}`
`R(""a{b,c}{d,e}f{g,h}"") = {""abdfg"", ""abdfh"", ""abefg"", ""abefh"", ""acdfg"", ""acdfh"", ""acefg"", ""acefh""}`
Formally, the 3 rules for our grammar:
For every lowercase letter `x`, we have `R(x) = {x}`
For expressions `e_1, e_2, ... , e_k` with `k >= 2`, we have `R({e_1,e_2,...}) = R(e_1) ∪ R(e_2) ∪ ...`
For expressions `e_1` and `e_2`, we have `R(e_1 + e_2) = {a + b for (a, b) in R(e_1) × R(e_2)}`, where + denotes concatenation, and × denotes the cartesian product.

Given an `expression` representing a set of words under the given grammar, return the sorted list of words that the expression represents.


Example 1:
Input: ""{a,b}{c,{d,e}}""
Output: [""ac"",""ad"",""ae"",""bc"",""bd"",""be""]

Example 2:
Input: ""{{a,z},a{b,c},{ab,z}}""
Output: [""a"",""ab"",""ac"",""z""]
Explanation: Each distinct word is written only once in the final answer.


Constraints:
`1 <= expression.length <= 60`
`expression[i]` consists of `'{'`, `'}'`, `','`or lowercase English letters.

The given `expression` represents a set of words based on the grammar given in the description.",0,,62.6,11.2,https://leetcode.com/problems/brace-expansion-ii,173,13.4K,21.3K,"Google,Adobe",String,258,161,62,1,"[Brace Expansion, /problems/brace-expansion/, Medium]"
223,1097,Game Play Analysis V,SQL Schema,1,,56.8,2.5,https://leetcode.com/problems/game-play-analysis-v,201,8.3K,14.6K,GSN Games,,71,21,77,0,
224,1106,Parsing A Boolean Expression,"Return the result of evaluating a given boolean `expression`, represented as a string.

An expression can either be:
`""t""`, evaluating to `True`;
`""f""`, evaluating to `False`;
`""!(expr)""`, evaluating to the logical NOT of the inner expression `expr`;
`""&(expr1,expr2,...)""`, evaluating to the logical AND of 2 or more inner expressions `expr1, expr2, ...`;
`""|(expr1,expr2,...)""`, evaluating to the logical OR of 2 or more inner expressions `expr1, expr2, ...`

Example 1:
Input: expression = ""!(f)""
Output: true

Example 2:
Input: expression = ""|(f,t)""
Output: true

Example 3:
Input: expression = ""&(t,f)""
Output: false

Example 4:
Input: expression = ""|(&(t,f,t),!(t))""
Output: false

Constraints:
`1 <= expression.length <= 20000`
`expression[i]` consists of characters in `{'(', ')', '&', '|', '!', 't', 'f', ','}`.

`expression` is a valid expression representing a boolean, as given in the description.",0,,59.4,31.8,https://leetcode.com/problems/parsing-a-boolean-expression,285,13.3K,22.4K,Amazon,String,341,21,94,1,
225,1121,Divide Array Into Increasing Sequences,"Given a non-decreasing array of positive integers `nums` and an integer `K`, find out if this array can be divided into one or more disjoint increasing subsequences of length at least `K`.


Example 1:
Input: nums = [1,2,2,3,3,4,4], K = 3
Output: true
Explanation: 
The array can be divided into the two subsequences [1,2,3,4] and [2,3,4] with lengths at least 3 each.


Example 2:
Input: nums = [5,6,6,7,8], K = 3
Output: false
Explanation: 
There is no way to divide the array using the conditions required.

Note:
`1 <= nums.length <= 10^5`
`1 <= K <= nums.length`
`1 <= nums[i] <= 10^5`",1,,58.3,0.0,https://leetcode.com/problems/divide-array-into-increasing-sequences,40,3.2K,5.6K,Google,Math,67,21,76,1,
226,1125,Smallest Sufficient Team,"In a project, you have a list of required skills `req_skills`, and a list of people. The `ith` person `people[i]` contains a list of skills that the person has.

Consider a sufficient team: a set of people such that for every required skill in `req_skills`, there is at least one person in the team who has that skill. We can represent these teams by the index of each person.

For example, `team = [0, 1, 3]` represents the people with skills `people[0]`, `people[1]`, and `people[3]`.

Return any sufficient team of the smallest possible size, represented by the index of each person. You may return the answer in any order.

It is guaranteed an answer exists.


Example 1:
Input: req_skills = [""java"",""nodejs"",""reactjs""], people = [[""java""],[""nodejs""],[""nodejs"",""reactjs""]]
Output: [0,2]

Example 2:
Input: req_skills = [""algorithms"",""math"",""java"",""reactjs"",""csharp"",""aws""], people = [[""algorithms"",""math"",""java""],[""algorithms"",""math"",""reactjs""],[""java"",""csharp"",""aws""],[""reactjs"",""csharp""],[""csharp"",""math""],[""aws"",""java""]]
Output: [1,2]

Constraints:
`1 <= req_skills.length <= 16`
`1 <= req_skills[i].length <= 16`
`req_skills[i]` consists of lowercase English letters.

All the strings of `req_skills` are unique.

`1 <= people.length <= 60`
`0 <= people[i].length <= 16`
`1 <= people[i][j].length <= 16`
`people[i][j]` consists of lowercase English letters.

All the strings of `people[i]` are unique.

Every skill in `people[i]` is a skill in `req_skills`.

It is guaranteed a sufficient team exists.",0,,46.9,7.5,https://leetcode.com/problems/smallest-sufficient-team,125,11.8K,25.1K,Google,"Dynamic Programming,Bit Manipulation",469,9,98,1,
227,1127,User Purchase Platform,SQL Schema,1,,50.8,0.0,https://leetcode.com/problems/user-purchase-platform,146,7.3K,14.4K,LinkedIn,,90,66,58,0,
228,1147,Longest Chunked Palindrome Decomposition,"You are given a string `text`. You should split it to k substrings `(subtext1, subtext2, ..., subtextk)` such that:
`subtexti` is a non-empty string.

The concatenation of all the substrings is equal to `text` (i.e., `subtext1 + subtext2 + ... + subtextk == text`).

`subtexti == subtextk - i + 1` for all valid values of `i` (i.e., `1 <= i <= k`).

Return the largest possible value of `k`.


Example 1:
Input: text = ""ghiabcdefhelloadamhelloabcdefghi""
Output: 7
Explanation: We can split the string on ""(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)"".


Example 2:
Input: text = ""merchant""
Output: 1
Explanation: We can split the string on ""(merchant)"".


Example 3:
Input: text = ""antaprezatepzapreanta""
Output: 11
Explanation: We can split the string on ""(a)(nt)(a)(pre)(za)(tpe)(za)(pre)(a)(nt)(a)"".


Example 4:
Input: text = ""aaa""
Output: 3
Explanation: We can split the string on ""(a)(a)(a)"".


Constraints:
`1 <= text.length <= 1000`
`text` consists only of lowercase English characters.",0,,59.5,0.0,https://leetcode.com/problems/longest-chunked-palindrome-decomposition,205,12.3K,20.6K,Google,"Dynamic Programming,Rolling Hash",264,16,94,1,
229,1153,String Transforms Into Another String,"Given two strings `str1` and `str2` of the same length, determine whether you can transform `str1` into `str2` by doing zero or more conversions.

In one conversion you can convert all occurrences of one character in `str1` to any other lowercase English character.

Return `true` if and only if you can transform `str1` into `str2`.


Example 1:
Input: str1 = ""aabcc"", str2 = ""ccdee""
Output: true
Explanation: Convert 'c' to 'e' then 'b' to 'd' then 'a' to 'c'. Note that the order of conversions matter.


Example 2:
Input: str1 = ""leetcode"", str2 = ""codeleet""
Output: false
Explanation: There is no way to transform str1 to str2.


Constraints:
`1 <= str1.length == str2.length <= 104`
`str1` and `str2` contain only lowercase English letters.",1,,35.8,47.8,https://leetcode.com/problems/string-transforms-into-another-string,176,34.8K,97.2K,"Google,ByteDance",Graph,572,214,73,1,
230,1157,Online Majority Element In Subarray,"Implementing the class `MajorityChecker`, which has the following API:
`MajorityChecker(int[] arr)` constructs an instance of MajorityChecker with the given array `arr`;
`int query(int left, int right, int threshold)` has arguments such that:
	
`0 <= left <= right < arr.length` representing a subarray of `arr`;
`2 * threshold > right - left + 1`, ie. the threshold is always a strict majority of the length of the subarray
Each `query(...)` returns the element in `arr[left], arr[left+1], ..., arr[right]` that occurs at least `threshold` times, or `-1` if no such element exists.


Example:
MajorityChecker majorityChecker = new MajorityChecker([1,1,2,2,1,1]);
majorityChecker.query(0,5,4); // returns 1
majorityChecker.query(0,3,3); // returns -1
majorityChecker.query(2,3,2); // returns 2

Constraints:
`1 <= arr.length <= 20000`
`1 <= arr[i] <= 20000`
For each query, `0 <= left <= right < len(arr)`
For each query, `2 * threshold > right - left + 1`
The number of queries is at most `10000`",0,,40.7,2.0,https://leetcode.com/problems/online-majority-element-in-subarray,84,9.5K,23.4K,"Google,Nutanix","Array,Binary Search,Segment Tree",302,34,90,1,
231,1159,Market Analysis II,SQL Schema,1,,56.4,2.6,https://leetcode.com/problems/market-analysis-ii,205,8.3K,14.6K,Poshmark,,55,22,71,0,
232,1163,Last Substring in Lexicographical Order,"Given a string `s`, return the last substring of `s` in lexicographical order.


Example 1:
Input: s = ""abab""
Output: ""bab""
Explanation: The substrings are [""a"", ""ab"", ""aba"", ""abab"", ""b"", ""ba"", ""bab""]. The lexicographically maximum substring is ""bab"".


Example 2:
Input: s = ""leetcode""
Output: ""tcode""

Constraints:
`1 <= s.length <= 4 * 105`
`s` contains only lowercase English letters.",0,,36.3,48.7,https://leetcode.com/problems/last-substring-in-lexicographical-order,233,24.3K,66.8K,"Goldman Sachs,Salesforce","String,Suffix Array",317,358,47,0,
233,1168,Optimize Water Distribution in a Village,"There are `n` houses in a village. We want to supply water for all the houses by building wells and laying pipes.

For each house `i`, we can either build a well inside it directly with cost `wells[i - 1]` (note the `-1` due to 0-indexing), or pipe in water from another well to it. The costs to lay pipes between houses are given by the array `pipes`, where each `pipes[j] = [house1j, house2j, costj]` represents the cost to connect `house1j` and `house2j` together using a pipe. Connections are bidirectional.

Return the minimum total cost to supply water to all houses.


Example 1:
Input: n = 3, wells = [1,2,2], pipes = [[1,2,1],[2,3,1]]
Output: 3
Explanation: 
The image shows the costs of connecting houses using pipes.

The best strategy is to build a well in the first house with cost 1 and connect the other houses to it with cost 2 so the total cost is 3.


Constraints:
`1 <= n <= 104`
`wells.length == n`
`0 <= wells[i] <= 105`
`1 <= pipes.length <= 104`
`pipes[j].length == 3`
`1 <= house1j, house2j <= n`
`0 <= costj <= 105`
`house1j != house2j`",1,,61.1,2.7,https://leetcode.com/problems/optimize-water-distribution-in-a-village,115,11.6K,18.9K,"Google,Facebook,Yahoo","Union Find,Graph",396,15,96,1,
234,1172,Dinner Plate Stacks,"You have an infinite number of stacks arranged in a row and numbered (left to right) from 0, each of the stacks has the same maximum `capacity`.

Implement the `DinnerPlates` class:
`DinnerPlates(int capacity)` Initializes the object with the maximum `capacity` of the stacks.

`void push(int val)` Pushes the given positive integer `val` into the leftmost stack with size less than `capacity`.

`int pop()` Returns the value at the top of the rightmost non-empty stack and removes it from that stack, and returns `-1` if all stacks are empty.

`int popAtStack(int index)` Returns the value at the top of the stack with the given `index` and removes it from that stack, and returns -1 if the stack with that given `index` is empty.


Example:
Input: 
[""DinnerPlates"",""push"",""push"",""push"",""push"",""push"",""popAtStack"",""push"",""push"",""popAtStack"",""popAtStack"",""pop"",""pop"",""pop"",""pop"",""pop""]
[[2],[1],[2],[3],[4],[5],[0],[20],[21],[0],[2],[],[],[],[],[]]
Output: 
[null,null,null,null,null,null,2,null,null,20,21,5,4,3,1,-1]
Explanation: 
DinnerPlates D = DinnerPlates(2);  // Initialize with capacity = 2
D.push(1);
D.push(2);
D.push(3);
D.push(4);
D.push(5);         // The stacks are now:  2  4
                                           1  3  5
                                           ] ] ]
D.popAtStack(0);   // Returns 2.  The stacks are now:     4
                                                       1  3  5
                                                       ] ] ]
D.push(20);        // The stacks are now: 20  4
                                           1  3  5
                                           ] ] ]
D.push(21);        // The stacks are now: 20  4 21
                                           1  3  5
                                           ] ] ]
D.popAtStack(0);   // Returns 20.  The stacks are now:     4 21
                                                        1  3  5
                                                        ] ] ]
D.popAtStack(2);   // Returns 21.  The stacks are now:     4
                                                        1  3  5
                                                        ] ] ] 
D.pop()            // Returns 5.  The stacks are now:      4
                                                        1  3 
                                                        ] ]  
D.pop()            // Returns 4.  The stacks are now:   1  3 
                                                        ] ]   
D.pop()            // Returns 3.  The stacks are now:   1 
                                                        ]   
D.pop()            // Returns 1.  There are no stacks.

D.pop()            // Returns -1.  There are still no stacks.


Constraints:
`1 <= capacity <= 20000`
`1 <= val <= 20000`
`0 <= index <= 100000`
At most `200000` calls will be made to `push`, `pop`, and `popAtStack`.",0,,37.6,12.1,https://leetcode.com/problems/dinner-plate-stacks,134,10.8K,28.9K,ByteDance,Design,235,31,88,0,
235,1178,Number of Valid Words for Each Puzzle,"With respect to a given `puzzle` string, a `word` is valid if both the following conditions are satisfied:
`word` contains the first letter of `puzzle`.

For each letter in `word`, that letter is in `puzzle`.

	For example, if the puzzle is ""abcdefg"", then valid words are ""faced"", ""cabbage"", and ""baggage""; while invalid words are ""beefed"" (doesn't include ""a"") and ""based"" (includes ""s"" which isn't in the puzzle).

Return an array `answer`, where `answer[i]` is the number of words in the given word list `words` that are valid with respect to the puzzle `puzzles[i]`.


Example :
Input: 
words = [""aaaa"",""asas"",""able"",""ability"",""actt"",""actor"",""access""], 
puzzles = [""aboveyz"",""abrodyz"",""abslute"",""absoryz"",""actresz"",""gaswxyz""]
Output: [1,1,3,2,4,0]
Explanation:
1 valid word for ""aboveyz"" : ""aaaa"" 
1 valid word for ""abrodyz"" : ""aaaa""
3 valid words for ""abslute"" : ""aaaa"", ""asas"", ""able""
2 valid words for ""absoryz"" : ""aaaa"", ""asas""
4 valid words for ""actresz"" : ""aaaa"", ""asas"", ""actt"", ""access""
There're no valid words for ""gaswxyz"" cause none of the words in the list contains letter 'g'.


Constraints:
`1 <= words.length <= 10^5`
`4 <= words[i].length <= 50`
`1 <= puzzles.length <= 10^4`
`puzzles[i].length == 7`
`words[i][j]`, `puzzles[i][j]` are English lowercase letters.

Each `puzzles[i] `doesn't contain repeated characters.",0,,39.6,63.1,https://leetcode.com/problems/number-of-valid-words-for-each-puzzle,104,8.9K,22.4K,Dropbox,"Hash Table,Bit Manipulation",287,34,89,0,
236,1183,Maximum Number of Ones,"Consider a matrix `M` with dimensions `width * height`, such that every cell has value `0` or `1`, and any square sub-matrix of `M` of size `sideLength * sideLength` has at most `maxOnes` ones.

Return the maximum possible number of ones that the matrix `M` can have.


Example 1:
Input: width = 3, height = 3, sideLength = 2, maxOnes = 1
Output: 4
Explanation:
In a 3*3 matrix, no 2*2 sub-matrix can have more than 1 one.

The best solution that has 4 ones is:
[1,0,1]
[0,0,0]
[1,0,1]

Example 2:
Input: width = 3, height = 3, sideLength = 2, maxOnes = 2
Output: 6
Explanation:
[1,0,1]
[1,0,1]
[1,0,1]

Constraints:
`1 <= width, height <= 100`
`1 <= sideLength <= width, height`
`0 <= maxOnes <= sideLength * sideLength`",1,,57.8,0.0,https://leetcode.com/problems/maximum-number-of-ones,22,1.7K,2.9K,Qualcomm,"Math,Sort",76,9,89,0,
237,1187,Make Array Strictly Increasing,"Given two integer arrays `arr1` and `arr2`, return the minimum number of operations (possibly zero) needed to make `arr1` strictly increasing.

In one operation, you can choose two indices `0 <= i < arr1.length` and `0 <= j < arr2.length` and do the assignment `arr1[i] = arr2[j]`.

If there is no way to make `arr1` strictly increasing, return `-1`.


Example 1:
Input: arr1 = [1,5,3,6,7], arr2 = [1,3,2,4]
Output: 1
Explanation: Replace `5` with `2`, then `arr1 = [1, 2, 3, 6, 7]`.


Example 2:
Input: arr1 = [1,5,3,6,7], arr2 = [4,3,1]
Output: 2
Explanation: Replace `5` with `3` and then replace `3` with `4`. `arr1 = [1, 3, 4, 6, 7]`.


Example 3:
Input: arr1 = [1,5,3,6,7], arr2 = [1,6,3,3]
Output: -1
Explanation: You can't make `arr1` strictly increasing.


Constraints:
`1 <= arr1.length, arr2.length <= 2000`
`0 <= arr1[i], arr2[i] <= 10^9`",0,,42.0,5.9,https://leetcode.com/problems/make-array-strictly-increasing,84,7.4K,17.7K,,,372,11,97,0,
238,1192,Critical Connections in a Network,"There are `n` servers numbered from `0` to `n-1` connected by undirected server-to-server `connections` forming a network where `connections[i] = [a, b]` represents a connection between servers `a` and `b`. Any server can reach any other server directly or indirectly through the network.

A critical connection is a connection that, if removed, will make some server unable to reach some other server.

Return all critical connections in the network in any order.


Example 1:
Input: n = 4, connections = [[0,1],[1,2],[2,0],[1,3]]
Output: [[1,3]]
Explanation: [[3,1]] is also accepted.


Constraints:
`1 <= n <= 10^5`
`n-1 <= connections.length <= 10^5`
`connections[i][0] != connections[i][1]`
There are no repeated connections.",0,/articles/critical-connections-in-a-network,50.3,76.3,https://leetcode.com/problems/critical-connections-in-a-network,436,101.6K,202.1K,"Amazon,Adobe",Depth-first Search,2165,110,95,1,
239,1194,Tournament Winners,SQL Schema,1,,52.5,2.2,https://leetcode.com/problems/tournament-winners,200,8.2K,15.6K,Wayfair,,63,30,68,0,
240,1199,Minimum Time to Build Blocks,"You are given a list of blocks, where `blocks[i] = t` means that the `i`-th block needs `t` units of time to be built. A block can only be built by exactly one worker.

A worker can either split into two workers (number of workers increases by one) or build a block then go home. Both decisions cost some time.

The time cost of spliting one worker into two workers is given as an integer `split`. Note that if two workers split at the same time, they split in parallel so the cost would be `split`.

Output the minimum time needed to build all blocks.
Initially, there is only one worker.


Example 1:
Input: blocks = [1], split = 1
Output: 1
Explanation: We use 1 worker to build 1 block in 1 time unit.


Example 2:
Input: blocks = [1,2], split = 5
Output: 7
Explanation: We split the worker into 2 workers in 5 time units then assign each of them to a block so the cost is 5 + max(1, 2) = 7.


Example 3:
Input: blocks = [1,2,3], split = 1
Output: 4
Explanation: Split 1 worker into 2, then assign the first worker to the last block and split the second worker into 2.

Then, use the two unassigned workers to build the first two blocks.

The cost is 1 + max(3, 1 + max(1, 2)) = 4.


Constraints:
`1 <= blocks.length <= 1000`
`1 <= blocks[i] <= 10^5`
`1 <= split <= 100`",1,,38.9,0.0,https://leetcode.com/problems/minimum-time-to-build-blocks,38,2.8K,7.1K,Google,"Math,Dynamic Programming",115,14,89,1,
241,1203,Sort Items by Groups Respecting Dependencies,"There are `n` items each belonging to zero or one of `m` groups where `group[i]` is the group that the `i`-th item belongs to and it's equal to `-1` if the `i`-th item belongs to no group. The items and the groups are zero indexed. A group can have no item belonging to it.

Return a sorted list of the items such that:
The items that belong to the same group are next to each other in the sorted list.

There are some relations between these items where `beforeItems[i]` is a list containing all the items that should come before the `i`-th item in the sorted array (to the left of the `i`-th item).

Return any solution if there is more than one solution and return an empty list if there is no solution.


Example 1:
Input: n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3,6],[],[],[]]
Output: [6,3,4,1,5,2,0,7]

Example 2:
Input: n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3],[],[4],[]]
Output: []
Explanation: This is the same as example 1 except that 4 needs to be before 6 in the sorted list.


Constraints:
`1 <= m <= n <= 3 * 104`
`group.length == beforeItems.length == n`
`-1 <= group[i] <= m - 1`
`0 <= beforeItems[i].length <= n - 1`
`0 <= beforeItems[i][j] <= n - 1`
`i != beforeItems[i][j]`
`beforeItems[i] `does not contain duplicates elements.",0,,48.4,9.0,https://leetcode.com/problems/sort-items-by-groups-respecting-dependencies,109,8.9K,18.4K,Google,"Depth-first Search,Graph,Topological Sort",387,68,85,1,
242,1206,Design Skiplist,"Design a Skiplist without using any built-in libraries.

A Skiplist is a data structure that takes O(log(n)) time to `add`, `erase` and `search`. Comparing with treap and red-black tree which has the same function and performance, the code length of Skiplist can be comparatively short and the idea behind Skiplists are just simple linked lists.

For example: we have a Skiplist containing `[30,40,50,60,70,90]` and we want to add `80` and `45` into it. The Skiplist works this way:
Artyom Kalinin [CC BY-SA 3.0], via Wikimedia Commons
You can see there are many layers in the Skiplist. Each layer is a sorted linked list. With the help of the top layers, `add` , `erase` and `search `can be faster than O(n). It can be proven that the average time complexity for each operation is O(log(n)) and space complexity is O(n).

To be specific, your design should include these functions:
`bool search(int target)` : Return whether the `target` exists in the Skiplist or not.

`void add(int num)`: Insert a value into the SkipList. 
`bool erase(int num)`: Remove a value in the Skiplist. If `num` does not exist in the Skiplist, do nothing and return false. If there exists multiple `num` values, removing any one of them is fine.

See more about Skiplist : https://en.wikipedia.org/wiki/Skip_list
Note that duplicates may exist in the Skiplist, your code needs to handle this situation.


Example:
Skiplist skiplist = new Skiplist();
skiplist.add(1);
skiplist.add(2);
skiplist.add(3);
skiplist.search(0);   // return false.

skiplist.add(4);
skiplist.search(1);   // return true.

skiplist.erase(0);    // return false, 0 is not in skiplist.

skiplist.erase(1);    // return true.

skiplist.search(1);   // return false, 1 has already been erased.


Constraints:
`0 <= num, target <= 20000`
At most `50000` calls will be made to `search`, `add`, and `erase`.",0,,59.0,22.6,https://leetcode.com/problems/design-skiplist,83,7.5K,12.7K,Microsoft,Design,239,29,89,0,"[Design HashSet, /problems/design-hashset/, Easy], [Design HashMap, /problems/design-hashmap/, Easy], [Design Linked List, /problems/design-linked-list/, Medium]"
243,1210,Minimum Moves to Reach Target with Rotations,"In an `n*n` grid, there is a snake that spans 2 cells and starts moving from the top left corner at `(0, 0)` and `(0, 1)`. The grid has empty cells represented by zeros and blocked cells represented by ones. The snake wants to reach the lower right corner at `(n-1, n-2)` and `(n-1, n-1)`.

In one move the snake can:
Move one cell to the right if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.

Move down one cell if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.

Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. In that case the snake moves from `(r, c)` and `(r, c+1)` to `(r, c)` and `(r+1, c)`.

Rotate counterclockwise if it's in a vertical position and the two cells to its right are both empty. In that case the snake moves from `(r, c)` and `(r+1, c)` to `(r, c)` and `(r, c+1)`.

Return the minimum number of moves to reach the target.

If there is no way to reach the target, return `-1`.


Example 1:
Input: grid = [[0,0,0,0,0,1],
               [1,1,0,0,1,0],
               [0,0,0,0,1,1],
               [0,0,1,0,1,0],
               [0,1,1,0,0,0],
               [0,1,1,0,0,0]]
Output: 11
Explanation:
One possible solution is [right, right, rotate clockwise, right, down, down, down, down, rotate counterclockwise, right, down].


Example 2:
Input: grid = [[0,0,1,1,1,1],
               [0,0,0,0,1,1],
               [1,1,0,0,0,1],
               [1,1,1,0,0,1],
               [1,1,1,0,0,1],
               [1,1,1,0,0,0]]
Output: 9

Constraints:
`2 <= n <= 100`
`0 <= grid[i][j] <= 1`
It is guaranteed that the snake starts at empty cells.",0,,46.6,0.0,https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations,137,6K,12.8K,Kakao,Breadth-first Search,155,46,77,0,
244,1216,Valid Palindrome III,"Given a string `s` and an integer `k`, return `true` if `s` is a `k`-palindrome.

A string is `k`-palindrome if it can be transformed into a palindrome by removing at most `k` characters from it.


Example 1:
Input: s = ""abcdeca"", k = 2
Output: true
Explanation: Remove 'b' and 'e' characters.


Example 2:
Input: s = ""abbababa"", k = 1
Output: true

Constraints:
`1 <= s.length <= 1000`
`s` consists of only lowercase English letters.

`1 <= k <= s.length`",1,/articles/valid-palindrome-iii,50.0,7.9,https://leetcode.com/problems/valid-palindrome-iii,121,14.2K,28.5K,Facebook,"String,Dynamic Programming",234,6,98,1,
245,1220,Count Vowels Permutation,"Given an integer `n`, your task is to count how many strings of length `n` can be formed under the following rules:
Each character is a lower case vowel (`'a'`, `'e'`, `'i'`, `'o'`, `'u'`)
Each vowel `'a'` may only be followed by an `'e'`.

Each vowel `'e'` may only be followed by an `'a'` or an `'i'`.

Each vowel `'i'` may not be followed by another `'i'`.

Each vowel `'o'` may only be followed by an `'i'` or a `'u'`.

Each vowel `'u'` may only be followed by an `'a'.`
Since the answer may be too large, return it modulo `10^9 + 7.`

Example 1:
Input: n = 1
Output: 5
Explanation: All possible strings are: ""a"", ""e"", ""i"" , ""o"" and ""u"".


Example 2:
Input: n = 2
Output: 10
Explanation: All possible strings are: ""ae"", ""ea"", ""ei"", ""ia"", ""ie"", ""io"", ""iu"", ""oi"", ""ou"" and ""ua"".


Example 3: 
Input: n = 5
Output: 68

Constraints:
`1 <= n <= 2 * 10^4`",0,,54.0,62.9,https://leetcode.com/problems/count-vowels-permutation,239,16.7K,30.9K,Swiggy,Dynamic Programming,309,57,84,0,
246,1223,Dice Roll Simulation,"A die simulator generates a random number from 1 to 6 for each roll. You introduced a constraint to the generator such that it cannot roll the number `i` more than `rollMax[i]` (1-indexed) consecutive times. 
Given an array of integers `rollMax` and an integer `n`, return the number of distinct sequences that can be obtained with exact `n` rolls.

Two sequences are considered different if at least one element differs from each other. Since the answer may be too large, return it modulo `10^9 + 7`.


Example 1:
Input: n = 2, rollMax = [1,1,2,2,2,3]
Output: 34
Explanation: There will be 2 rolls of die, if there are no constraints on the die, there are 6 * 6 = 36 possible combinations. In this case, looking at rollMax array, the numbers 1 and 2 appear at most once consecutively, therefore sequences (1,1) and (2,2) cannot occur, so the final answer is 36-2 = 34.


Example 2:
Input: n = 2, rollMax = [1,1,1,1,1,1]
Output: 30

Example 3:
Input: n = 3, rollMax = [1,1,1,2,2,3]
Output: 181

Constraints:
`1 <= n <= 5000`
`rollMax.length == 6`
`1 <= rollMax[i] <= 15`",0,,46.7,6.4,https://leetcode.com/problems/dice-roll-simulation,180,17.1K,36.6K,Codenation,Dynamic Programming,518,162,76,0,
247,1224,Maximum Equal Frequency,"Given an array `nums` of positive integers, return the longest possible length of an array prefix of `nums`, such that it is possible to remove exactly one element from this prefix so that every number that has appeared in it will have the same number of occurrences.

If after removing one element there are no remaining elements, it's still considered that every appeared number has the same number of ocurrences (0).


Example 1:
Input: nums = [2,2,1,1,5,3,3,5]
Output: 7
Explanation: For the subarray [2,2,1,1,5,3,3] of length 7, if we remove nums[4]=5, we will get [2,2,1,1,3,3], so that each number will appear exactly twice.


Example 2:
Input: nums = [1,1,1,2,2,2,3,3,3,4,4,4,5]
Output: 13

Example 3:
Input: nums = [1,1,1,2,2,2]
Output: 5

Example 4:
Input: nums = [10,2,8,9,3,8,1,5,2,3,7,6]
Output: 8

Constraints:
`2 <= nums.length <= 10^5`
`1 <= nums[i] <= 10^5`",0,,35.5,0.0,https://leetcode.com/problems/maximum-equal-frequency,86,8.3K,23.5K,American Express,Hash Table,243,29,89,0,
248,1225,Report Contiguous Dates,SQL Schema,1,,63.0,2.3,https://leetcode.com/problems/report-contiguous-dates,158,7K,11.1K,"Amazon,Facebook",,123,10,92,1,
249,1231,Divide Chocolate,"You have one chocolate bar that consists of some chunks. Each chunk has its own sweetness given by the array `sweetness`.

You want to share the chocolate with your `K` friends so you start cutting the chocolate bar into `K+1` pieces using `K` cuts, each piece consists of some consecutive chunks.

Being generous, you will eat the piece with the minimum total sweetness and give the other pieces to your friends.

Find the maximum total sweetness of the piece you can get by cutting the chocolate bar optimally.


Example 1:
Input: sweetness = [1,2,3,4,5,6,7,8,9], K = 5
Output: 6
Explanation: You can divide the chocolate to [1,2,3], [4,5], [6], [7], [8], [9]

Example 2:
Input: sweetness = [5,6,7,8,9,1,2,3,4], K = 8
Output: 1
Explanation: There is only one way to cut the bar into 9 pieces.


Example 3:
Input: sweetness = [1,2,2,1,2,2,1,2,2], K = 2
Output: 5
Explanation: You can divide the chocolate to [1,2,2], [1,2,2], [1,2,2]

Constraints:
`0 <= K < sweetness.length <= 10^4`
`1 <= sweetness[i] <= 10^5`",1,,53.7,8.3,https://leetcode.com/problems/divide-chocolate,124,23.6K,44K,Google,"Binary Search,Greedy",455,33,93,1,
250,1235,Maximum Profit in Job Scheduling,"We have `n` jobs, where every job is scheduled to be done from `startTime[i]` to `endTime[i]`, obtaining a profit of `profit[i]`.

You're given the `startTime`, `endTime` and `profit` arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.

If you choose a job that ends at time `X` you will be able to start another job that starts at time `X`.


Example 1:
Input: startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]
Output: 120
Explanation: The subset chosen is the first and fourth job. 
Time range [1-3]+[3-6] , we get profit of 120 = 50 + 70.


Example 2:
Input: startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60]
Output: 150
Explanation: The subset chosen is the first, fourth and fifth job. 
Profit obtained 150 = 20 + 70 + 60.


Example 3:
Input: startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4]
Output: 6

Constraints:
`1 <= startTime.length == endTime.length == profit.length <= 5 * 104`
`1 <= startTime[i] < endTime[i] <= 109`
`1 <= profit[i] <= 104`",0,,47.6,82.7,https://leetcode.com/problems/maximum-profit-in-job-scheduling,271,36.9K,77.4K,"LinkedIn,DoorDash,ByteDance,Amazon,Cisco,Databricks,Bloomberg,Dunzo,Swiggy","Binary Search,Dynamic Programming,Sort",1183,13,99,1,
251,1240,Tiling a Rectangle with the Fewest Squares,"Given a rectangle of size `n` x `m`, find the minimum number of integer-sided squares that tile the rectangle.


Example 1:
Input: n = 2, m = 3
Output: 3
Explanation: `3` squares are necessary to cover the rectangle.

`2` (squares of `1x1`)
`1` (square of `2x2`)

Example 2:
Input: n = 5, m = 8
Output: 5

Example 3:
Input: n = 11, m = 13
Output: 6

Constraints:
`1 <= n <= 13`
`1 <= m <= 13`",0,,52.8,22.9,https://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares,114,11.6K,22K,Google,"Dynamic Programming,Backtracking",293,298,50,1,
252,1246,Palindrome Removal,"Given an integer array `arr`, in one move you can select a palindromic subarray `arr[i], arr[i+1], ..., arr[j]` where `i <= j`, and remove that subarray from the given array. Note that after removing a subarray, the elements on the left and on the right of that subarray move to fill the gap left by the removal.

Return the minimum number of moves needed to remove all numbers from the array.


Example 1:
Input: arr = [1,2]
Output: 2

Example 2:
Input: arr = [1,3,4,1,5]
Output: 3
Explanation: Remove [4] then remove [1,3,1] then remove [5].


Constraints:
`1 <= arr.length <= 100`
`1 <= arr[i] <= 20`",1,,45.8,0.0,https://leetcode.com/problems/palindrome-removal,56,7.1K,15.5K,Microsoft,Dynamic Programming,222,7,97,0,
253,1250,Check If It Is a Good Array,"Given an array `nums` of positive integers. Your task is to select some subset of `nums`, multiply each element by an integer and add all these numbers. The array is said to be good if you can obtain a sum of `1` from the array by any possible subset and multiplicand.

Return `True` if the array is good otherwise return `False`.


Example 1:
Input: nums = [12,5,7,23]
Output: true
Explanation: Pick numbers 5 and 7.

5*3 + 7*(-2) = 1

Example 2:
Input: nums = [29,6,10]
Output: true
Explanation: Pick numbers 29, 6 and 10.

29*1 + 6*(-3) + 10*(-1) = 1

Example 3:
Input: nums = [3,6]
Output: false

Constraints:
`1 <= nums.length <= 10^5`
`1 <= nums[i] <= 10^9`",0,,56.2,0.0,https://leetcode.com/problems/check-if-it-is-a-good-array,79,9.1K,16.2K,Dropbox,Math,134,207,39,0,
254,1255,Maximum Score Words Formed by Letters,"Given a list of `words`, list of  single `letters` (might be repeating) and `score` of every character.

Return the maximum score of any valid set of words formed by using the given letters (`words[i]` cannot be used two or more times).

It is not necessary to use all characters in `letters` and each letter can only be used once. Score of letters `'a'`, `'b'`, `'c'`, ... ,`'z'` is given by `score[0]`, `score[1]`, ... , `score[25]` respectively.


Example 1:
Input: words = [""dog"",""cat"",""dad"",""good""], letters = [""a"",""a"",""c"",""d"",""d"",""d"",""g"",""o"",""o""], score = [1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0]
Output: 23
Explanation:
Score  a=1, c=9, d=5, g=3, o=2
Given letters, we can form the words ""dad"" (5+1+5) and ""good"" (3+2+2+5) with a score of 23.

Words ""dad"" and ""dog"" only get a score of 21.


Example 2:
Input: words = [""xxxz"",""ax"",""bx"",""cx""], letters = [""z"",""a"",""b"",""c"",""x"",""x"",""x""], score = [4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,10]
Output: 27
Explanation:
Score  a=4, b=4, c=4, x=5, z=10
Given letters, we can form the words ""ax"" (4+5), ""bx"" (4+5) and ""cx"" (4+5) with a score of 27.

Word ""xxxz"" only get a score of 25.


Example 3:
Input: words = [""leetcode""], letters = [""l"",""e"",""t"",""c"",""o"",""d""], score = [0,0,1,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0]
Output: 0
Explanation:
Letter ""e"" can only be used once.


Constraints:
`1 <= words.length <= 14`
`1 <= words[i].length <= 15`
`1 <= letters.length <= 100`
`letters[i].length == 1`
`score.length == 26`
`0 <= score[i] <= 10`
`words[i]`, `letters[i]` contains only lower case English letters.",0,,70.1,13.4,https://leetcode.com/problems/maximum-score-words-formed-by-letters,201,12K,17.2K,Google,Bit Manipulation,274,26,91,1,
255,1259,Handshakes That Don't Cross,"You are given an even number of people `num_people` that stand around a circle and each person shakes hands with someone else, so that there are `num_people / 2` handshakes total.

Return the number of ways these handshakes could occur such that none of the handshakes cross.

Since this number could be very big, return the answer mod `10^9 + 7`

Example 1:
Input: num_people = 2
Output: 1

Example 2:
Input: num_people = 4
Output: 2
Explanation: There are two ways to do it, the first way is [(1,2),(3,4)] and the second one is [(2,3),(4,1)].


Example 3:
Input: num_people = 6
Output: 5

Example 4:
Input: num_people = 8
Output: 14

Constraints:
`2 <= num_people <= 1000`
`num_people % 2 == 0`",1,,54.3,0.0,https://leetcode.com/problems/handshakes-that-dont-cross,41,3.7K,6.7K,Amazon,"Math,Dynamic Programming",83,6,93,1,
256,1263,Minimum Moves to Move a Box to Their Target Location,"Storekeeper is a game in which the player pushes boxes around in a warehouse trying to get them to target locations.

The game is represented by a `grid` of size `m x n`, where each element is a wall, floor, or a box.

Your task is move the box `'B'` to the target position `'T'` under the following rules:
Player is represented by character `'S'` and can move up, down, left, right in the `grid` if it is a floor (empy cell).

Floor is represented by character `'.'` that means free cell to walk.

Wall is represented by character `'#'` that means obstacle  (impossible to walk there). 
There is only one box `'B'` and one target cell `'T'` in the `grid`.

The box can be moved to an adjacent free cell by standing next to the box and then moving in the direction of the box. This is a push.

The player cannot walk through the box.

Return the minimum number of pushes to move the box to the target. If there is no way to reach the target, return `-1`.


Example 1:
Input: grid = [[""#"",""#"",""#"",""#"",""#"",""#""],
               [""#"",""T"",""#"",""#"",""#"",""#""],
               [""#"",""."",""."",""B"",""."",""#""],
               [""#"",""."",""#"",""#"",""."",""#""],
               [""#"",""."",""."",""."",""S"",""#""],
               [""#"",""#"",""#"",""#"",""#"",""#""]]
Output: 3
Explanation: We return only the number of times the box is pushed.


Example 2:
Input: grid = [[""#"",""#"",""#"",""#"",""#"",""#""],
               [""#"",""T"",""#"",""#"",""#"",""#""],
               [""#"",""."",""."",""B"",""."",""#""],
               [""#"",""#"",""#"",""#"",""."",""#""],
               [""#"",""."",""."",""."",""S"",""#""],
               [""#"",""#"",""#"",""#"",""#"",""#""]]
Output: -1

Example 3:
Input: grid = [[""#"",""#"",""#"",""#"",""#"",""#""],
               [""#"",""T"",""."",""."",""#"",""#""],
               [""#"",""."",""#"",""B"",""."",""#""],
               [""#"",""."",""."",""."",""."",""#""],
               [""#"",""."",""."",""."",""S"",""#""],
               [""#"",""#"",""#"",""#"",""#"",""#""]]
Output: 5
Explanation:  push the box down, left, left, up and up.


Example 4:
Input: grid = [[""#"",""#"",""#"",""#"",""#"",""#"",""#""],
               [""#"",""S"",""#"",""."",""B"",""T"",""#""],
               [""#"",""#"",""#"",""#"",""#"",""#"",""#""]]
Output: -1

Constraints:
`m == grid.length`
`n == grid[i].length`
`1 <= m <= 20`
`1 <= n <= 20`
`grid` contains only characters `'.'`, `'#'`,  `'S'` , `'T'`, or `'B'`.

There is only one character `'S'`, `'B'` and `'T'` in the `grid`.",0,,43.6,6.2,https://leetcode.com/problems/minimum-moves-to-move-a-box-to-their-target-location,105,6K,13.8K,,,288,12,96,0,
257,1269,Number of Ways to Stay in the Same Place After Some Steps,"You have a pointer at index `0` in an array of size `arrLen`. At each step, you can move 1 position to the left, 1 position to the right in the array or stay in the same place  (The pointer should not be placed outside the array at any time).

Given two integers `steps` and `arrLen`, return the number of ways such that your pointer still at index `0` after exactly `steps` steps.

Since the answer may be too large, return it modulo `10^9 + 7`.


Example 1:
Input: steps = 3, arrLen = 2
Output: 4
Explanation: There are 4 differents ways to stay at index 0 after 3 steps.

Right, Left, Stay
Stay, Right, Left
Right, Stay, Left
Stay, Stay, Stay

Example 2:
Input: steps = 2, arrLen = 4
Output: 2
Explanation: There are 2 differents ways to stay at index 0 after 2 steps
Right, Left
Stay, Stay

Example 3:
Input: steps = 4, arrLen = 2
Output: 8

Constraints:
`1 <= steps <= 500`
`1 <= arrLen <= 10^6`",0,,43.3,2.2,https://leetcode.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps,220,19.1K,44.2K,Facebook,Dynamic Programming,361,21,95,1,
258,1274,Number of Ships in a Rectangle,"(This problem is an interactive problem.)
Each ship is located at an integer point on the sea represented by a cartesian plane, and each integer point may contain at most 1 ship.

You have a function `Sea.hasShips(topRight, bottomLeft)` which takes two points as arguments and returns `true` If there is at least one ship in the rectangle represented by the two points, including on the boundary.

Given two points: the top right and bottom left corners of a rectangle, return the number of ships present in that rectangle. It is guaranteed that there are at most 10 ships in that rectangle.

Submissions making more than 400 calls to `hasShips` will be judged Wrong Answer. Also, any solutions that attempt to circumvent the judge will result in disqualification.


Example :
Input: 
ships = [[1,1],[2,2],[3,3],[5,5]], topRight = [4,4], bottomLeft = [0,0]
Output: 3
Explanation: From [0,0] to [4,4] we can count 3 ships within the range.


Constraints:
On the input `ships` is only given to initialize the map internally. You must solve this problem ""blindfolded"". In other words, you must find the answer using the given `hasShips` API, without knowing the `ships` position.

`0 <= bottomLeft[0] <= topRight[0] <= 1000`
`0 <= bottomLeft[1] <= topRight[1] <= 1000`
`topRight != bottomLeft`",1,,65.9,11.7,https://leetcode.com/problems/number-of-ships-in-a-rectangle,82,9.6K,14.6K,Bloomberg,Divide and Conquer,178,29,86,0,
259,1278,Palindrome Partitioning III,"You are given a string `s` containing lowercase letters and an integer `k`. You need to :
First, change some characters of `s` to other lowercase English letters.

Then divide `s` into `k` non-empty disjoint substrings such that each substring is palindrome.

Return the minimal number of characters that you need to change to divide the string.


Example 1:
Input: s = ""abc"", k = 2
Output: 1
Explanation: You can split the string into ""ab"" and ""c"", and change 1 character in ""ab"" to make it palindrome.


Example 2:
Input: s = ""aabbc"", k = 3
Output: 0
Explanation: You can split the string into ""aa"", ""bb"" and ""c"", all of them are palindrome.


Example 3:
Input: s = ""leetcode"", k = 8
Output: 0

Constraints:
`1 <= k <= s.length <= 100`.

`s` only contains lowercase English letters.",0,,61.1,0.0,https://leetcode.com/problems/palindrome-partitioning-iii,184,12.4K,20.2K,"Uber,Apple",Dynamic Programming,426,9,98,1,"[Palindrome Partitioning IV, /problems/palindrome-partitioning-iv/, Hard]"
260,1284,Minimum Number of Flips to Convert Binary Matrix to Zero Matrix,"Given a `m x n` binary matrix `mat`. In one step, you can choose one cell and flip it and all the four neighbours of it if they exist (Flip is changing 1 to 0 and 0 to 1). A pair of cells are called neighboors if they share one edge.

Return the minimum number of steps required to convert `mat` to a zero matrix or -1 if you cannot.

Binary matrix is a matrix with all cells equal to 0 or 1 only.

Zero matrix is a matrix with all cells equal to 0.


Example 1:
Input: mat = [[0,0],[0,1]]
Output: 3
Explanation: One possible solution is to flip (1, 0) then (0, 1) and finally (1, 1) as shown.


Example 2:
Input: mat = [[0]]
Output: 0
Explanation: Given matrix is a zero matrix. We don't need to change it.


Example 3:
Input: mat = [[1,1,1],[1,0,1],[0,0,0]]
Output: 6

Example 4:
Input: mat = [[1,0,0],[1,0,0]]
Output: -1
Explanation: Given matrix can't be a zero matrix

Constraints:
`m == mat.length`
`n == mat[0].length`
`1 <= m <= 3`
`1 <= n <= 3`
`mat[i][j]` is 0 or 1.",0,,70.1,22.2,https://leetcode.com/problems/minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix,186,11.4K,16.3K,"Google,Airbnb",Breadth-first Search,291,34,90,1,
261,1289,Minimum Falling Path Sum II,"Given a square grid of integers `arr`, a falling path with non-zero shifts is a choice of exactly one element from each row of `arr`, such that no two elements chosen in adjacent rows are in the same column.

Return the minimum sum of a falling path with non-zero shifts.


Example 1:
Input: arr = [[1,2,3],[4,5,6],[7,8,9]]
Output: 13
Explanation: 
The possible falling paths are:
[1,5,9], [1,5,7], [1,6,7], [1,6,8],
[2,4,8], [2,4,9], [2,6,7], [2,6,8],
[3,4,8], [3,4,9], [3,5,7], [3,5,9]
The falling path with the smallest sum is [1,5,7], so the answer is 13.


Constraints:
`1 <= arr.length == arr[i].length <= 200`
`-99 <= arr[i][j] <= 99`",0,,62.6,20.1,https://leetcode.com/problems/minimum-falling-path-sum-ii,231,16.4K,26.2K,Roblox,Dynamic Programming,370,38,91,0,"[Minimum Falling Path Sum, /problems/minimum-falling-path-sum/, Medium]"
262,1293,Shortest Path in a Grid with Obstacles Elimination,"Given a `m * n` grid, where each cell is either `0` (empty) or `1` (obstacle). In one step, you can move up, down, left or right from and to an empty cell.

Return the minimum number of steps to walk from the upper left corner `(0, 0)` to the lower right corner `(m-1, n-1)` given that you can eliminate at most `k` obstacles. If it is not possible to find such walk return -1.


Example 1:
Input: 
grid = 
[[0,0,0],
 [1,1,0],
 [0,0,0],
 [0,1,1],
 [0,0,0]], 
k = 1
Output: 6
Explanation: 
The shortest path without eliminating any obstacle is 10. 
The shortest path with one obstacle elimination at position (3,2) is 6. Such path is `(0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2) -> (3,2) -> (4,2)`.


Example 2:
Input: 
grid = 
[[0,1,1],
 [1,1,1],
 [1,0,0]], 
k = 1
Output: -1
Explanation: 
We need to eliminate at least two obstacles to find such a walk.


Constraints:
`grid.length == m`
`grid[0].length == n`
`1 <= m, n <= 40`
`1 <= k <= m*n`
`grid[i][j] == 0 or 1`
`grid[0][0] == grid[m-1][n-1] == 0`",0,,43.1,48.8,https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination,268,26.2K,60.9K,"Google,ByteDance,Amazon",Breadth-first Search,724,12,98,1,"[Shortest Path to Get Food, /problems/shortest-path-to-get-food/, Medium]"
263,1298,Maximum Candies You Can Get from Boxes,"Given `n` boxes, each box is given in the format `[status, candies, keys, containedBoxes]` where:
`status[i]`: an integer which is 1 if `box[i]` is open and 0 if `box[i]` is closed.

`candies[i]`: an integer representing the number of candies in `box[i]`.

`keys[i]`: an array contains the indices of the boxes you can open with the key in `box[i]`.

`containedBoxes[i]`: an array contains the indices of the boxes found in `box[i]`.

You will start with some boxes given in `initialBoxes` array. You can take all the candies in any open box and you can use the keys in it to open new boxes and you also can use the boxes you find in it.

Return the maximum number of candies you can get following the rules above.


Example 1:
Input: status = [1,0,1,0], candies = [7,5,4,100], keys = [[],[],[1],[]], containedBoxes = [[1,2],[3],[],[]], initialBoxes = [0]
Output: 16
Explanation: You will be initially given box 0. You will find 7 candies in it and boxes 1 and 2. Box 1 is closed and you don't have a key for it so you will open box 2. You will find 4 candies and a key to box 1 in box 2.

In box 1, you will find 5 candies and box 3 but you will not find a key to box 3 so box 3 will remain closed.

Total number of candies collected = 7 + 4 + 5 = 16 candy.


Example 2:
Input: status = [1,0,0,0,0,0], candies = [1,1,1,1,1,1], keys = [[1,2,3,4,5],[],[],[],[],[]], containedBoxes = [[1,2,3,4,5],[],[],[],[],[]], initialBoxes = [0]
Output: 6
Explanation: You have initially box 0. Opening it you can find boxes 1,2,3,4 and 5 and their keys. The total number of candies will be 6.


Example 3:
Input: status = [1,1,1], candies = [100,1,100], keys = [[],[0,2],[]], containedBoxes = [[],[],[]], initialBoxes = [1]
Output: 1

Example 4:
Input: status = [1], candies = [100], keys = [[]], containedBoxes = [[]], initialBoxes = []
Output: 0

Example 5:
Input: status = [1,1,1], candies = [2,3,2], keys = [[],[],[]], containedBoxes = [[],[],[]], initialBoxes = [2,1,0]
Output: 7

Constraints:
`1 <= status.length <= 1000`
`status.length == candies.length == keys.length == containedBoxes.length == n`
`status[i]` is `0` or `1`.

`1 <= candies[i] <= 1000`
`0 <= keys[i].length <= status.length`
`0 <= keys[i][j] < status.length`
All values in `keys[i]` are unique.

`0 <= containedBoxes[i].length <= status.length`
`0 <= containedBoxes[i][j] < status.length`
All values in `containedBoxes[i]` are unique.

Each box is contained in one box at most.

`0 <= initialBoxes.length <= status.length`
`0 <= initialBoxes[i] < status.length`",0,,59.8,0.0,https://leetcode.com/problems/maximum-candies-you-can-get-from-boxes,150,7.8K,13K,Airbnb,Breadth-first Search,118,94,56,0,
264,1301,Number of Paths with Max Score,"You are given a square `board` of characters. You can move on the board starting at the bottom right square marked with the character `'S'`.

You need to reach the top left square marked with the character `'E'`. The rest of the squares are labeled either with a numeric character `1, 2, ..., 9` or with an obstacle `'X'`. In one move you can go up, left or up-left (diagonally) only if there is no obstacle there.

Return a list of two integers: the first integer is the maximum sum of numeric characters you can collect, and the second is the number of such paths that you can take to get that maximum sum, taken modulo `10^9 + 7`.

In case there is no path, return `[0, 0]`.


Example 1:
Input: board = [""E23"",""2X2"",""12S""]
Output: [7,1]

Example 2:
Input: board = [""E12"",""1X1"",""21S""]
Output: [4,2]

Example 3:
Input: board = [""E11"",""XXX"",""11S""]
Output: [0,0]

Constraints:
`2 <= board.length == board[i].length <= 100`",0,,38.2,0.0,https://leetcode.com/problems/number-of-paths-with-max-score,119,6.9K,17.9K,Samsung,Dynamic Programming,199,11,95,0,
265,1307,Verbal Arithmetic Puzzle,"Given an equation, represented by `words` on left side and the `result` on right side.

You need to check if the equation is solvable under the following rules:
Each character is decoded as one digit (0 - 9).

Every pair of different characters they must map to different digits.

Each `words[i]` and `result` are decoded as one number without leading zeros.

Sum of numbers on left side (`words`) will equal to the number on right side (`result`). 
Return `True` if the equation is solvable otherwise return `False`.


Example 1:
Input: words = [""SEND"",""MORE""], result = ""MONEY""
Output: true
Explanation: Map 'S'-> 9, 'E'->5, 'N'->6, 'D'->7, 'M'->1, 'O'->0, 'R'->8, 'Y'->'2'
Such that: ""SEND"" + ""MORE"" = ""MONEY"" ,  9567 + 1085 = 10652

Example 2:
Input: words = [""SIX"",""SEVEN"",""SEVEN""], result = ""TWENTY""
Output: true
Explanation: Map 'S'-> 6, 'I'->5, 'X'->0, 'E'->8, 'V'->7, 'N'->2, 'T'->1, 'W'->'3', 'Y'->4
Such that: ""SIX"" + ""SEVEN"" + ""SEVEN"" = ""TWENTY"" ,  650 + 68782 + 68782 = 138214

Example 3:
Input: words = [""THIS"",""IS"",""TOO""], result = ""FUNNY""
Output: true

Example 4:
Input: words = [""LEET"",""CODE""], result = ""POINT""
Output: false

Constraints:
`2 <= words.length <= 5`
`1 <= words[i].length, result.length <= 7`
`words[i], result` contain only uppercase English letters.

The number of different characters used in the expression is at most `10`.",0,,36.6,0.0,https://leetcode.com/problems/verbal-arithmetic-puzzle,117,5.5K,15.1K,Atlassian,"Math,Backtracking",205,65,76,0,
266,1312,Minimum Insertion Steps to Make a String Palindrome,"Given a string `s`. In one step you can insert any character at any index of the string.

Return the minimum number of steps to make `s` palindrome.

A Palindrome String is one that reads the same backward as well as forward.


Example 1:
Input: s = ""zzazz""
Output: 0
Explanation: The string ""zzazz"" is already palindrome we don't need any insertions.


Example 2:
Input: s = ""mbadm""
Output: 2
Explanation: String can be ""mbdadbm"" or ""mdbabdm"".


Example 3:
Input: s = ""leetcode""
Output: 5
Explanation: Inserting 5 characters the string becomes ""leetcodocteel"".


Example 4:
Input: s = ""g""
Output: 0

Example 5:
Input: s = ""no""
Output: 1

Constraints:
`1 <= s.length <= 500`
All characters of `s` are lower case English letters.",0,,60.0,29.9,https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome,308,22.6K,37.6K,"Amazon,LinkedIn",Dynamic Programming,715,13,98,1,
267,1316,Distinct Echo Substrings,"Return the number of distinct non-empty substrings of `text` that can be written as the concatenation of some string with itself (i.e. it can be written as `a + a` where `a` is some string).


Example 1:
Input: text = ""abcabcabc""
Output: 3
Explanation: The 3 substrings are ""abcabc"", ""bcabca"" and ""cabcab"".


Example 2:
Input: text = ""leetcodeleetcode""
Output: 2
Explanation: The 2 substrings are ""ee"" and ""leetcodeleetcode"".


Constraints:
`1 <= text.length <= 2000`
`text` has only lowercase English letters.",0,,49.7,22.9,https://leetcode.com/problems/distinct-echo-substrings,116,8.7K,17.4K,Google,"String,Rolling Hash",110,137,45,1,
268,1320,Minimum Distance to Type a Word Using Two Fingers,"You have a keyboard layout as shown above in the XY plane, where each English uppercase letter is located at some coordinate, for example, the letter A is located at coordinate (0,0), the letter B is located at coordinate (0,1), the letter P is located at coordinate (2,3) and the letter Z is located at coordinate (4,1).

Given the string `word`, return the minimum total distance to type such string using only two fingers. The distance between coordinates (x1,y1) and (x2,y2) is |x1 - x2| + |y1 - y2|. 
Note that the initial positions of your two fingers are considered free so don't count towards your total distance, also your two fingers do not have to start at the first letter or the first two letters.


Example 1:
Input: word = ""CAKE""
Output: 3
Explanation: 
Using two fingers, one optimal way to type ""CAKE"" is: 
Finger 1 on letter 'C' -> cost = 0 
Finger 1 on letter 'A' -> cost = Distance from letter 'C' to letter 'A' = 2 
Finger 2 on letter 'K' -> cost = 0 
Finger 2 on letter 'E' -> cost = Distance from letter 'K' to letter 'E' = 1 
Total distance = 3

Example 2:
Input: word = ""HAPPY""
Output: 6
Explanation: 
Using two fingers, one optimal way to type ""HAPPY"" is:
Finger 1 on letter 'H' -> cost = 0
Finger 1 on letter 'A' -> cost = Distance from letter 'H' to letter 'A' = 2
Finger 2 on letter 'P' -> cost = 0
Finger 2 on letter 'P' -> cost = Distance from letter 'P' to letter 'P' = 0
Finger 1 on letter 'Y' -> cost = Distance from letter 'A' to letter 'Y' = 4
Total distance = 6

Example 3:
Input: word = ""NEW""
Output: 3

Example 4:
Input: word = ""YEAR""
Output: 7

Constraints:
`2 <= word.length <= 300`
Each word[i]` is an English uppercase letter.",0,,61.7,2.1,https://leetcode.com/problems/minimum-distance-to-type-a-word-using-two-fingers,197,17.6K,28.5K,Google,Dynamic Programming,541,23,96,1,
269,1326,Minimum Number of Taps to Open to Water a Garden,"There is a one-dimensional garden on the x-axis. The garden starts at the point `0` and ends at the point `n`. (i.e The length of the garden is `n`).

There are `n + 1` taps located at points `[0, 1, ..., n]` in the garden.

Given an integer `n` and an integer array `ranges` of length `n + 1` where `ranges[i]` (0-indexed) means the `i-th` tap can water the area `[i - ranges[i], i + ranges[i]]` if it was open.

Return the minimum number of taps that should be open to water the whole garden, If the garden cannot be watered return -1.


Example 1:
Input: n = 5, ranges = [3,4,1,1,0,0]
Output: 1
Explanation: The tap at point 0 can cover the interval [-3,3]
The tap at point 1 can cover the interval [-3,5]
The tap at point 2 can cover the interval [1,3]
The tap at point 3 can cover the interval [2,4]
The tap at point 4 can cover the interval [4,4]
The tap at point 5 can cover the interval [5,5]
Opening Only the second tap will water the whole garden [0,5]

Example 2:
Input: n = 3, ranges = [0,0,0,0]
Output: -1
Explanation: Even if you activate all the four taps you cannot water the whole garden.


Example 3:
Input: n = 7, ranges = [1,2,1,0,2,1,0,1]
Output: 3

Example 4:
Input: n = 8, ranges = [4,0,0,0,0,0,0,0,4]
Output: 2

Example 5:
Input: n = 8, ranges = [4,0,0,0,4,0,0,0,4]
Output: 1

Constraints:
`1 <= n <= 10^4`
`ranges.length == n + 1`
`0 <= ranges[i] <= 100`",0,,47.5,67.9,https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden,216,25K,52.7K,"Apple,Docusign,Twitter,Morgan Stanley","Dynamic Programming,Greedy",572,56,91,1,
270,1330,Reverse Subarray To Maximize Array Value,"You are given an integer array `nums`. The value of this array is defined as the sum of `|nums[i]-nums[i+1]|` for all `0 <= i < nums.length-1`.

You are allowed to select any subarray of the given array and reverse it. You can perform this operation only once.

Find maximum possible value of the final array.


Example 1:
Input: nums = [2,3,1,5,4]
Output: 10
Explanation: By reversing the subarray [3,1,5] the array becomes [2,5,1,3,4] whose value is 10.


Example 2:
Input: nums = [2,4,9,24,2,1,10]
Output: 68

Constraints:
`1 <= nums.length <= 3*10^4`
`-10^5 <= nums[i] <= 10^5`",0,,36.8,0.0,https://leetcode.com/problems/reverse-subarray-to-maximize-array-value,39,2.9K,7.9K,Codenation,"Array,Math",221,27,89,0,
271,1335,Minimum Difficulty of a Job Schedule,"You want to schedule a list of jobs in `d` days. Jobs are dependent (i.e To work on the `i-th` job, you have to finish all the jobs `j` where `0 <= j < i`).

You have to finish at least one task every day. The difficulty of a job schedule is the sum of difficulties of each day of the `d` days. The difficulty of a day is the maximum difficulty of a job done in that day.

Given an array of integers `jobDifficulty` and an integer `d`. The difficulty of the `i-th` job is `jobDifficulty[i]`.

Return the minimum difficulty of a job schedule. If you cannot find a schedule for the jobs return -1.


Example 1:
Input: jobDifficulty = [6,5,4,3,2,1], d = 2
Output: 7
Explanation: First day you can finish the first 5 jobs, total difficulty = 6.

Second day you can finish the last job, total difficulty = 1.

The difficulty of the schedule = 6 + 1 = 7 

Example 2:
Input: jobDifficulty = [9,9,9], d = 4
Output: -1
Explanation: If you finish a job per day you will still have a free day. you cannot find a schedule for the given jobs.


Example 3:
Input: jobDifficulty = [1,1,1], d = 3
Output: 3
Explanation: The schedule is one job per day. total difficulty will be 3.


Example 4:
Input: jobDifficulty = [7,1,7,1,7,1], d = 3
Output: 15

Example 5:
Input: jobDifficulty = [11,111,22,222,33,333,44,444], d = 6
Output: 843

Constraints:
`1 <= jobDifficulty.length <= 300`
`0 <= jobDifficulty[i] <= 1000`
`1 <= d <= 10`",0,,56.6,93.7,https://leetcode.com/problems/minimum-difficulty-of-a-job-schedule,247,34.9K,61.6K,"Amazon,Swiggy",Dynamic Programming,617,78,89,1,
272,1336,Number of Transactions per Visit,SQL Schema,1,,49.2,5.7,https://leetcode.com/problems/number-of-transactions-per-visit,129,4.8K,9.8K,"Square,Machine Zone,MachineZone",,34,164,17,0,
273,1340,Jump Game V,"Given an array of integers `arr` and an integer `d`. In one step you can jump from index `i` to index:
`i + x` where: `i + x < arr.length` and ` 0 < x <= d`.

`i - x` where: `i - x >= 0` and ` 0 < x <= d`.

In addition, you can only jump from index `i` to index `j` if `arr[i] > arr[j]` and `arr[i] > arr[k]` for all indices `k` between `i` and `j` (More formally `min(i, j) < k < max(i, j)`).

You can choose any index of the array and start jumping. Return the maximum number of indices you can visit.

Notice that you can not jump outside of the array at any time.


Example 1:
Input: arr = [6,4,14,6,8,13,9,7,10,6,12], d = 2
Output: 4
Explanation: You can start at index 10. You can jump 10 --> 8 --> 6 --> 7 as shown.

Note that if you start at index 6 you can only jump to index 7. You cannot jump to index 5 because 13 > 9. You cannot jump to index 4 because index 5 is between index 4 and 6 and 13 > 9.

Similarly You cannot jump from index 3 to index 2 or index 1.


Example 2:
Input: arr = [3,3,3,3,3], d = 3
Output: 1
Explanation: You can start at any index. You always cannot jump to any index.


Example 3:
Input: arr = [7,6,5,4,3,2,1], d = 1
Output: 7
Explanation: Start at index 0. You can visit all the indicies. 

Example 4:
Input: arr = [7,1,7,1,7,1], d = 2
Output: 2

Example 5:
Input: arr = [66], d = 1
Output: 1

Constraints:
`1 <= arr.length <= 1000`
`1 <= arr[i] <= 10^5`
`1 <= d <= arr.length`",0,,59.3,3.3,https://leetcode.com/problems/jump-game-v,183,11.8K,19.9K,Microsoft,Dynamic Programming,334,13,96,0,
274,1345,Jump Game IV,"Given an array of integers `arr`, you are initially positioned at the first index of the array.

In one step you can jump from index `i` to index:
`i + 1` where: `i + 1 < arr.length`.

`i - 1` where: `i - 1 >= 0`.

`j` where: `arr[i] == arr[j]` and `i != j`.

Return the minimum number of steps to reach the last index of the array.

Notice that you can not jump outside of the array at any time.


Example 1:
Input: arr = [100,-23,-23,404,100,23,23,23,3,404]
Output: 3
Explanation: You need three jumps from index 0 --> 4 --> 3 --> 9. Note that index 9 is the last index of the array.


Example 2:
Input: arr = [7]
Output: 0
Explanation: Start index is the last index. You don't need to jump.


Example 3:
Input: arr = [7,6,9,6,9,6,9,7]
Output: 1
Explanation: You can jump directly from index 0 to index 7 which is last index of the array.


Example 4:
Input: arr = [6,1,9]
Output: 2

Example 5:
Input: arr = [11,22,7,7,7,7,7,7,7,22,13]
Output: 3

Constraints:
`1 <= arr.length <= 5 * 104`
`-108 <= arr[i] <= 108`",0,/articles/jump-game-iv,41.9,42.0,https://leetcode.com/problems/jump-game-iv,253,31.6K,75.3K,"Amazon,Google",Breadth-first Search,588,42,93,1,
275,1349,Maximum Students Taking Exam,"Given a `m * n` matrix `seats`  that represent seats distributions in a classroom. If a seat is broken, it is denoted by `'#'` character otherwise it is denoted by a `'.'` character.

Students can see the answers of those sitting next to the left, right, upper left and upper right, but he cannot see the answers of the student sitting directly in front or behind him. Return the maximum number of students that can take the exam together without any cheating being possible..

Students must be placed in seats in good condition.


Example 1:
Input: seats = [[""#"",""."",""#"",""#"",""."",""#""],
                [""."",""#"",""#"",""#"",""#"","".""],
                [""#"",""."",""#"",""#"",""."",""#""]]
Output: 4
Explanation: Teacher can place 4 students in available seats so they don't cheat on the exam. 

Example 2:
Input: seats = [[""."",""#""],
                [""#"",""#""],
                [""#"","".""],
                [""#"",""#""],
                [""."",""#""]]
Output: 3
Explanation: Place all students in available seats. 

Example 3:
Input: seats = [[""#"",""."",""."",""."",""#""],
                [""."",""#"",""."",""#"","".""],
                [""."",""."",""#"",""."","".""],
                [""."",""#"",""."",""#"","".""],
                [""#"",""."",""."",""."",""#""]]
Output: 10
Explanation: Place students in available seats in column 1, 3 and 5.


Constraints:
`seats` contains only characters `'.' and``'#'.`
`m == seats.length`
`n == seats[i].length`
`1 <= m <= 8`
`1 <= n <= 8`",0,,44.2,12.9,https://leetcode.com/problems/maximum-students-taking-exam,112,7.4K,16.7K,SAP,Dynamic Programming,388,10,97,0,
276,1354,Construct Target Array With Multiple Sums,"Given an array of integers `target`. From a starting array, `A` consisting of all 1's, you may perform the following procedure :
let `x` be the sum of all elements currently in your array.

choose index `i`, such that `0 <= i < target.size` and set the value of `A` at index `i` to `x`.

You may repeat this procedure as many times as needed.

Return True if it is possible to construct the `target` array from `A` otherwise return False.


Example 1:
Input: target = [9,3,5]
Output: true
Explanation: Start with [1, 1, 1] 
[1, 1, 1], sum = 3 choose index 1
[1, 3, 1], sum = 5 choose index 2
[1, 3, 5], sum = 9 choose index 0
[9, 3, 5] Done

Example 2:
Input: target = [1,1,1,2]
Output: false
Explanation: Impossible to create target array from [1,1,1,1].


Example 3:
Input: target = [8,5]
Output: true

Constraints:
`N == target.length`
`1 <= target.length <= 5 * 10^4`
`1 <= target[i] <= 10^9`",0,/articles/construct-target-array-with-multiple-sums,31.3,35.3,https://leetcode.com/problems/construct-target-array-with-multiple-sums,115,8.9K,28.3K,Quora,Greedy,263,35,88,0,
277,1359,Count All Valid Pickup and Delivery Options,"Given `n` orders, each order consist in pickup and delivery services. 
Count all valid pickup/delivery possible sequences such that delivery(i) is always after of pickup(i). 
Since the answer may be too large, return it modulo 10^9 + 7.


Example 1:
Input: n = 1
Output: 1
Explanation: Unique order (P1, D1), Delivery 1 always is after of Pickup 1.


Example 2:
Input: n = 2
Output: 6
Explanation: All possible orders: 
(P1,P2,D1,D2), (P1,P2,D2,D1), (P1,D1,P2,D2), (P2,P1,D1,D2), (P2,P1,D2,D1) and (P2,D2,P1,D1).

This is an invalid order (P1,D2,P2,D1) because Pickup 2 is after of Delivery 2.


Example 3:
Input: n = 3
Output: 90

Constraints:
`1 <= n <= 500`",0,,56.3,53.7,https://leetcode.com/problems/count-all-valid-pickup-and-delivery-options,143,11.6K,20.6K,DoorDash,"Math,Dynamic Programming",287,32,90,0,
278,1363,Largest Multiple of Three,"Given an integer array of `digits`, return the largest multiple of three that can be formed by concatenating some of the given digits in any order.

Since the answer may not fit in an integer data type, return the answer as a string.

If there is no answer return an empty string.


Example 1:
Input: digits = [8,1,9]
Output: ""981""

Example 2:
Input: digits = [8,6,7,1,0]
Output: ""8760""

Example 3:
Input: digits = [1]
Output: """"

Example 4:
Input: digits = [0,0,0,0,0,0]
Output: ""0""

Constraints:
`1 <= digits.length <= 10^4`
`0 <= digits[i] <= 9`
The returning answer must not contain unnecessary leading zeros.",0,,34.1,3.9,https://leetcode.com/problems/largest-multiple-of-three,153,10K,29.4K,Amazon,"Math,Dynamic Programming",244,39,86,1,
279,1368,Minimum Cost to Make at Least One Valid Path in a Grid,"Given a m x n `grid`. Each cell of the `grid` has a sign pointing to the next cell you should visit if you are currently in this cell. The sign of `grid[i][j]` can be:
1 which means go to the cell to the right. (i.e go from `grid[i][j]` to `grid[i][j + 1]`)
2 which means go to the cell to the left. (i.e go from `grid[i][j]` to `grid[i][j - 1]`)
3 which means go to the lower cell. (i.e go from `grid[i][j]` to `grid[i + 1][j]`)
4 which means go to the upper cell. (i.e go from `grid[i][j]` to `grid[i - 1][j]`)
Notice that there could be some invalid signs on the cells of the `grid` which points outside the `grid`.

You will initially start at the upper left cell `(0,0)`. A valid path in the grid is a path which starts from the upper left cell `(0,0)` and ends at the bottom-right cell `(m - 1, n - 1)` following the signs on the grid. The valid path doesn't have to be the shortest.

You can modify the sign on a cell with `cost = 1`. You can modify the sign on a cell one time only.

Return the minimum cost to make the grid have at least one valid path.


Example 1:
Input: grid = [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]
Output: 3
Explanation: You will start at point (0, 0).

The path to (3, 3) is as follows. (0, 0) --> (0, 1) --> (0, 2) --> (0, 3) change the arrow to down with cost = 1 --> (1, 3) --> (1, 2) --> (1, 1) --> (1, 0) change the arrow to down with cost = 1 --> (2, 0) --> (2, 1) --> (2, 2) --> (2, 3) change the arrow to down with cost = 1 --> (3, 3)
The total cost = 3.


Example 2:
Input: grid = [[1,1,3],[3,2,2],[1,1,4]]
Output: 0
Explanation: You can follow the path from (0, 0) to (2, 2).


Example 3:
Input: grid = [[1,2],[4,3]]
Output: 1

Example 4:
Input: grid = [[2,2,2],[2,2,2]]
Output: 3

Example 5:
Input: grid = [[4]]
Output: 0

Constraints:
`m == grid.length`
`n == grid[i].length`
`1 <= m, n <= 100`",0,,57.6,21.1,https://leetcode.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid,179,16.4K,28.4K,Google,Breadth-first Search,513,7,99,1,
280,1369,Get the Second Most Recent Activity,SQL Schema,1,,69.1,2.4,https://leetcode.com/problems/get-the-second-most-recent-activity,173,7K,10.1K,Microsoft,,58,6,91,0,
281,1373,Maximum Sum BST in Binary Tree,"Given a binary tree `root`, the task is to return the maximum sum of all keys of any sub-tree which is also a Binary Search Tree (BST).

Assume a BST is defined as follows:
The left subtree of a node contains only nodes with keys less than the node's key.

The right subtree of a node contains only nodes with keys greater than the node's key.

Both the left and right subtrees must also be binary search trees.


Example 1:
Input: root = [1,4,3,2,4,2,5,null,null,null,null,null,null,4,6]
Output: 20
Explanation: Maximum sum in a valid Binary search tree is obtained in root node with key equal to 3.


Example 2:
Input: root = [4,3,null,1,2]
Output: 2
Explanation: Maximum sum in a valid Binary search tree is obtained in a single root node with key equal to 2.


Example 3:
Input: root = [-4,-2,-5]
Output: 0
Explanation: All values are negatives. Return an empty BST.


Example 4:
Input: root = [2,1,3]
Output: 6

Example 5:
Input: root = [5,4,8,3,null,6,3]
Output: 7

Constraints:
The given binary tree will have between `1` and `40000` nodes.

Each node's value is between `[-4 * 10^4 , 4 * 10^4]`.",0,,37.1,8.0,https://leetcode.com/problems/maximum-sum-bst-in-binary-tree,270,15K,40.4K,Amazon,"Dynamic Programming,Binary Search Tree",407,67,86,1,
282,1377,Frog Position After T Seconds,"Given an undirected tree consisting of `n` vertices numbered from `1` to `n`. A frog starts jumping from vertex 1. In one second, the frog jumps from its current vertex to another unvisited vertex if they are directly connected. The frog can not jump back to a visited vertex. In case the frog can jump to several vertices, it jumps randomly to one of them with the same probability. Otherwise, when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex.

The edges of the undirected tree are given in the array `edges`, where `edges[i] = [ai, bi]` means that exists an edge connecting the vertices `ai` and `bi`.

Return the probability that after `t` seconds the frog is on the vertex `target`.


Example 1:
Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 2, target = 4
Output: 0.16666666666666666 
Explanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 probability to the vertex 2 after second 1 and then jumping with 1/2 probability to vertex 4 after second 2. Thus the probability for the frog is on the vertex 4 after 2 seconds is 1/3 * 1/2 = 1/6 = 0.16666666666666666. 

Example 2:
Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 1, target = 7
Output: 0.3333333333333333
Explanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 = 0.3333333333333333 probability to the vertex 7 after second 1. 

Example 3:
Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 20, target = 6
Output: 0.16666666666666666

Constraints:
`1 <= n <= 100`
`edges.length == n - 1`
`edges[i].length == 2`
`1 <= ai, bi <= n`
`1 <= t <= 50`
`1 <= target <= n`
Answers within `10-5` of the actual value will be accepted as correct.",0,,35.4,3.0,https://leetcode.com/problems/frog-position-after-t-seconds,197,12.6K,35.7K,Google,Depth-first Search,188,69,73,1,
283,1383,Maximum Performance of a Team,"There are `n` engineers numbered from 1 to `n` and two arrays: `speed` and `efficiency`, where `speed[i]` and `efficiency[i]` represent the speed and efficiency for the i-th engineer respectively. Return the maximum performance of a team composed of at most `k` engineers, since the answer can be a huge number, return this modulo 10^9 + 7.

The performance of a team is the sum of their engineers' speeds multiplied by the minimum efficiency among their engineers. 

Example 1:
Input: n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 2
Output: 60
Explanation: 
We have the maximum performance of the team by selecting engineer 2 (with speed=10 and efficiency=4) and engineer 5 (with speed=5 and efficiency=7). That is, performance = (10 + 5) * min(4, 7) = 60.


Example 2:
Input: n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 3
Output: 68
Explanation:
This is the same example as the first but k = 3. We can select engineer 1, engineer 2 and engineer 5 to get the maximum performance of the team. That is, performance = (2 + 10 + 5) * min(5, 4, 7) = 68.


Example 3:
Input: n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 4
Output: 72

Constraints:
`1 <= n <= 10^5`
`speed.length == n`
`efficiency.length == n`
`1 <= speed[i] <= 10^5`
`1 <= efficiency[i] <= 10^8`
`1 <= k <= n`",0,,36.0,57.2,https://leetcode.com/problems/maximum-performance-of-a-team,94,13.4K,37.3K,"DoorDash,Amazon","Greedy,Sort",407,28,94,1,
284,1384,Total Sales Amount by Year,SQL Schema,1,,65.0,0.0,https://leetcode.com/problems/total-sales-amount-by-year,124,5K,7.7K,,,85,33,72,0,
285,1388,Pizza With 3n Slices,"There is a pizza with 3n slices of varying size, you and your friends will take slices of pizza as follows:
You will pick any pizza slice.

Your friend Alice will pick next slice in anti clockwise direction of your pick. 
Your friend Bob will pick next slice in clockwise direction of your pick.

Repeat until there are no more slices of pizzas.

Sizes of Pizza slices is represented by circular array `slices` in clockwise direction.

Return the maximum possible sum of slice sizes which you can have.


Example 1:
Input: slices = [1,2,3,4,5,6]
Output: 10
Explanation: Pick pizza slice of size 4, Alice and Bob will pick slices with size 3 and 5 respectively. Then Pick slices with size 6, finally Alice and Bob will pick slice of size 2 and 1 respectively. Total = 4 + 6.


Example 2:
Input: slices = [8,9,8,6,1,1]
Output: 16
Output: Pick pizza slice of size 8 in each turn. If you pick slice with size 9 your partners will pick slices of size 8.

Example 3:
Input: slices = [4,1,2,5,8,3,1,9,7]
Output: 21

Example 4:
Input: slices = [3,1,2]
Output: 3

Constraints:
`1 <= slices.length <= 500`
`slices.length % 3 == 0`
`1 <= slices[i] <= 1000`",0,,46.2,0.0,https://leetcode.com/problems/pizza-with-3n-slices,63,5.6K,12K,Google,Dynamic Programming,343,5,99,1,
286,1392,Longest Happy Prefix,"A string is called a happy prefix if is a non-empty prefix which is also a suffix (excluding itself).

Given a string `s`. Return the longest happy prefix of `s` .

Return an empty string if no such prefix exists.


Example 1:
Input: s = ""level""
Output: ""l""
Explanation: s contains 4 prefix excluding itself (""l"", ""le"", ""lev"", ""leve""), and suffix (""l"", ""el"", ""vel"", ""evel""). The largest prefix which is also suffix is given by ""l"".


Example 2:
Input: s = ""ababab""
Output: ""abab""
Explanation: ""abab"" is the largest prefix which is also suffix. They can overlap in the original string.


Example 3:
Input: s = ""leetcodeleet""
Output: ""leet""

Example 4:
Input: s = ""a""
Output: """"

Constraints:
`1 <= s.length <= 10^5`
`s` contains only lowercase English letters.",0,,42.0,2.9,https://leetcode.com/problems/longest-happy-prefix,157,12.5K,29.8K,Google,String,330,19,95,1,
287,1397,Find All Good Strings,"Given the strings `s1` and `s2` of size `n`, and the string `evil`. Return the number of good strings.

A good string has size `n`, it is alphabetically greater than or equal to `s1`, it is alphabetically smaller than or equal to `s2`, and it does not contain the string `evil` as a substring. Since the answer can be a huge number, return this modulo 10^9 + 7.


Example 1:
Input: n = 2, s1 = ""aa"", s2 = ""da"", evil = ""b""
Output: 51 
Explanation: There are 25 good strings starting with 'a': ""aa"",""ac"",""ad"",...,""az"". Then there are 25 good strings starting with 'c': ""ca"",""cc"",""cd"",...,""cz"" and finally there is one good string starting with 'd': ""da"". 

Example 2:
Input: n = 8, s1 = ""leetcode"", s2 = ""leetgoes"", evil = ""leet""
Output: 0 
Explanation: All strings greater than or equal to s1 and smaller than or equal to s2 start with the prefix ""leet"", therefore, there is not any good string.


Example 3:
Input: n = 2, s1 = ""gx"", s2 = ""gz"", evil = ""x""
Output: 2

Constraints:
`s1.length == n`
`s2.length == n`
`s1 <= s2`
`1 <= n <= 500`
`1 <= evil.length <= 50`
All strings consist of lowercase English letters.",0,,38.7,0.0,https://leetcode.com/problems/find-all-good-strings,67,2.9K,7.4K,Dunzo,Dynamic Programming,179,90,67,0,
288,1402,Reducing Dishes,"A chef has collected data on the `satisfaction` level of his `n` dishes. Chef can cook any dish in 1 unit of time.

Like-time coefficient of a dish is defined as the time taken to cook that dish including previous dishes multiplied by its satisfaction level  i.e.  `time[i]`*`satisfaction[i]`
Return the maximum sum of Like-time coefficient that the chef can obtain after dishes preparation.

Dishes can be prepared in any order and the chef can discard some dishes to get this maximum value.


Example 1:
Input: satisfaction = [-1,-8,0,5,-9]
Output: 14
Explanation: After Removing the second and last dish, the maximum total Like-time coefficient will be equal to (-1*1 + 0*2 + 5*3 = 14). Each dish is prepared in one unit of time.


Example 2:
Input: satisfaction = [4,3,2]
Output: 20
Explanation: Dishes can be prepared in any order, (2*1 + 3*2 + 4*3 = 20)

Example 3:
Input: satisfaction = [-1,-4,-5]
Output: 0
Explanation: People don't like the dishes. No dish is prepared.


Example 4:
Input: satisfaction = [-2,5,-1,0,3,-3]
Output: 35

Constraints:
`n == satisfaction.length`
`1 <= n <= 500`
`-10^3 <= satisfaction[i] <= 10^3`",0,,72.1,28.3,https://leetcode.com/problems/reducing-dishes,305,20.7K,28.7K,OT,Dynamic Programming,414,89,82,0,
289,1406,Stone Game III,"Alice and Bob continue their games with piles of stones. There are several stones arranged in a row, and each stone has an associated value which is an integer given in the array `stoneValue`.

Alice and Bob take turns, with Alice starting first. On each player's turn, that player can take 1, 2 or 3 stones from the first remaining stones in the row.

The score of each player is the sum of values of the stones taken. The score of each player is 0 initially.

The objective of the game is to end with the highest score, and the winner is the player with the highest score and there could be a tie. The game continues until all the stones have been taken.

Assume Alice and Bob play optimally.

Return ""Alice"" if Alice will win, ""Bob"" if Bob will win or ""Tie"" if they end the game with the same score.


Example 1:
Input: values = [1,2,3,7]
Output: ""Bob""
Explanation: Alice will always lose. Her best move will be to take three piles and the score become 6. Now the score of Bob is 7 and Bob wins.


Example 2:
Input: values = [1,2,3,-9]
Output: ""Alice""
Explanation: Alice must choose all the three piles at the first move to win and leave Bob with negative score.

If Alice chooses one pile her score will be 1 and the next move Bob's score becomes 5. The next move Alice will take the pile with value = -9 and lose.

If Alice chooses two piles her score will be 3 and the next move Bob's score becomes 3. The next move Alice will take the pile with value = -9 and also lose.

Remember that both play optimally so here Alice will choose the scenario that makes her win.


Example 3:
Input: values = [1,2,3,6]
Output: ""Tie""
Explanation: Alice cannot win this game. She can end the game in a draw if she decided to choose all the first three piles, otherwise she will lose.


Example 4:
Input: values = [1,2,3,-1,-2,-3,7]
Output: ""Alice""

Example 5:
Input: values = [-1,-2,-3]
Output: ""Tie""

Constraints:
`1 <= values.length <= 50000`
`-1000 <= values[i] <= 1000`",0,,57.8,11.5,https://leetcode.com/problems/stone-game-iii,183,17.7K,30.5K,Google,Dynamic Programming,521,9,98,1,"[Stone Game V, /problems/stone-game-v/, Hard], [Stone Game VI, /problems/stone-game-vi/, Medium], [Stone Game VII, /problems/stone-game-vii/, Medium]"
290,1411,Number of Ways to Paint N × 3 Grid,"You have a `grid` of size `n x 3` and you want to paint each cell of the grid with exactly one of the three colors: Red, Yellow, or Green while making sure that no two adjacent cells have the same color (i.e., no two cells that share vertical or horizontal sides have the same color).

Given `n` the number of rows of the grid, return the number of ways you can paint this `grid`. As the answer may grow large, the answer must be computed modulo `109 + 7`.


Example 1:
Input: n = 1
Output: 12
Explanation: There are 12 possible way to paint the grid as shown.


Example 2:
Input: n = 2
Output: 54

Example 3:
Input: n = 3
Output: 246

Example 4:
Input: n = 7
Output: 106494

Example 5:
Input: n = 5000
Output: 30228214

Constraints:
`n == grid.length`
`grid[i].length == 3`
`1 <= n <= 5000`",0,,60.5,19.5,https://leetcode.com/problems/number-of-ways-to-paint-n-3-grid,194,15.6K,25.8K,"Akuna Capital,Facebook,Paypal",Dynamic Programming,438,24,95,1,
291,1412,Find the Quiet Students in All Exams,SQL Schema,1,,63.9,15.6,https://leetcode.com/problems/find-the-quiet-students-in-all-exams,242,8.8K,13.8K,,,80,7,92,0,
292,1416,Restore The Array,"A program was supposed to print an array of integers. The program forgot to print whitespaces and the array is printed as a string of digits and all we know is that all integers in the array were in the range `[1, k]` and there are no leading zeros in the array.

Given the string `s` and the integer `k`. There can be multiple ways to restore the array.

Return the number of possible array that can be printed as a string `s` using the mentioned program.

The number of ways could be very large so return it modulo `10^9 + 7`

Example 1:
Input: s = ""1000"", k = 10000
Output: 1
Explanation: The only possible array is [1000]

Example 2:
Input: s = ""1000"", k = 10
Output: 0
Explanation: There cannot be an array that was printed this way and has all integer >= 1 and <= 10.


Example 3:
Input: s = ""1317"", k = 2000
Output: 8
Explanation: Possible arrays are [1317],[131,7],[13,17],[1,317],[13,1,7],[1,31,7],[1,3,17],[1,3,1,7]

Example 4:
Input: s = ""2020"", k = 30
Output: 1
Explanation: The only possible array is [20,20]. [2020] is invalid because 2020 > 30. [2,020] is ivalid because 020 contains leading zeros.


Example 5:
Input: s = ""1234567890"", k = 90
Output: 34

Constraints:
`1 <= s.length <= 10^5`.

`s` consists of only digits and doesn't contain leading zeros.

`1 <= k <= 10^9`.",0,,36.8,9.5,https://leetcode.com/problems/restore-the-array,118,8.6K,23.3K,ByteDance,Dynamic Programming,226,8,97,0,
293,1420,Build Array Where You Can Find The Maximum Exactly K Comparisons,"Given three integers `n`, `m` and `k`. Consider the following algorithm to find the maximum element of an array of positive integers:
You should build the array arr which has the following properties:
`arr` has exactly `n` integers.

`1 <= arr[i] <= m` where `(0 <= i < n)`.

After applying the mentioned algorithm to `arr`, the value `search_cost` is equal to `k`.

Return the number of ways to build the array `arr` under the mentioned conditions. As the answer may grow large, the answer must be computed modulo `10^9 + 7`.


Example 1:
Input: n = 2, m = 3, k = 1
Output: 6
Explanation: The possible arrays are [1, 1], [2, 1], [2, 2], [3, 1], [3, 2] [3, 3]

Example 2:
Input: n = 5, m = 2, k = 3
Output: 0
Explanation: There are no possible arrays that satisify the mentioned conditions.


Example 3:
Input: n = 9, m = 1, k = 1
Output: 1
Explanation: The only possible array is [1, 1, 1, 1, 1, 1, 1, 1, 1]

Example 4:
Input: n = 50, m = 100, k = 25
Output: 34549172
Explanation: Don't forget to compute the answer modulo 1000000007

Example 5:
Input: n = 37, m = 17, k = 7
Output: 418930126

Constraints:
`1 <= n <= 50`
`1 <= m <= 100`
`0 <= k <= n`",0,,64.1,18.6,https://leetcode.com/problems/build-array-where-you-can-find-the-maximum-exactly-k-comparisons,122,7.3K,11.4K,Dunzo,Dynamic Programming,276,7,98,0,
294,1425,Constrained Subsequence Sum,"Given an integer array `nums` and an integer `k`, return the maximum sum of a non-empty subsequence of that array such that for every two consecutive integers in the subsequence, `nums[i]` and `nums[j]`, where `i < j`, the condition `j - i <= k` is satisfied.

A subsequence of an array is obtained by deleting some number of elements (can be zero) from the array, leaving the remaining elements in their original order.


Example 1:
Input: nums = [10,2,-10,5,20], k = 2
Output: 37
Explanation: The subsequence is [10, 2, 5, 20].


Example 2:
Input: nums = [-1,-2,-3], k = 1
Output: -1
Explanation: The subsequence must be non-empty, so we choose the largest number.


Example 3:
Input: nums = [10,-2,-10,-5,20], k = 2
Output: 23
Explanation: The subsequence is [10, -2, -5, 20].


Constraints:
`1 <= k <= nums.length <= 105`
`-104 <= nums[i] <= 104`",0,,45.0,0.0,https://leetcode.com/problems/constrained-subsequence-sum,157,12.1K,27K,Akuna Capital,Dynamic Programming,487,22,96,0,
295,1434,Number of Ways to Wear Different Hats to Each Other,"There are `n` people and 40 types of hats labeled from 1 to 40.

Given a list of list of integers `hats`, where `hats[i]` is a list of all hats preferred by the i-th` person.

Return the number of ways that the n people wear different hats to each other.

Since the answer may be too large, return it modulo `10^9 + 7`.


Example 1:
Input: hats = [[3,4],[4,5],[5]]
Output: 1
Explanation: There is only one way to choose hats given the conditions. 
First person choose hat 3, Second person choose hat 4 and last one hat 5.


Example 2:
Input: hats = [[3,5,1],[3,5]]
Output: 4
Explanation: There are 4 ways to choose hats
(3,5), (5,3), (1,3) and (1,5)

Example 3:
Input: hats = [[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4]]
Output: 24
Explanation: Each person can choose hats labeled from 1 to 4.

Number of Permutations of (1,2,3,4) = 24.


Example 4:
Input: hats = [[1,2,3],[2,3,5,6],[1,3,7,9],[1,8,9],[2,5,7]]
Output: 111

Constraints:
`n == hats.length`
`1 <= n <= 10`
`1 <= hats[i].length <= 40`
`1 <= hats[i][j] <= 40`
`hats[i]` contains a list of unique integers.",0,,39.6,0.0,https://leetcode.com/problems/number-of-ways-to-wear-different-hats-to-each-other,93,6.2K,15.6K,MindTickle,"Dynamic Programming,Bit Manipulation",384,5,99,0,
296,1439,Find the Kth Smallest Sum of a Matrix With Sorted Rows,"You are given an `m * n` matrix, `mat`, and an integer `k`, which has its rows sorted in non-decreasing order.

You are allowed to choose exactly 1 element from each row to form an array. Return the Kth smallest array sum among all possible arrays.


Example 1:
Input: mat = [[1,3,11],[2,4,6]], k = 5
Output: 7
Explanation: Choosing one element from each row, the first k smallest sum are:
[1,2], [1,4], [3,2], [3,4], [1,6]. Where the 5th sum is 7.  

Example 2:
Input: mat = [[1,3,11],[2,4,6]], k = 9
Output: 17

Example 3:
Input: mat = [[1,10,10],[1,4,5],[2,3,6]], k = 7
Output: 9
Explanation: Choosing one element from each row, the first k smallest sum are:
[1,1,2], [1,1,3], [1,4,2], [1,4,3], [1,1,6], [1,5,2], [1,5,3]. Where the 7th sum is 9.  

Example 4:
Input: mat = [[1,1,10],[2,2,9]], k = 7
Output: 12

Constraints:
`m == mat.length`
`n == mat.length[i]`
`1 <= m, n <= 40`
`1 <= k <= min(200, n ^ m)`
`1 <= mat[i][j] <= 5000`
`mat[i]` is a non decreasing array.",0,,60.2,19.3,https://leetcode.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows,152,15.3K,25.4K,Facebook,Heap,485,7,99,1,
297,1444,Number of Ways of Cutting a Pizza,"Given a rectangular pizza represented as a `rows x cols` matrix containing the following characters: `'A'` (an apple) and `'.'` (empty cell) and given the integer `k`. You have to cut the pizza into `k` pieces using `k-1` cuts. 
For each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.

Return the number of ways of cutting the pizza such that each piece contains at least one apple. Since the answer can be a huge number, return this modulo 10^9 + 7.


Example 1:
Input: pizza = [""A.."",""AAA"",""...""], k = 3
Output: 3 
Explanation: The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple.


Example 2:
Input: pizza = [""A.."",""AA."",""...""], k = 3
Output: 1

Example 3:
Input: pizza = [""A.."",""A.."",""...""], k = 1
Output: 1

Constraints:
`1 <= rows, cols <= 50`
`rows == pizza.length`
`cols == pizza[i].length`
`1 <= k <= 10`
`pizza` consists of characters `'A'` and `'.'` only.",0,,53.9,6.0,https://leetcode.com/problems/number-of-ways-of-cutting-a-pizza,133,8.3K,15.5K,Google,Dynamic Programming,302,8,97,1,
298,1449,Form Largest Integer With Digits That Add up to Target,"Given an array of integers `cost` and an integer `target`. Return the maximum integer you can paint under the following rules:
The cost of painting a digit (i+1) is given by `cost[i]` (0 indexed).

The total cost used must be equal to `target`.

Integer does not have digits 0.

Since the answer may be too large, return it as string.

If there is no way to paint any integer given the condition, return ""0"".


Example 1:
Input: cost = [4,3,2,5,6,7,2,5,5], target = 9
Output: ""7772""
Explanation:  The cost to paint the digit '7' is 2, and the digit '2' is 3. Then cost(""7772"") = 2*3+ 3*1 = 9. You could also paint ""977"", but ""7772"" is the largest number.

Digit    cost
  1  ->   4
  2  ->   3
  3  ->   2
  4  ->   5
  5  ->   6
  6  ->   7
  7  ->   2
  8  ->   5
  9  ->   5

Example 2:
Input: cost = [7,6,5,5,5,6,8,7,8], target = 12
Output: ""85""
Explanation: The cost to paint the digit '8' is 7, and the digit '5' is 5. Then cost(""85"") = 7 + 5 = 12.


Example 3:
Input: cost = [2,4,6,2,4,6,4,4,4], target = 5
Output: ""0""
Explanation: It's not possible to paint any integer with total cost equal to target.


Example 4:
Input: cost = [6,10,15,40,40,40,40,40,40], target = 47
Output: ""32211""

Constraints:
`cost.length == 9`
`1 <= cost[i] <= 5000`
`1 <= target <= 5000`",0,,44.3,10.7,https://leetcode.com/problems/form-largest-integer-with-digits-that-add-up-to-target,122,9K,20.2K,Google,"String,Dynamic Programming",332,6,98,1,
299,1453,Maximum Number of Darts Inside of a Circular Dartboard,"You have a very large square wall and a circular dartboard placed on the wall. You have been challenged to throw darts into the board blindfolded. Darts thrown at the wall are represented as an array of `points` on a 2D plane. 
Return the maximum number of points that are within or lie on any circular dartboard of radius `r`.


Example 1:
Input: points = [[-2,0],[2,0],[0,2],[0,-2]], r = 2
Output: 4
Explanation: Circle dartboard with center in (0,0) and radius = 2 contain all points.


Example 2:
Input: points = [[-3,0],[3,0],[2,6],[5,4],[0,9],[7,8]], r = 5
Output: 5
Explanation: Circle dartboard with center in (0,4) and radius = 5 contain all points except the point (7,8).


Example 3:
Input: points = [[-2,0],[2,0],[0,2],[0,-2]], r = 1
Output: 1

Example 4:
Input: points = [[1,2],[3,5],[1,-1],[2,3],[4,1],[1,3]], r = 2
Output: 4

Constraints:
`1 <= points.length <= 100`
`points[i].length == 2`
`-10^4 <= points[i][0], points[i][1] <= 10^4`
`1 <= r <= 5000`",0,,35.5,0.0,https://leetcode.com/problems/maximum-number-of-darts-inside-of-a-circular-dartboard,54,3.9K,11K,Facebook,Geometry,86,210,29,1,
300,1458,Max Dot Product of Two Subsequences,"Given two arrays `nums1` and `nums2`.

Return the maximum dot product between non-empty subsequences of nums1 and nums2 with the same length.

A subsequence of a array is a new array which is formed from the original array by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, `[2,3,5]` is a subsequence of `[1,2,3,4,5]` while `[1,5,3]` is not).


Example 1:
Input: nums1 = [2,1,-2,5], nums2 = [3,0,-6]
Output: 18
Explanation: Take subsequence [2,-2] from nums1 and subsequence [3,-6] from nums2.

Their dot product is (2*3 + (-2)*(-6)) = 18.


Example 2:
Input: nums1 = [3,-2], nums2 = [2,-6,7]
Output: 21
Explanation: Take subsequence [3] from nums1 and subsequence [7] from nums2.

Their dot product is (3*7) = 21.


Example 3:
Input: nums1 = [-1,-1], nums2 = [1,1]
Output: -1
Explanation: Take subsequence [-1] from nums1 and subsequence [1] from nums2.

Their dot product is -1.


Constraints:
`1 <= nums1.length, nums2.length <= 500`
`-1000 <= nums1[i], nums2[i] <= 1000`",0,,43.4,7.0,https://leetcode.com/problems/max-dot-product-of-two-subsequences,210,12.6K,29K,Microsoft,Dynamic Programming,410,10,98,0,
301,1463,Cherry Pickup II,"Given a `rows x cols` matrix `grid` representing a field of cherries. Each cell in `grid` represents the number of cherries that you can collect.

You have two robots that can collect cherries for you, Robot #1 is located at the top-left corner (0,0) , and Robot #2 is located at the top-right corner (0, cols-1) of the grid.

Return the maximum number of cherries collection using both robots  by following the rules below:
From a cell (i,j), robots can move to cell (i+1, j-1) , (i+1, j) or (i+1, j+1).

When any robot is passing through a cell, It picks it up all cherries, and the cell becomes an empty cell (0).

When both robots stay on the same cell, only one of them takes the cherries.

Both robots cannot move outside of the grid at any moment.

Both robots should reach the bottom row in the `grid`.


Example 1:
Input: grid = [[3,1,1],[2,5,1],[1,5,5],[2,1,1]]
Output: 24
Explanation: Path of robot #1 and #2 are described in color green and blue respectively.

Cherries taken by Robot #1, (3 + 2 + 5 + 2) = 12.

Cherries taken by Robot #2, (1 + 5 + 5 + 1) = 12.

Total of cherries: 12 + 12 = 24.


Example 2:
Input: grid = [[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]
Output: 28
Explanation: Path of robot #1 and #2 are described in color green and blue respectively.

Cherries taken by Robot #1, (1 + 9 + 5 + 2) = 17.

Cherries taken by Robot #2, (1 + 3 + 4 + 3) = 11.

Total of cherries: 17 + 11 = 28.


Example 3:
Input: grid = [[1,0,0,3],[0,0,0,3],[0,0,3,3],[9,0,3,3]]
Output: 22

Example 4:
Input: grid = [[1,1],[1,1]]
Output: 4

Constraints:
`rows == grid.length`
`cols == grid[i].length`
`2 <= rows, cols <= 70`
`0 <= grid[i][j] <= 100 `",0,/articles/cherry-pickup-ii,68.8,23.5,https://leetcode.com/problems/cherry-pickup-ii,264,26.3K,38.2K,Google,Dynamic Programming,742,9,99,1,
302,1467,Probability of a Two Boxes Having The Same Number of Distinct Balls,"Given `2n` balls of `k` distinct colors. You will be given an integer array `balls` of size `k` where `balls[i]` is the number of balls of color `i`. 
All the balls will be shuffled uniformly at random, then we will distribute the first `n` balls to the first box and the remaining `n` balls to the other box (Please read the explanation of the second example carefully).

Please note that the two boxes are considered different. For example, if we have two balls of colors `a` and `b`, and two boxes `[]` and `()`, then the distribution `[a] (b)` is considered different than the distribution `[b] (a) `(Please read the explanation of the first example carefully).

We want to calculate the probability that the two boxes have the same number of distinct balls.


Example 1:
Input: balls = [1,1]
Output: 1.00000
Explanation: Only 2 ways to divide the balls equally:
- A ball of color 1 to box 1 and a ball of color 2 to box 2
- A ball of color 2 to box 1 and a ball of color 1 to box 2
In both ways, the number of distinct colors in each box is equal. The probability is 2/2 = 1

Example 2:
Input: balls = [2,1,1]
Output: 0.66667
Explanation: We have the set of balls [1, 1, 2, 3]
This set of balls will be shuffled randomly and we may have one of the 12 distinct shuffles with equale probability (i.e. 1/12):
[1,1 / 2,3], [1,1 / 3,2], [1,2 / 1,3], [1,2 / 3,1], [1,3 / 1,2], [1,3 / 2,1], [2,1 / 1,3], [2,1 / 3,1], [2,3 / 1,1], [3,1 / 1,2], [3,1 / 2,1], [3,2 / 1,1]
After that we add the first two balls to the first box and the second two balls to the second box.

We can see that 8 of these 12 possible random distributions have the same number of distinct colors of balls in each box.

Probability is 8/12 = 0.66667

Example 3:
Input: balls = [1,2,1,2]
Output: 0.60000
Explanation: The set of balls is [1, 2, 2, 3, 4, 4]. It is hard to display all the 180 possible random shuffles of this set but it is easy to check that 108 of them will have the same number of distinct colors in each box.

Probability = 108 / 180 = 0.6

Example 4:
Input: balls = [3,2,1]
Output: 0.30000
Explanation: The set of balls is [1, 1, 1, 2, 2, 3]. It is hard to display all the 60 possible random shuffles of this set but it is easy to check that 18 of them will have the same number of distinct colors in each box.

Probability = 18 / 60 = 0.3

Example 5:
Input: balls = [6,6,6,6,6,6]
Output: 0.90327

Constraints:
`1 <= balls.length <= 8`
`1 <= balls[i] <= 6`
`sum(balls)` is even.

Answers within `10^-5` of the actual value will be accepted as correct.",0,,61.0,14.2,https://leetcode.com/problems/probability-of-a-two-boxes-having-the-same-number-of-distinct-balls,76,5K,8.1K,,,156,119,57,0,
303,1473,Paint House III,"There is a row of `m` houses in a small city, each house must be painted with one of the `n` colors (labeled from `1` to `n`), some houses that have been painted last summer should not be painted again.

A neighborhood is a maximal group of continuous houses that are painted with the same color.

For example: `houses = [1,2,2,3,3,2,1,1]` contains `5` neighborhoods `[{1}, {2,2}, {3,3}, {2}, {1,1}]`.

Given an array `houses`, an `m x n` matrix `cost` and an integer `target` where:
`houses[i]`: is the color of the house `i`, and `0` if the house is not painted yet.

`cost[i][j]`: is the cost of paint the house `i` with the color `j + 1`.

Return the minimum cost of painting all the remaining houses in such a way that there are exactly `target` neighborhoods. If it is not possible, return `-1`.


Example 1:
Input: houses = [0,0,0,0,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3
Output: 9
Explanation: Paint houses of this way [1,2,2,1,1]
This array contains target = 3 neighborhoods, [{1}, {2,2}, {1,1}].

Cost of paint all houses (1 + 1 + 1 + 1 + 5) = 9.


Example 2:
Input: houses = [0,2,1,2,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3
Output: 11
Explanation: Some houses are already painted, Paint the houses of this way [2,2,1,2,2]
This array contains target = 3 neighborhoods, [{2,2}, {1}, {2,2}]. 
Cost of paint the first and last house (10 + 1) = 11.


Example 3:
Input: houses = [0,0,0,0,0], cost = [[1,10],[10,1],[1,10],[10,1],[1,10]], m = 5, n = 2, target = 5
Output: 5

Example 4:
Input: houses = [3,1,2,3], cost = [[1,1,1],[1,1,1],[1,1,1],[1,1,1]], m = 4, n = 3, target = 3
Output: -1
Explanation: Houses are already painted with a total of 4 neighborhoods [{3},{1},{2},{3}] different of target = 3.


Constraints:
`m == houses.length == cost.length`
`n == cost[i].length`
`1 <= m <= 100`
`1 <= n <= 20`
`1 <= target <= m`
`0 <= houses[i] <= n`
`1 <= cost[i][j] <= 10^4`",0,,48.5,18.1,https://leetcode.com/problems/paint-house-iii,164,8.7K,18K,Paypal,Dynamic Programming,335,19,95,0,
304,1478,Allocate Mailboxes,"Given the array `houses` and an integer `k`. where `houses[i]` is the location of the ith house along a street, your task is to allocate `k` mailboxes in the street.

Return the minimum total distance between each house and its nearest mailbox.

The answer is guaranteed to fit in a 32-bit signed integer.


Example 1:
Input: houses = [1,4,8,10,20], k = 3
Output: 5
Explanation: Allocate mailboxes in position 3, 9 and 20.

Minimum total distance from each houses to nearest mailboxes is |3-1| + |4-3| + |9-8| + |10-9| + |20-20| = 5 

Example 2:
Input: houses = [2,3,5,12,18], k = 2
Output: 9
Explanation: Allocate mailboxes in position 3 and 14.

Minimum total distance from each houses to nearest mailboxes is |2-3| + |3-3| + |5-3| + |12-14| + |18-14| = 9.


Example 3:
Input: houses = [7,4,6,1], k = 1
Output: 8

Example 4:
Input: houses = [3,6,14,10], k = 4
Output: 0

Constraints:
`n == houses.length`
`1 <= n <= 100`
`1 <= houses[i] <= 10^4`
`1 <= k <= n`
Array `houses` contain unique integers.",0,,53.8,18.8,https://leetcode.com/problems/allocate-mailboxes,93,8.4K,15.7K,Bloomberg,"Math,Dynamic Programming",428,7,98,0,
305,1479,Sales by Day of the Week,SQL Schema,1,,83.3,6.2,https://leetcode.com/problems/sales-by-day-of-the-week,141,7K,8.4K,Amazon,,56,19,75,1,
306,1483,Kth Ancestor of a Tree Node,"You are given a tree with `n` nodes numbered from `0` to `n-1` in the form of a parent array where `parent[i]` is the parent of node `i`. The root of the tree is node `0`.

Implement the function `getKthAncestor``(int node, int k)` to return the `k`-th ancestor of the given `node`. If there is no such ancestor, return `-1`.

The k-th ancestor of a tree node is the `k`-th node in the path from that node to the root.


Example:
Input:
[""TreeAncestor"",""getKthAncestor"",""getKthAncestor"",""getKthAncestor""]
[[7,[-1,0,0,1,1,2,2]],[3,1],[5,2],[6,3]]
Output:
[null,1,0,-1]
Explanation:
TreeAncestor treeAncestor = new TreeAncestor(7, [-1, 0, 0, 1, 1, 2, 2]);
treeAncestor.getKthAncestor(3, 1);  // returns 1 which is the parent of 3
treeAncestor.getKthAncestor(5, 2);  // returns 0 which is the grandparent of 5
treeAncestor.getKthAncestor(6, 3);  // returns -1 because there is no such ancestor

Constraints:
`1 <= k <= n <= 5*10^4`
`parent[0] == -1` indicating that `0` is the root node.

`0 <= parent[i] < n` for all `0 < i < n`
`0 <= node < n`
There will be at most `5*10^4` queries.",0,,31.4,9.8,https://leetcode.com/problems/kth-ancestor-of-a-tree-node,154,11.7K,37.1K,Google,Dynamic Programming,425,57,88,1,
307,1489,Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree,"Given a weighted undirected connected graph with `n` vertices numbered from `0` to `n - 1`, and an array `edges` where `edges[i] = [ai, bi, weighti]` represents a bidirectional and weighted edge between nodes `ai` and `bi`. A minimum spanning tree (MST) is a subset of the graph's edges that connects all vertices without cycles and with the minimum possible total edge weight.

Find all the critical and pseudo-critical edges in the given graph's minimum spanning tree (MST). An MST edge whose deletion from the graph would cause the MST weight to increase is called a critical edge. On the other hand, a pseudo-critical edge is that which can appear in some MSTs but not all.

Note that you can return the indices of the edges in any order.


Example 1:
Input: n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]
Output: [[0,1],[2,3,4,5]]
Explanation: The figure above describes the graph.

The following figure shows all the possible MSTs:
Notice that the two edges 0 and 1 appear in all MSTs, therefore they are critical edges, so we return them in the first list of the output.

The edges 2, 3, 4, and 5 are only part of some MSTs, therefore they are considered pseudo-critical edges. We add them to the second list of the output.


Example 2:
Input: n = 4, edges = [[0,1,1],[1,2,1],[2,3,1],[0,3,1]]
Output: [[],[0,1,2,3]]
Explanation: We can observe that since all 4 edges have equal weight, choosing any 3 edges from the given 4 will yield an MST. Therefore all 4 edges are pseudo-critical.


Constraints:
`2 <= n <= 100`
`1 <= edges.length <= min(200, n * (n - 1) / 2)`
`edges[i].length == 3`
`0 <= ai < bi < n`
`1 <= weighti <= 1000`
All pairs `(ai, bi)` are distinct.",0,,51.5,0.0,https://leetcode.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree,66,4.5K,8.8K,Amazon,"Depth-first Search,Union Find",222,33,87,1,
308,1494,Parallel Courses II,"Given the integer `n` representing the number of courses at some university labeled from `1` to `n`, and the array `dependencies` where `dependencies[i] = [xi, yi]` represents a prerequisite relationship, that is, the course `xi` must be taken before the course `yi`. Also, you are given the integer `k`.

In one semester you can take at most `k` courses as long as you have taken all the prerequisites for the courses you are taking.

Return the minimum number of semesters to take all courses. It is guaranteed that you can take all courses in some way.


Example 1:
Input: n = 4, dependencies = [[2,1],[3,1],[1,4]], k = 2
Output: 3 
Explanation: The figure above represents the given graph. In this case we can take courses 2 and 3 in the first semester, then take course 1 in the second semester and finally take course 4 in the third semester.


Example 2:
Input: n = 5, dependencies = [[2,1],[3,1],[4,1],[1,5]], k = 2
Output: 4 
Explanation: The figure above represents the given graph. In this case one optimal way to take all courses is: take courses 2 and 3 in the first semester and take course 4 in the second semester, then take course 1 in the third semester and finally take course 5 in the fourth semester.


Example 3:
Input: n = 11, dependencies = [], k = 2
Output: 6

Constraints:
`1 <= n <= 15`
`1 <= k <= n`
`0 <= dependencies.length <= n * (n-1) / 2`
`dependencies[i].length == 2`
`1 <= xi, yi <= n`
`xi != yi`
All prerequisite relationships are distinct, that is, `dependencies[i] != dependencies[j]`.

The given graph is a directed acyclic graph.",0,,31.2,9.3,https://leetcode.com/problems/parallel-courses-ii,146,6.5K,20.8K,Microsoft,Graph,353,28,93,0,"[Parallel Courses, /problems/parallel-courses/, Medium]"
309,1499,Max Value of Equation,"Given an array `points` containing the coordinates of points on a 2D plane, sorted by the x-values, where `points[i] = [xi, yi]` such that `xi < xj` for all `1 <= i < j <= points.length`. You are also given an integer `k`.

Find the maximum value of the equation `yi + yj + |xi - xj|` where `|xi - xj| <= k` and `1 <= i < j <= points.length`. It is guaranteed that there exists at least one pair of points that satisfy the constraint `|xi - xj| <= k`.


Example 1:
Input: points = [[1,3],[2,0],[5,10],[6,-10]], k = 1
Output: 4
Explanation: The first two points satisfy the condition |xi - xj| <= 1 and if we calculate the equation we get 3 + 0 + |1 - 2| = 4. Third and fourth points also satisfy the condition and give a value of 10 + -10 + |5 - 6| = 1.

No other pairs satisfy the condition, so we return the max of 4 and 1.


Example 2:
Input: points = [[0,0],[3,0],[9,2]], k = 3
Output: 3
Explanation: Only the first two points have an absolute difference of 3 or less in the x-values, and give the value of 0 + 0 + |0 - 3| = 3.


Constraints:
`2 <= points.length <= 10^5`
`points[i].length == 2`
`-10^8 <= points[i][0], points[i][1] <= 10^8`
`0 <= k <= 2 * 10^8`
`points[i][0] < points[j][0]` for all `1 <= i < j <= points.length`
`xi` form a strictly increasing sequence.",0,,45.0,26.4,https://leetcode.com/problems/max-value-of-equation,91,11.2K,24.9K,Google,"Array,Sliding Window",349,14,96,1,
310,1505,Minimum Possible Integer After at Most K Adjacent Swaps On Digits,"Given a string `num` representing the digits of a very large integer and an integer `k`.

You are allowed to swap any two adjacent digits of the integer at most `k` times.

Return the minimum integer you can obtain also as a string.


Example 1:
Input: num = ""4321"", k = 4
Output: ""1342""
Explanation: The steps to obtain the minimum integer from 4321 with 4 adjacent swaps are shown.


Example 2:
Input: num = ""100"", k = 1
Output: ""010""
Explanation: It's ok for the output to have leading zeros, but the input is guaranteed not to have any leading zeros.


Example 3:
Input: num = ""36789"", k = 1000
Output: ""36789""
Explanation: We can keep the number without any swaps.


Example 4:
Input: num = ""22"", k = 22
Output: ""22""

Example 5:
Input: num = ""9438957234785635408"", k = 23
Output: ""0345989723478563548""

Constraints:
`1 <= num.length <= 30000`
`num` contains digits only and doesn't have leading zeros.

`1 <= k <= 10^9`",0,,36.4,27.2,https://leetcode.com/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits,95,5.6K,15.2K,Amazon,Greedy,212,14,94,1,
311,1510,Stone Game IV,"Alice and Bob take turns playing a game, with Alice starting first.

Initially, there are `n` stones in a pile.  On each player's turn, that player makes a move consisting of removing any non-zero square number of stones in the pile.

Also, if a player cannot make a move, he/she loses the game.

Given a positive integer `n`. Return `True` if and only if Alice wins the game otherwise return `False`, assuming both players play optimally.


Example 1:
Input: n = 1
Output: true
Explanation: Alice can remove 1 stone winning the game because Bob doesn't have any moves.


Example 2:
Input: n = 2
Output: false
Explanation: Alice can only remove 1 stone, after that Bob removes the last one winning the game (2 -> 1 -> 0).


Example 3:
Input: n = 4
Output: true
Explanation: n is already a perfect square, Alice can win with one move, removing 4 stones (4 -> 0).


Example 4:
Input: n = 7
Output: false
Explanation: Alice can't win the game if Bob plays optimally.

If Alice starts removing 4 stones, Bob will remove 1 stone then Alice should remove only 1 stone and finally Bob removes the last one (7 -> 3 -> 2 -> 1 -> 0). 
If Alice starts removing 1 stone, Bob will remove 4 stones then Alice only can remove 1 stone and finally Bob removes the last one (7 -> 6 -> 2 -> 1 -> 0).


Example 5:
Input: n = 17
Output: false
Explanation: Alice can't win the game if Bob plays optimally.


Constraints:
`1 <= n <= 10^5`",0,/articles/stone-game-iv,58.9,2.7,https://leetcode.com/problems/stone-game-iv,245,26.6K,45K,Microsoft,Dynamic Programming,403,25,94,0,"[Stone Game V, /problems/stone-game-v/, Hard], [Stone Game VI, /problems/stone-game-vi/, Medium], [Stone Game VII, /problems/stone-game-vii/, Medium]"
312,1515,Best Position for a Service Centre,"A delivery company wants to build a new service centre in a new city. The company knows the positions of all the customers in this city on a 2D-Map and wants to build the new centre in a position such that the sum of the euclidean distances to all customers is minimum.

Given an array `positions` where `positions[i] = [xi, yi]` is the position of the `ith` customer on the map, return the minimum sum of the euclidean distances to all customers.

In other words, you need to choose the position of the service centre `[xcentre, ycentre]` such that the following formula is minimized:
Answers within `10^-5` of the actual value will be accepted.


Example 1:
Input: positions = [[0,1],[1,0],[1,2],[2,1]]
Output: 4.00000
Explanation: As shown, you can see that choosing [xcentre, ycentre] = [1, 1] will make the distance to each customer = 1, the sum of all distances is 4 which is the minimum possible we can achieve.


Example 2:
Input: positions = [[1,1],[3,3]]
Output: 2.82843
Explanation: The minimum possible sum of distances = sqrt(2) + sqrt(2) = 2.82843

Example 3:
Input: positions = [[1,1]]
Output: 0.00000

Example 4:
Input: positions = [[1,1],[0,0],[2,0]]
Output: 2.73205
Explanation: At the first glance, you may think that locating the centre at [1, 0] will achieve the minimum sum, but locating it at [1, 0] will make the sum of distances = 3.

Try to locate the centre at [1.0, 0.5773502711] you will see that the sum of distances is 2.73205.

Be careful with the precision!

Example 5:
Input: positions = [[0,1],[3,2],[4,5],[7,6],[8,9],[11,1],[2,12]]
Output: 32.94036
Explanation: You can use [4.3460852395, 4.9813795505] as the position of the centre.


Constraints:
`1 <= positions.length <= 50`
`positions[i].length == 2`
`0 <= positions[i][0], positions[i][1] <= 100`",0,,38.3,31.8,https://leetcode.com/problems/best-position-for-a-service-centre,96,6.3K,16.4K,"Reddit,Uber",Geometry,109,146,43,0,
313,1516,Move Sub-Tree of N-Ary Tree,"Given the `root` of an N-ary tree of unique values, and two nodes of the tree `p` and `q`.

You should move the subtree of the node `p` to become a direct child of node `q`. If `p` is already a direct child of `q`, don't change anything. Node `p` must be the last child in the children list of node `q`.

Return the root of the tree after adjusting it.

There are 3 cases for nodes `p` and `q`:
Node `q` is in the sub-tree of node `p`.

Node `p` is in the sub-tree of node `q`.

Neither node `p` is in the sub-tree of node `q` nor node `q` is in the sub-tree of node `p`.

In cases 2 and 3, you just need to move `p` (with its sub-tree) to be a child of `q`, but in case 1 the tree may be disconnected, thus you need to reconnect the tree again. Please read the examples carefully before solving this problem.

Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).

For example, the above tree is serialized as [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14].


Example 1:
Input: root = [1,null,2,3,null,4,5,null,6,null,7,8], p = 4, q = 1
Output: [1,null,2,3,4,null,5,null,6,null,7,8]
Explanation: This example follows the second case as node p is in the sub-tree of node q. We move node p with its sub-tree to be a direct child of node q.

Notice that node 4 is the last child of node 1.


Example 2:
Input: root = [1,null,2,3,null,4,5,null,6,null,7,8], p = 7, q = 4
Output: [1,null,2,3,null,4,5,null,6,null,7,8]
Explanation: Node 7 is already a direct child of node 4. We don't change anything.


Example 3:
Input: root = [1,null,2,3,null,4,5,null,6,null,7,8], p = 3, q = 8
Output: [1,null,2,null,4,5,null,7,8,null,null,null,3,null,6]
Explanation: This example follows case 3 because node p is not in the sub-tree of node q and vice-versa. We can move node 3 with its sub-tree and make it as node 8's child.


Example 4:
Input: root = [1,null,2,3,null,4,5,null,6,null,7,8], p = 2, q = 7
Output: [1,null,7,3,null,2,null,6,null,4,5,null,null,8]
Explanation: Node q is in the sub-tree of node p, so this is case 1.

The first step, we move node p (with all of its sub-tree except for node q) and add it as a child to node q.

Then we will see that the tree is disconnected, you need to reconnect node q to replace node p as shown.


Example 5:
Input: root = [1,null,2,3,null,4,5,null,6,null,7,8], p = 1, q = 2
Output: [2,null,4,5,1,null,7,8,null,null,3,null,null,null,6]
Explanation: Node q is in the sub-tree of node p, so this is case 1.

The first step, we move node p (with all of its sub-tree except for node q) and add it as a child to node q.

As node p was the root of the tree, node q replaces it and becomes the root of the tree.


Constraints:
The total number of nodes is between `[2, 1000]`.

Each node has a unique value.

`p != null`
`q != null`
`p` and `q` are two different nodes (i.e. `p != q`).",1,,64.2,0.0,https://leetcode.com/problems/move-sub-tree-of-n-ary-tree,25,1.2K,1.9K,Google,Tree,13,28,32,1,"[Find Root of N-Ary Tree, /problems/find-root-of-n-ary-tree/, Medium]"
314,1520,Maximum Number of Non-Overlapping Substrings,"Given a string `s` of lowercase letters, you need to find the maximum number of non-empty substrings of `s` that meet the following conditions:
The substrings do not overlap, that is for any two substrings `s[i..j]` and `s[k..l]`, either `j < k` or `i > l` is true.

A substring that contains a certain character `c` must also contain all occurrences of `c`.

Find the maximum number of substrings that meet the above conditions. If there are multiple solutions with the same number of substrings, return the one with minimum total length. It can be shown that there exists a unique solution of minimum total length.

Notice that you can return the substrings in any order.


Example 1:
Input: s = ""adefaddaccc""
Output: [""e"",""f"",""ccc""]
Explanation: The following are all the possible substrings that meet the conditions:
[
  ""adefaddaccc""
  ""adefadda"",
  ""ef"",
  ""e"",
  ""f"",
  ""ccc"",
]
If we choose the first string, we cannot choose anything else and we'd get only 1. If we choose ""adefadda"", we are left with ""ccc"" which is the only one that doesn't overlap, thus obtaining 2 substrings. Notice also, that it's not optimal to choose ""ef"" since it can be split into two. Therefore, the optimal way is to choose [""e"",""f"",""ccc""] which gives us 3 substrings. No other solution of the same number of substrings exist.


Example 2:
Input: s = ""abbaccd""
Output: [""d"",""bb"",""cc""]
Explanation: Notice that while the set of substrings [""d"",""abba"",""cc""] also has length 3, it's considered incorrect since it has larger total length.


Constraints:
`1 <= s.length <= 10^5`
`s` contains only lowercase English letters.",0,,36.5,0.0,https://leetcode.com/problems/maximum-number-of-non-overlapping-substrings,90,8.1K,22.3K,Amazon,Greedy,341,46,88,1,
315,1521,Find a Value of a Mysterious Function Closest to Target,"Winston was given the above mysterious function `func`. He has an integer array `arr` and an integer `target` and he wants to find the values `l` and `r` that make the value `|func(arr, l, r) - target|` minimum possible.

Return the minimum possible value of `|func(arr, l, r) - target|`.

Notice that `func` should be called with the values `l` and `r` where `0 <= l, r < arr.length`.


Example 1:
Input: arr = [9,12,3,7,15], target = 5
Output: 2
Explanation: Calling func with all the pairs of [l,r] = [[0,0],[1,1],[2,2],[3,3],[4,4],[0,1],[1,2],[2,3],[3,4],[0,2],[1,3],[2,4],[0,3],[1,4],[0,4]], Winston got the following results [9,12,3,7,15,8,0,3,7,0,0,3,0,0,0]. The value closest to 5 is 7 and 3, thus the minimum difference is 2.


Example 2:
Input: arr = [1000000,1000000,1000000], target = 1
Output: 999999
Explanation: Winston called the func with all possible values of [l,r] and he always got 1000000, thus the min difference is 999999.


Example 3:
Input: arr = [1,2,4,8,16], target = 0
Output: 0

Constraints:
`1 <= arr.length <= 105`
`1 <= arr[i] <= 106`
`0 <= target <= 107`",0,,44.2,0.0,https://leetcode.com/problems/find-a-value-of-a-mysterious-function-closest-to-target,78,6.1K,13.7K,American Express,"Binary Search,Bit Manipulation,Segment Tree",200,8,96,0,
316,1526,Minimum Number of Increments on Subarrays to Form a Target Array,"Given an array of positive integers `target` and an array `initial` of same size with all zeros.

Return the minimum number of operations to form a `target` array from `initial` if you are allowed to do the following operation:
Choose any subarray from `initial` and increment each value by one.

The answer is guaranteed to fit within the range of a 32-bit signed integer.


Example 1:
Input: target = [1,2,3,2,1]
Output: 3
Explanation: We need at least 3 operations to form the target array from the initial array.

[0,0,0,0,0] increment 1 from index 0 to 4 (inclusive).

[1,1,1,1,1] increment 1 from index 1 to 3 (inclusive).

[1,2,2,2,1] increment 1 at index 2.

[1,2,3,2,1] target array is formed.


Example 2:
Input: target = [3,1,1,2]
Output: 4
Explanation: (initial)[0,0,0,0] -> [1,1,1,1] -> [1,1,1,2] -> [2,1,1,2] -> [3,1,1,2] (target).


Example 3:
Input: target = [3,1,5,4,2]
Output: 7
Explanation: (initial)[0,0,0,0,0] -> [1,1,1,1,1] -> [2,1,1,1,1] -> [3,1,1,1,1] 
                                  -> [3,1,2,2,2] -> [3,1,3,3,2] -> [3,1,4,4,2] -> [3,1,5,4,2] (target).


Example 4:
Input: target = [1,1,1,1]
Output: 1

Constraints:
`1 <= target.length <= 10^5`
`1 <= target[i] <= 10^5`",0,,60.3,0.0,https://leetcode.com/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array,131,7.9K,13.1K,Google,Segment Tree,302,17,95,1,
317,1531,String Compression II,"Run-length encoding is a string compression method that works by replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string `""aabccc""` we replace `""aa""` by `""a2""` and replace `""ccc""` by `""c3""`. Thus the compressed string becomes `""a2bc3""`.

Notice that in this problem, we are not adding `'1'` after single characters.

Given a string `s` and an integer `k`. You need to delete at most `k` characters from `s` such that the run-length encoded version of `s` has minimum length.

Find the minimum length of the run-length encoded version of `s` after deleting at most `k` characters.


Example 1:
Input: s = ""aaabcccd"", k = 2
Output: 4
Explanation: Compressing s without deleting anything will give us ""a3bc3d"" of length 6. Deleting any of the characters 'a' or 'c' would at most decrease the length of the compressed string to 5, for instance delete 2 'a' then we will have s = ""abcccd"" which compressed is abc3d. Therefore, the optimal way is to delete 'b' and 'd', then the compressed version of s will be ""a3c3"" of length 4.


Example 2:
Input: s = ""aabbaa"", k = 2
Output: 2
Explanation: If we delete both 'b' characters, the resulting compressed string would be ""a4"" of length 2.


Example 3:
Input: s = ""aaaaaaaaaaa"", k = 0
Output: 3
Explanation: Since k is zero, we cannot delete anything. The compressed string is ""a11"" of length 3.


Constraints:
`1 <= s.length <= 100`
`0 <= k <= s.length`
`s` contains only lowercase English letters.",0,,34.1,61.4,https://leetcode.com/problems/string-compression-ii,62,6.4K,18.7K,Toptal,"String,Dynamic Programming",286,29,91,0,
318,1537,Get the Maximum Score,"You are given two sorted arrays of distinct integers `nums1` and `nums2.`
A valid path is defined as follows:
Choose array nums1 or nums2 to traverse (from index-0).

Traverse the current array from left to right.

If you are reading any value that is present in `nums1` and `nums2` you are allowed to change your path to the other array. (Only one repeated value is considered in the valid path).

Score is defined as the sum of uniques values in a valid path.

Return the maximum score you can obtain of all possible valid paths.

Since the answer may be too large, return it modulo 10^9 + 7.


Example 1:
Input: nums1 = [2,4,5,8,10], nums2 = [4,6,8,9]
Output: 30
Explanation: Valid paths:
[2,4,5,8,10], [2,4,5,8,9], [2,4,6,8,9], [2,4,6,8,10],  (starting from nums1)
[4,6,8,9], [4,5,8,10], [4,5,8,9], [4,6,8,10]    (starting from nums2)
The maximum is obtained with the path in green [2,4,6,8,10].


Example 2:
Input: nums1 = [1,3,5,7,9], nums2 = [3,5,100]
Output: 109
Explanation: Maximum sum is obtained with the path [1,3,5,100].


Example 3:
Input: nums1 = [1,2,3,4,5], nums2 = [6,7,8,9,10]
Output: 40
Explanation: There are no common elements between nums1 and nums2.

Maximum sum is obtained with the path [6,7,8,9,10].


Example 4:
Input: nums1 = [1,4,5,8,9,11,19], nums2 = [2,3,4,11,12]
Output: 61

Constraints:
`1 <= nums1.length <= 10^5`
`1 <= nums2.length <= 10^5`
`1 <= nums1[i], nums2[i] <= 10^7`
`nums1` and `nums2` are strictly increasing.",0,,36.6,5.8,https://leetcode.com/problems/get-the-maximum-score,159,10K,27.2K,MindTickle,Dynamic Programming,324,22,94,0,
319,1542,Find Longest Awesome Substring,"Given a string `s`. An awesome substring is a non-empty substring of `s` such that we can make any number of swaps in order to make it palindrome.

Return the length of the maximum length awesome substring of `s`.


Example 1:
Input: s = ""3242415""
Output: 5
Explanation: ""24241"" is the longest awesome substring, we can form the palindrome ""24142"" with some swaps.


Example 2:
Input: s = ""12345678""
Output: 1

Example 3:
Input: s = ""213123""
Output: 6
Explanation: ""213123"" is the longest awesome substring, we can form the palindrome ""231132"" with some swaps.


Example 4:
Input: s = ""00""
Output: 2

Constraints:
`1 <= s.length <= 10^5`
`s` consists only of digits.",0,,36.7,0.0,https://leetcode.com/problems/find-longest-awesome-substring,57,5.6K,15.2K,Directi,"String,Bit Manipulation",317,7,98,0,
320,1547,Minimum Cost to Cut a Stick,"Given a wooden stick of length `n` units. The stick is labelled from `0` to `n`. For example, a stick of length 6 is labelled as follows:
Given an integer array `cuts` where `cuts[i]` denotes a position you should perform a cut at.

You should perform the cuts in order, you can change the order of the cuts as you wish.

The cost of one cut is the length of the stick to be cut, the total cost is the sum of costs of all cuts. When you cut a stick, it will be split into two smaller sticks (i.e. the sum of their lengths is the length of the stick before the cut). Please refer to the first example for a better explanation.

Return the minimum total cost of the cuts.


Example 1:
Input: n = 7, cuts = [1,3,4,5]
Output: 16
Explanation: Using cuts order = [1, 3, 4, 5] as in the input leads to the following scenario:
The first cut is done to a rod of length 7 so the cost is 7. The second cut is done to a rod of length 6 (i.e. the second part of the first cut), the third is done to a rod of length 4 and the last cut is to a rod of length 3. The total cost is 7 + 6 + 4 + 3 = 20.

Rearranging the cuts to be [3, 5, 1, 4] for example will lead to a scenario with total cost = 16 (as shown in the example photo 7 + 4 + 3 + 2 = 16).


Example 2:
Input: n = 9, cuts = [5,6,1,4,2]
Output: 22
Explanation: If you try the given cuts ordering the cost will be 25.

There are much ordering with total cost <= 25, for example, the order [4, 6, 5, 2, 1] has total cost = 22 which is the minimum possible.


Constraints:
`2 <= n <= 10^6`
`1 <= cuts.length <= min(n - 1, 100)`
`1 <= cuts[i] <= n - 1`
All the integers in `cuts` array are distinct.",0,,52.9,15.2,https://leetcode.com/problems/minimum-cost-to-cut-a-stick,128,10.7K,20.3K,Google,Dynamic Programming,415,7,98,1,
321,1548,The Most Similar Path in a Graph,"We have `n` cities and `m` bi-directional `roads` where `roads[i] = [ai, bi]` connects city `ai` with city `bi`. Each city has a name consisting of exactly 3 upper-case English letters given in the string array `names`. Starting at any city `x`, you can reach any city `y` where `y != x` (i.e. the cities and the roads are forming an undirected connected graph).

You will be given a string array `targetPath`. You should find a path in the graph of the same length and with the minimum edit distance to `targetPath`.

You need to return the order of the nodes in the path with the minimum edit distance, The path should be of the same length of `targetPath` and should be valid (i.e. there should be a direct road between `ans[i]` and `ans[i + 1]`). If there are multiple answers return any one of them.

The edit distance is defined as follows:
Follow-up: If each node can be visited only once in the path, What should you change in your solution?

Example 1:
Input: n = 5, roads = [[0,2],[0,3],[1,2],[1,3],[1,4],[2,4]], names = [""ATL"",""PEK"",""LAX"",""DXB"",""HND""], targetPath = [""ATL"",""DXB"",""HND"",""LAX""]
Output: [0,2,4,2]
Explanation: [0,2,4,2], [0,3,0,2] and [0,3,1,2] are accepted answers.

[0,2,4,2] is equivalent to [""ATL"",""LAX"",""HND"",""LAX""] which has edit distance = 1 with targetPath.

[0,3,0,2] is equivalent to [""ATL"",""DXB"",""ATL"",""LAX""] which has edit distance = 1 with targetPath.

[0,3,1,2] is equivalent to [""ATL"",""DXB"",""PEK"",""LAX""] which has edit distance = 1 with targetPath.


Example 2:
Input: n = 4, roads = [[1,0],[2,0],[3,0],[2,1],[3,1],[3,2]], names = [""ATL"",""PEK"",""LAX"",""DXB""], targetPath = [""ABC"",""DEF"",""GHI"",""JKL"",""MNO"",""PQR"",""STU"",""VWX""]
Output: [0,1,0,1,0,1,0,1]
Explanation: Any path in this graph has edit distance = 8 with targetPath.


Example 3:
Input: n = 6, roads = [[0,1],[1,2],[2,3],[3,4],[4,5]], names = [""ATL"",""PEK"",""LAX"",""ATL"",""DXB"",""HND""], targetPath = [""ATL"",""DXB"",""HND"",""DXB"",""ATL"",""LAX"",""PEK""]
Output: [3,4,5,4,3,2,1]
Explanation: [3,4,5,4,3,2,1] is the only path with edit distance = 0 with targetPath.

It's equivalent to [""ATL"",""DXB"",""HND"",""DXB"",""ATL"",""LAX"",""PEK""]

Constraints:
`2 <= n <= 100`
`m == roads.length`
`n - 1 <= m <= (n * (n - 1) / 2)`
`0 <= ai, bi <= n - 1`
`ai != bi `
The graph is guaranteed to be connected and each pair of nodes may have at most one direct road.

`names.length == n`
`names[i].length == 3`
`names[i]` consists of upper-case English letters.

There can be two cities with the same name.

`1 <= targetPath.length <= 100`
`targetPath[i].length == 3`
`targetPath[i]` consists of upper-case English letters.",1,,54.5,4.0,https://leetcode.com/problems/the-most-similar-path-in-a-graph,62,5.7K,10.5K,Google,"Dynamic Programming,Graph",133,64,68,1,
322,1553,Minimum Number of Days to Eat N Oranges,"There are `n` oranges in the kitchen and you decided to eat some of these oranges every day as follows:
Eat one orange.

If the number of remaining oranges (`n`) is divisible by 2 then you can eat  n/2 oranges.

If the number of remaining oranges (`n`) is divisible by 3 then you can eat  2*(n/3) oranges.

You can only choose one of the actions per day.

Return the minimum number of days to eat `n` oranges.


Example 1:
Input: n = 10
Output: 4
Explanation: You have 10 oranges.

Day 1: Eat 1 orange,  10 - 1 = 9.  
Day 2: Eat 6 oranges, 9 - 2*(9/3) = 9 - 6 = 3. (Since 9 is divisible by 3)
Day 3: Eat 2 oranges, 3 - 2*(3/3) = 3 - 2 = 1. 
Day 4: Eat the last orange  1 - 1  = 0.

You need at least 4 days to eat the 10 oranges.


Example 2:
Input: n = 6
Output: 3
Explanation: You have 6 oranges.

Day 1: Eat 3 oranges, 6 - 6/2 = 6 - 3 = 3. (Since 6 is divisible by 2).

Day 2: Eat 2 oranges, 3 - 2*(3/3) = 3 - 2 = 1. (Since 3 is divisible by 3)
Day 3: Eat the last orange  1 - 1  = 0.

You need at least 3 days to eat the 6 oranges.


Example 3:
Input: n = 1
Output: 1

Example 4:
Input: n = 56
Output: 6

Constraints:
`1 <= n <= 2*10^9`",0,,29.9,19.1,https://leetcode.com/problems/minimum-number-of-days-to-eat-n-oranges,163,14.3K,48K,Google,Dynamic Programming,403,32,93,1,
323,1559,Detect Cycles in 2D Grid,"Given a 2D array of characters `grid` of size `m x n`, you need to find if there exists any cycle consisting of the same value in `grid`.

A cycle is a path of length 4 or more in the grid that starts and ends at the same cell. From a given cell, you can move to one of the cells adjacent to it - in one of the four directions (up, down, left, or right), if it has the same value of the current cell.

Also, you cannot move to the cell that you visited in your last move. For example, the cycle `(1, 1) -> (1, 2) -> (1, 1)` is invalid because from `(1, 2)` we visited `(1, 1)` which was the last visited cell.

Return `true` if any cycle of the same value exists in `grid`, otherwise, return `false`.


Example 1:
Input: grid = [[""a"",""a"",""a"",""a""],[""a"",""b"",""b"",""a""],[""a"",""b"",""b"",""a""],[""a"",""a"",""a"",""a""]]
Output: true
Explanation: There are two valid cycles shown in different colors in the image below:

Example 2:
Input: grid = [[""c"",""c"",""c"",""a""],[""c"",""d"",""c"",""c""],[""c"",""c"",""e"",""c""],[""f"",""c"",""c"",""c""]]
Output: true
Explanation: There is only one valid cycle highlighted in the image below:

Example 3:
Input: grid = [[""a"",""b"",""b""],[""b"",""z"",""b""],[""b"",""b"",""a""]]
Output: false

Constraints:
`m == grid.length`
`n == grid[i].length`
`1 <= m <= 500`
`1 <= n <= 500`
`grid` consists only of lowercase English letters.",0,,44.6,6.8,https://leetcode.com/problems/detect-cycles-in-2d-grid,191,9.7K,21.7K,Amazon,Depth-first Search,266,9,97,1,
324,1563,Stone Game V,"There are several stones arranged in a row, and each stone has an associated value which is an integer given in the array `stoneValue`.

In each round of the game, Alice divides the row into two non-empty rows (i.e. left row and right row), then Bob calculates the value of each row which is the sum of the values of all the stones in this row. Bob throws away the row which has the maximum value, and Alice's score increases by the value of the remaining row. If the value of the two rows are equal, Bob lets Alice decide which row will be thrown away. The next round starts with the remaining row.

The game ends when there is only one stone remaining. Alice's is initially zero.

Return the maximum score that Alice can obtain.


Example 1:
Input: stoneValue = [6,2,3,4,5,5]
Output: 18
Explanation: In the first round, Alice divides the row to [6,2,3], [4,5,5]. The left row has the value 11 and the right row has value 14. Bob throws away the right row and Alice's score is now 11.

In the second round Alice divides the row to [6], [2,3]. This time Bob throws away the left row and Alice's score becomes 16 (11 + 5).

The last round Alice has only one choice to divide the row which is [2], [3]. Bob throws away the right row and Alice's score is now 18 (16 + 2). The game ends because only one stone is remaining in the row.


Example 2:
Input: stoneValue = [7,7,7,7,7,7,7]
Output: 28

Example 3:
Input: stoneValue = [4]
Output: 0

Constraints:
`1 <= stoneValue.length <= 500`
`1 <= stoneValue[i] <= 10^6`",0,,40.0,3.2,https://leetcode.com/problems/stone-game-v,135,8.6K,21.4K,,,203,45,82,0,
325,1568,Minimum Number of Days to Disconnect Island,"Given a 2D `grid` consisting of `1`s (land) and `0`s (water).  An island is a maximal 4-directionally (horizontal or vertical) connected group of `1`s.

The grid is said to be connected if we have exactly one island, otherwise is said disconnected.

In one day, we are allowed to change any single land cell `(1)` into a water cell `(0)`.

Return the minimum number of days to disconnect the grid.


Example 1:
Input: grid = [[0,1,1,0],[0,1,1,0],[0,0,0,0]]
Output: 2
Explanation: We need at least 2 days to get a disconnected grid.

Change land grid[1][1] and grid[0][2] to water and get 2 disconnected island.


Example 2:
Input: grid = [[1,1]]
Output: 2
Explanation: Grid of full water is also disconnected ([[1,1]] -> [[0,0]]), 0 islands.


Example 3:
Input: grid = [[1,0,1,0]]
Output: 0

Example 4:
Input: grid = [[1,1,0,1,1],
               [1,1,1,1,1],
               [1,1,0,1,1],
               [1,1,0,1,1]]
Output: 1

Example 5:
Input: grid = [[1,1,0,1,1],
               [1,1,1,1,1],
               [1,1,0,1,1],
               [1,1,1,1,1]]
Output: 2

Constraints:
`1 <= grid.length, grid[i].length <= 30`
`grid[i][j]` is `0` or `1`.",0,,50.2,8.5,https://leetcode.com/problems/minimum-number-of-days-to-disconnect-island,86,5.7K,11.4K,Unacademy,Greedy,180,97,65,0,
326,1569,Number of Ways to Reorder Array to Get Same BST,"Given an array `nums` that represents a permutation of integers from `1` to `n`. We are going to construct a binary search tree (BST) by inserting the elements of `nums` in order into an initially empty BST. Find the number of different ways to reorder `nums` so that the constructed BST is identical to that formed from the original array `nums`.

For example, given `nums = [2,1,3]`, we will have 2 as the root, 1 as a left child, and 3 as a right child. The array `[2,3,1]` also yields the same BST but `[3,2,1]` yields a different BST.

Return the number of ways to reorder `nums` such that the BST formed is identical to the original BST formed from `nums`.

Since the answer may be very large, return it modulo `10^9 + 7`.


Example 1:
Input: nums = [2,1,3]
Output: 1
Explanation: We can reorder nums to be [2,3,1] which will yield the same BST. There are no other ways to reorder nums which will yield the same BST.


Example 2:
Input: nums = [3,4,5,1,2]
Output: 5
Explanation: The following 5 arrays will yield the same BST: 
[3,1,2,4,5]
[3,1,4,2,5]
[3,1,4,5,2]
[3,4,1,2,5]
[3,4,1,5,2]

Example 3:
Input: nums = [1,2,3]
Output: 0
Explanation: There are no other orderings of nums that will yield the same BST.


Example 4:
Input: nums = [3,1,2,5,4,6]
Output: 19

Example 5:
Input: nums = [9,4,2,1,3,6,5,7,8,14,11,10,12,13,16,15,17,18]
Output: 216212978
Explanation: The number of ways to reorder nums to get the same BST is 3216212999. Taking this number modulo 10^9 + 7 gives 216212978.


Constraints:
`1 <= nums.length <= 1000`
`1 <= nums[i] <= nums.length`
All integers in `nums` are distinct.",0,,50.0,35.1,https://leetcode.com/problems/number-of-ways-to-reorder-array-to-get-same-bst,84,5.3K,10.7K,Google,Dynamic Programming,179,25,88,1,
327,1575,Count All Possible Routes,"You are given an array of distinct positive integers locations where `locations[i]` represents the position of city `i`. You are also given integers `start`, `finish` and `fuel` representing the starting city, ending city, and the initial amount of fuel you have, respectively.

At each step, if you are at city `i`, you can pick any city `j` such that `j != i` and `0 <= j < locations.length` and move to city `j`. Moving from city `i` to city `j` reduces the amount of fuel you have by `|locations[i] - locations[j]|`. Please notice that `|x|` denotes the absolute value of `x`.

Notice that `fuel` cannot become negative at any point in time, and that you are allowed to visit any city more than once (including `start` and `finish`).

Return the count of all possible routes from `start` to `finish`.

Since the answer may be too large, return it modulo `10^9 + 7`.


Example 1:
Input: locations = [2,3,6,8,4], start = 1, finish = 3, fuel = 5
Output: 4
Explanation: The following are all possible routes, each uses 5 units of fuel:
1 -> 3
1 -> 2 -> 3
1 -> 4 -> 3
1 -> 4 -> 2 -> 3

Example 2:
Input: locations = [4,3,1], start = 1, finish = 0, fuel = 6
Output: 5
Explanation: The following are all possible routes:
1 -> 0, used fuel = 1
1 -> 2 -> 0, used fuel = 5
1 -> 2 -> 1 -> 0, used fuel = 5
1 -> 0 -> 1 -> 0, used fuel = 3
1 -> 0 -> 1 -> 0 -> 1 -> 0, used fuel = 5

Example 3:
Input: locations = [5,2,1], start = 0, finish = 2, fuel = 3
Output: 0
Explanation: It's impossible to get from 0 to 2 using only 3 units of fuel since the shortest route needs 4 units of fuel.


Example 4:
Input: locations = [2,1,5], start = 0, finish = 0, fuel = 3
Output: 2
Explanation: There are two possible routes, 0 and 0 -> 1 -> 0.


Example 5:
Input: locations = [1,2,3], start = 0, finish = 2, fuel = 40
Output: 615088286
Explanation: The total number of possible routes is 2615088300. Taking this number modulo 10^9 + 7 gives us 615088286.


Constraints:
`2 <= locations.length <= 100`
`1 <= locations[i] <= 10^9`
All integers in `locations` are distinct.

`0 <= start, finish < locations.length`
`1 <= fuel <= 200`",0,,57.1,10.1,https://leetcode.com/problems/count-all-possible-routes,99,6.4K,11.2K,TSYS,Dynamic Programming,214,10,96,0,
328,1579,Remove Max Number of Edges to Keep Graph Fully Traversable,"Alice and Bob have an undirected graph of `n` nodes and 3 types of edges:
Type 1: Can be traversed by Alice only.

Type 2: Can be traversed by Bob only.

Type 3: Can by traversed by both Alice and Bob.

Given an array `edges` where `edges[i] = [typei, ui, vi]` represents a bidirectional edge of type `typei` between nodes `ui` and `vi`, find the maximum number of edges you can remove so that after removing the edges, the graph can still be fully traversed by both Alice and Bob. The graph is fully traversed by Alice and Bob if starting from any node, they can reach all other nodes.

Return the maximum number of edges you can remove, or return `-1` if it's impossible for the graph to be fully traversed by Alice and Bob.


Example 1:
Input: n = 4, edges = [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]]
Output: 2
Explanation: If we remove the 2 edges [1,1,2] and [1,1,3]. The graph will still be fully traversable by Alice and Bob. Removing any additional edge will not make it so. So the maximum number of edges we can remove is 2.


Example 2:
Input: n = 4, edges = [[3,1,2],[3,2,3],[1,1,4],[2,1,4]]
Output: 0
Explanation: Notice that removing any edge will not make the graph fully traversable by Alice and Bob.


Example 3:
Input: n = 4, edges = [[3,2,3],[1,1,2],[2,3,4]]
Output: -1
Explanation: In the current graph, Alice cannot reach node 4 from the other nodes. Likewise, Bob cannot reach 1. Therefore it's impossible to make the graph fully traversable.


Constraints:
`1 <= n <= 10^5`
`1 <= edges.length <= min(10^5, 3 * n * (n-1) / 2)`
`edges[i].length == 3`
`1 <= edges[i][0] <= 3`
`1 <= edges[i][1] < edges[i][2] <= n`
All tuples `(typei, ui, vi)` are distinct.",0,,46.3,5.3,https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable,124,6.7K,14.4K,Uber,Union Find,307,3,99,0,
329,1585,Check If String Is Transformable With Substring Sort Operations,"Given two strings `s` and `t`, you want to transform string `s` into string `t` using the following operation any number of times:
Choose a non-empty substring in `s` and sort it in-place so the characters are in ascending order.

For example, applying the operation on the underlined substring in `""14234""` results in `""12344""`.

Return `true` if it is possible to transform string `s` into string `t`. Otherwise, return `false`.

A substring is a contiguous sequence of characters within a string.


Example 1:
Input: s = ""84532"", t = ""34852""
Output: true
Explanation: You can transform s into t using the following sort operations:
""84532"" (from index 2 to 3) -> ""84352""
""84352"" (from index 0 to 2) -> ""34852""

Example 2:
Input: s = ""34521"", t = ""23415""
Output: true
Explanation: You can transform s into t using the following sort operations:
""34521"" -> ""23451""
""23451"" -> ""23415""

Example 3:
Input: s = ""12345"", t = ""12435""
Output: false

Example 4:
Input: s = ""1"", t = ""2""
Output: false

Constraints:
`s.length == t.length`
`1 <= s.length <= 105`
`s` and `t` only contain digits from `'0'` to `'9'`.",0,,48.5,0.0,https://leetcode.com/problems/check-if-string-is-transformable-with-substring-sort-operations,60,4.7K,9.7K,Google,"String,Greedy",233,4,98,1,
330,1591,Strange Printer II,"There is a strange printer with the following two special requirements:
On each turn, the printer will print a solid rectangular pattern of a single color on the grid. This will cover up the existing colors in the rectangle.

Once the printer has used a color for the above operation, the same color cannot be used again.

You are given a `m x n` matrix `targetGrid`, where `targetGrid[row][col]` is the color in the position `(row, col)` of the grid.

Return `true` if it is possible to print the matrix `targetGrid`, otherwise, return `false`.


Example 1:
Input: targetGrid = [[1,1,1,1],[1,2,2,1],[1,2,2,1],[1,1,1,1]]
Output: true

Example 2:
Input: targetGrid = [[1,1,1,1],[1,1,3,3],[1,1,3,4],[5,5,1,4]]
Output: true

Example 3:
Input: targetGrid = [[1,2,1],[2,1,2],[1,2,1]]
Output: false
Explanation: It is impossible to form targetGrid because it is not allowed to print the same color in different turns.


Example 4:
Input: targetGrid = [[1,1,1],[3,1,3]]
Output: false

Constraints:
`m == targetGrid.length`
`n == targetGrid[i].length`
`1 <= m, n <= 60`
`1 <= targetGrid[row][col] <= 60`",0,,55.3,0.0,https://leetcode.com/problems/strange-printer-ii,46,3.4K,6.2K,Google,Greedy,179,5,97,1,"[Strange Printer, /problems/strange-printer/, Hard]"
331,1595,Minimum Cost to Connect Two Groups of Points,"You are given two groups of points where the first group has `size1` points, the second group has `size2` points, and `size1 >= size2`.

The `cost` of the connection between any two points are given in an `size1 x size2` matrix where `cost[i][j]` is the cost of connecting point `i` of the first group and point `j` of the second group. The groups are connected if each point in both groups is connected to one or more points in the opposite group. In other words, each point in the first group must be connected to at least one point in the second group, and each point in the second group must be connected to at least one point in the first group.

Return the minimum cost it takes to connect the two groups.


Example 1:
Input: cost = [[15, 96], [36, 2]]
Output: 17
Explanation: The optimal way of connecting the groups is:
1--A
2--B
This results in a total cost of 17.


Example 2:
Input: cost = [[1, 3, 5], [4, 1, 1], [1, 5, 3]]
Output: 4
Explanation: The optimal way of connecting the groups is:
1--A
2--B
2--C
3--A
This results in a total cost of 4.

Note that there are multiple points connected to point 2 in the first group and point A in the second group. This does not matter as there is no limit to the number of points that can be connected. We only care about the minimum total cost.


Example 3:
Input: cost = [[2, 5, 1], [3, 4, 7], [8, 1, 2], [6, 2, 4], [3, 8, 8]]
Output: 10

Constraints:
`size1 == cost.length`
`size2 == cost[i].length`
`1 <= size1, size2 <= 12`
`size1 >= size2`
`0 <= cost[i][j] <= 100`",0,,43.6,11.9,https://leetcode.com/problems/minimum-cost-to-connect-two-groups-of-points,59,4.4K,10.1K,Google,"Dynamic Programming,Graph",207,9,96,1,
332,1597,Build Binary Expression Tree From Infix Expression,"A binary expression tree is a kind of binary tree used to represent arithmetic expressions. Each node of a binary expression tree has either zero or two children. Leaf nodes (nodes with 0 children) correspond to operands (numbers), and internal nodes (nodes with 2 children) correspond to the operators `'+'` (addition), `'-'` (subtraction), `'*'` (multiplication), and `'/'` (division).

For each internal node with operator `o`, the infix expression that it represents is `(A o B)`, where `A` is the expression the left subtree represents and `B` is the expression the right subtree represents.

You are given a string `s`, an infix expression containing operands, the operators described above, and parentheses `'('` and `')'`.

Return any valid binary expression tree, which its in-order traversal reproduces `s` after omitting the parenthesis from it (see examples below).

Please note that order of operations applies in `s`. That is, expressions in parentheses are evaluated first, and multiplication and division happen before addition and subtraction.

Operands must also appear in the same order in both `s` and the in-order traversal of the tree.


Example 1:
Input: s = ""3*4-2*5""
Output: [-,*,*,3,4,2,5]
Explanation: The tree above is the only valid tree whose inorder traversal produces s.


Example 2:
Input: s = ""2-3/(5*2)+1""
Output: [+,-,1,2,/,null,null,null,null,3,*,null,null,5,2]
Explanation: The inorder traversal of the tree above is 2-3/5*2+1 which is the same as s without the parenthesis. The tree also produces the correct result and its operands are in the same order as they appear in s.

The tree below is also a valid binary expression tree with the same inorder traversal as s, but it not a valid answer because it does not evaluate to the same value.

The third tree below is also not valid. Although it produces the same result and is equivalent to the above trees, its inorder traversal does not produce s and its operands are not in the same order as s.


Example 3:
Input: s = ""1+2+3+4+5""
Output: [+,+,5,+,4,null,null,+,3,null,null,1,2]
Explanation: The tree [+,+,5,+,+,null,null,1,2,3,4] is also one of many other valid trees.


Constraints:
`1 <= s.length <= 1000`
`s` consists of digits and the characters `'+'`, `'-'`, `'*'`, and `'/'`.

Operands in `s` are exactly 1 digit.

It is guaranteed that `s` is a valid expression.",1,,59.0,25.2,https://leetcode.com/problems/build-binary-expression-tree-from-infix-expression,60,2.9K,4.8K,Amazon,"String,Tree",77,16,83,1,"[Basic Calculator III, /problems/basic-calculator-iii/, Hard], [Check If Two Expression Trees are Equivalent, /problems/check-if-two-expression-trees-are-equivalent/, Medium]"
333,1601,Maximum Number of Achievable Transfer Requests,"We have `n` buildings numbered from `0` to `n - 1`. Each building has a number of employees. It's transfer season, and some employees want to change the building they reside in.

You are given an array `requests` where `requests[i] = [fromi, toi]` represents an employee's request to transfer from building `fromi` to building `toi`.

All buildings are full, so a list of requests is achievable only if for each building, the net change in employee transfers is zero. This means the number of employees leaving is equal to the number of employees moving in. For example if `n = 3` and two employees are leaving building `0`, one is leaving building `1`, and one is leaving building `2`, there should be two employees moving to building `0`, one employee moving to building `1`, and one employee moving to building `2`.

Return the maximum number of achievable requests.


Example 1:
Input: n = 5, requests = [[0,1],[1,0],[0,1],[1,2],[2,0],[3,4]]
Output: 5
Explantion: Let's see the requests:
From building 0 we have employees x and y and both want to move to building 1.

From building 1 we have employees a and b and they want to move to buildings 2 and 0 respectively.

From building 2 we have employee z and they want to move to building 0.

From building 3 we have employee c and they want to move to building 4.

From building 4 we don't have any requests.

We can achieve the requests of users x and b by swapping their places.

We can achieve the requests of users y, a and z by swapping the places in the 3 buildings.


Example 2:
Input: n = 3, requests = [[0,0],[1,2],[2,1]]
Output: 3
Explantion: Let's see the requests:
From building 0 we have employee x and they want to stay in the same building 0.

From building 1 we have employee y and they want to move to building 2.

From building 2 we have employee z and they want to move to building 1.

We can achieve all the requests. 

Example 3:
Input: n = 4, requests = [[0,3],[3,1],[1,2],[2,0]]
Output: 4

Constraints:
`1 <= n <= 20`
`1 <= requests.length <= 16`
`requests[i].length == 2`
`0 <= fromi, toi < n`",0,,47.8,0.0,https://leetcode.com/problems/maximum-number-of-achievable-transfer-requests,82,5.6K,11.8K,Amazon,Dynamic Programming,172,21,89,1,
334,1606,Find Servers That Handled Most Number of Requests,"You have `k` servers numbered from `0` to `k-1` that are being used to handle multiple requests simultaneously. Each server has infinite computational capacity but cannot handle more than one request at a time. The requests are assigned to servers according to a specific algorithm:
The `ith` (0-indexed) request arrives.

If all servers are busy, the request is dropped (not handled at all).

If the `(i % k)th` server is available, assign the request to that server.

Otherwise, assign the request to the next available server (wrapping around the list of servers and starting from 0 if necessary). For example, if the `ith` server is busy, try to assign the request to the `(i+1)th` server, then the `(i+2)th` server, and so on.

You are given a strictly increasing array `arrival` of positive integers, where `arrival[i]` represents the arrival time of the `ith` request, and another array `load`, where `load[i]` represents the load of the `ith` request (the time it takes to complete). Your goal is to find the busiest server(s). A server is considered busiest if it handled the most number of requests successfully among all the servers.

Return a list containing the IDs (0-indexed) of the busiest server(s). You may return the IDs in any order.


Example 1:
Input: k = 3, arrival = [1,2,3,4,5], load = [5,2,3,3,3] 
Output: [1] 
Explanation:
All of the servers start out available.

The first 3 requests are handled by the first 3 servers in order.

Request 3 comes in. Server 0 is busy, so it's assigned to the next available server, which is 1.

Request 4 comes in. It cannot be handled since all servers are busy, so it is dropped.

Servers 0 and 2 handled one request each, while server 1 handled two requests. Hence server 1 is the busiest server.


Example 2:
Input: k = 3, arrival = [1,2,3,4], load = [1,2,1,2]
Output: [0]
Explanation:
The first 3 requests are handled by first 3 servers.

Request 3 comes in. It is handled by server 0 since the server is available.

Server 0 handled two requests, while servers 1 and 2 handled one request each. Hence server 0 is the busiest server.


Example 3:
Input: k = 3, arrival = [1,2,3], load = [10,12,11]
Output: [0,1,2]
Explanation: Each server handles a single request, so they are all considered the busiest.


Example 4:
Input: k = 3, arrival = [1,2,3,4,8,9,10], load = [5,2,10,3,1,2,2]
Output: [1]

Example 5:
Input: k = 1, arrival = [1], load = [1]
Output: [0]

Constraints:
`1 <= k <= 105`
`1 <= arrival.length, load.length <= 105`
`arrival.length == load.length`
`1 <= arrival[i], load[i] <= 109`
`arrival` is strictly increasing.",0,,37.4,28.8,https://leetcode.com/problems/find-servers-that-handled-most-number-of-requests,72,3.9K,10.5K,Wish,Ordered Map,191,7,96,0,
335,1610,Maximum Number of Visible Points,"You are given an array `points`, an integer `angle`, and your `location`, where `location = [posx, posy]` and `points[i] = [xi, yi]` both denote integral coordinates on the X-Y plane.

Initially, you are facing directly east from your position. You cannot move from your position, but you can rotate. In other words, `posx` and `posy` cannot be changed. Your field of view in degrees is represented by `angle`, determining how wide you can see from any given view direction. Let `d` be the amount in degrees that you rotate counterclockwise. Then, your field of view is the inclusive range of angles `[d - angle/2, d + angle/2]`.

Your browser does not support the video tag or this video format.

You can see some set of points if, for each point, the angle formed by the point, your position, and the immediate east direction from your position is in your field of view.

There can be multiple points at one coordinate. There may be points at your location, and you can always see these points regardless of your rotation. Points do not obstruct your vision to other points.

Return the maximum number of points you can see.


Example 1:
Input: points = [[2,1],[2,2],[3,3]], angle = 90, location = [1,1]
Output: 3
Explanation: The shaded region represents your field of view. All points can be made visible in your field of view, including [3,3] even though [2,2] is in front and in the same line of sight.


Example 2:
Input: points = [[2,1],[2,2],[3,4],[1,1]], angle = 90, location = [1,1]
Output: 4
Explanation: All points can be made visible in your field of view, including the one at your location.


Example 3:
Input: points = [[1,0],[2,1]], angle = 13, location = [1,1]
Output: 1
Explanation: You can only see one of the two points, as shown above.


Constraints:
`1 <= points.length <= 105`
`points[i].length == 2`
`location.length == 2`
`0 <= angle < 360`
`0 <= posx, posy, xi, yi <= 100`",0,,30.4,37.6,https://leetcode.com/problems/maximum-number-of-visible-points,78,7.4K,24.4K,"Google,Amazon","Two Pointers,Geometry",148,223,40,1,
336,1611,Minimum One Bit Operations to Make Integers Zero,"Given an integer `n`, you must transform it into `0` using the following operations any number of times:
Change the rightmost (`0th`) bit in the binary representation of `n`.

Change the `ith` bit in the binary representation of `n` if the `(i-1)th` bit is set to `1` and the `(i-2)th` through `0th` bits are set to `0`.

Return the minimum number of operations to transform `n` into `0`.


Example 1:
Input: n = 0
Output: 0

Example 2:
Input: n = 3
Output: 2
Explanation: The binary representation of 3 is ""11"".

""11"" -> ""01"" with the 2nd operation since the 0th bit is 1.

""01"" -> ""00"" with the 1st operation.


Example 3:
Input: n = 6
Output: 4
Explanation: The binary representation of 6 is ""110"".

""110"" -> ""010"" with the 2nd operation since the 1st bit is 1 and 0th through 0th bits are 0.

""010"" -> ""011"" with the 1st operation.

""011"" -> ""001"" with the 2nd operation since the 0th bit is 1.

""001"" -> ""000"" with the 1st operation.


Example 4:
Input: n = 9
Output: 14

Example 5:
Input: n = 333
Output: 393

Constraints:
`0 <= n <= 109`",0,,57.7,39.8,https://leetcode.com/problems/minimum-one-bit-operations-to-make-integers-zero,75,3.8K,6.6K,Expedia,"Dynamic Programming,Bit Manipulation",144,100,59,0,
337,1617,Count Subtrees With Max Distance Between Cities,"There are `n` cities numbered from `1` to `n`. You are given an array `edges` of size `n-1`, where `edges[i] = [ui, vi]` represents a bidirectional edge between cities `ui` and `vi`. There exists a unique path between each pair of cities. In other words, the cities form a tree.

A subtree is a subset of cities where every city is reachable from every other city in the subset, where the path between each pair passes through only the cities from the subset. Two subtrees are different if there is a city in one subtree that is not present in the other.

For each `d` from `1` to `n-1`, find the number of subtrees in which the maximum distance between any two cities in the subtree is equal to `d`.

Return an array of size `n-1` where the `dth` element (1-indexed) is the number of subtrees in which the maximum distance between any two cities is equal to `d`.

Notice that the distance between the two cities is the number of edges in the path between them.


Example 1:
Input: n = 4, edges = [[1,2],[2,3],[2,4]]
Output: [3,4,0]
Explanation:
The subtrees with subsets {1,2}, {2,3} and {2,4} have a max distance of 1.

The subtrees with subsets {1,2,3}, {1,2,4}, {2,3,4} and {1,2,3,4} have a max distance of 2.

No subtree has two nodes where the max distance between them is 3.


Example 2:
Input: n = 2, edges = [[1,2]]
Output: [1]

Example 3:
Input: n = 3, edges = [[1,2],[2,3]]
Output: [2,1]

Constraints:
`2 <= n <= 15`
`edges.length == n-1`
`edges[i].length == 2`
`1 <= ui, vi <= n`
All pairs `(ui, vi)` are distinct.",0,,63.2,0.0,https://leetcode.com/problems/count-subtrees-with-max-distance-between-cities,84,4.3K,6.8K,Codenation,Backtracking,156,23,87,0,"[Tree Diameter, /problems/tree-diameter/, Medium]"
338,1622,Fancy Sequence,"Write an API that generates fancy sequences using the `append`, `addAll`, and `multAll` operations.

Implement the `Fancy` class:
`Fancy()` Initializes the object with an empty sequence.

`void append(val)` Appends an integer `val` to the end of the sequence.

`void addAll(inc)` Increments all existing values in the sequence by an integer `inc`.

`void multAll(m)` Multiplies all existing values in the sequence by an integer `m`.

`int getIndex(idx)` Gets the current value at index `idx` (0-indexed) of the sequence modulo `109 + 7`. If the index is greater or equal than the length of the sequence, return `-1`.


Example 1:
Input
[""Fancy"", ""append"", ""addAll"", ""append"", ""multAll"", ""getIndex"", ""addAll"", ""append"", ""multAll"", ""getIndex"", ""getIndex"", ""getIndex""]
[[], [2], [3], [7], [2], [0], [3], [10], [2], [0], [1], [2]]
Output
[null, null, null, null, null, 10, null, null, null, 26, 34, 20]
Explanation
Fancy fancy = new Fancy();
fancy.append(2);   // fancy sequence: [2]
fancy.addAll(3);   // fancy sequence: [2+3] -> [5]
fancy.append(7);   // fancy sequence: [5, 7]
fancy.multAll(2);  // fancy sequence: [5*2, 7*2] -> [10, 14]
fancy.getIndex(0); // return 10
fancy.addAll(3);   // fancy sequence: [10+3, 14+3] -> [13, 17]
fancy.append(10);  // fancy sequence: [13, 17, 10]
fancy.multAll(2);  // fancy sequence: [13*2, 17*2, 10*2] -> [26, 34, 20]
fancy.getIndex(0); // return 26
fancy.getIndex(1); // return 34
fancy.getIndex(2); // return 20

Constraints:
`1 <= val, inc, m <= 100`
`0 <= idx <= 105`
At most `105` calls total will be made to `append`, `addAll`, `multAll`, and `getIndex`.",0,,15.0,12.3,https://leetcode.com/problems/fancy-sequence,70,3.8K,25.3K,Google,"Math,Design",166,53,76,1,
339,1627,Graph Connectivity With Threshold,"We have `n` cities labeled from `1` to `n`. Two different cities with labels `x` and `y` are directly connected by a bidirectional road if and only if `x` and `y` share a common divisor strictly greater than some `threshold`. More formally, cities with labels `x` and `y` have a road between them if there exists an integer `z` such that all of the following are true:
`x % z == 0`,
`y % z == 0`, and
`z > threshold`.

Given the two integers, `n` and `threshold`, and an array of `queries`, you must determine for each `queries[i] = [ai, bi]` if cities `ai` and `bi` are connected directly or indirectly. (i.e. there is some path between them).

Return an array `answer`, where `answer.length == queries.length` and `answer[i]` is `true` if for the `ith` query, there is a path between `ai` and `bi`, or `answer[i]` is `false` if there is no path.


Example 1:
Input: n = 6, threshold = 2, queries = [[1,4],[2,5],[3,6]]
Output: [false,false,true]
Explanation: The divisors for each number:
1:   1
2:   1, 2
3:   1, 3
4:   1, 2, 4
5:   1, 5
6:   1, 2, 3, 6
Using the underlined divisors above the threshold, only cities 3 and 6 share a common divisor, so they are the
only ones directly connected. The result of each query:
[1,4]   1 is not connected to 4
[2,5]   2 is not connected to 5
[3,6]   3 is connected to 6 through path 3--6

Example 2:
Input: n = 6, threshold = 0, queries = [[4,5],[3,4],[3,2],[2,6],[1,3]]
Output: [true,true,true,true,true]
Explanation: The divisors for each number are the same as the previous example. However, since the threshold is 0,
all divisors can be used. Since all numbers share 1 as a divisor, all cities are connected.


Example 3:
Input: n = 5, threshold = 1, queries = [[4,5],[4,5],[3,2],[2,3],[3,4]]
Output: [false,false,false,false,false]
Explanation: Only cities 2 and 4 share a common divisor 2 which is strictly greater than the threshold 1, so they are the only ones directly connected.

Please notice that there can be multiple queries for the same pair of nodes [x, y], and that the query [x, y] is equivalent to the query [y, x].


Constraints:
`2 <= n <= 104`
`0 <= threshold <= n`
`1 <= queries.length <= 105`
`queries[i].length == 2`
`1 <= ai, bi <= cities`
`ai != bi`",0,,40.2,16.2,https://leetcode.com/problems/graph-connectivity-with-threshold,92,6.1K,15.1K,Trexquant,"Math,Union Find",163,20,89,0,
340,1632,Rank Transform of a Matrix,"Given an `m x n` `matrix`, return a new matrix `answer` where `answer[row][col]` is the rank of `matrix[row][col]`.

The rank is an integer that represents how large an element is compared to other elements. It is calculated using the following rules:
The rank is an integer starting from `1`.

If two elements `p` and `q` are in the same row or column, then:
	
If `p < q` then `rank(p) < rank(q)`
If `p == q` then `rank(p) == rank(q)`
If `p > q` then `rank(p) > rank(q)`
The rank should be as small as possible.

It is guaranteed that `answer` is unique under the given rules.


Example 1:
Input: matrix = [[1,2],[3,4]]
Output: [[1,2],[2,3]]
Explanation:
The rank of matrix[0][0] is 1 because it is the smallest integer in its row and column.

The rank of matrix[0][1] is 2 because matrix[0][1] > matrix[0][0] and matrix[0][0] is rank 1.

The rank of matrix[1][0] is 2 because matrix[1][0] > matrix[0][0] and matrix[0][0] is rank 1.

The rank of matrix[1][1] is 3 because matrix[1][1] > matrix[0][1], matrix[1][1] > matrix[1][0], and both matrix[0][1] and matrix[1][0] are rank 2.


Example 2:
Input: matrix = [[7,7],[7,7]]
Output: [[1,1],[1,1]]

Example 3:
Input: matrix = [[20,-21,14],[-19,4,19],[22,-47,24],[-19,4,19]]
Output: [[4,2,3],[1,3,4],[5,1,6],[1,3,4]]

Example 4:
Input: matrix = [[7,3,6],[1,4,5],[9,8,2]]
Output: [[5,1,4],[1,2,3],[6,3,1]]

Constraints:
`m == matrix.length`
`n == matrix[i].length`
`1 <= m, n <= 500`
`-109 <= matrix[row][col] <= 109`",0,/articles/rank-transform-of-a-matrix,31.9,5.8,https://leetcode.com/problems/rank-transform-of-a-matrix,45,3.6K,11.1K,Google,"Greedy,Union Find",193,6,97,1,"[Rank Transform of an Array, /problems/rank-transform-of-an-array/, Easy]"
341,1635,Hopper Company Queries I,SQL Schema,1,,56.2,3.4,https://leetcode.com/problems/hopper-company-queries-i,83,2.1K,3.8K,Uber,,26,11,70,0,
342,1639,Number of Ways to Form a Target String Given a Dictionary,"You are given a list of strings of the same length `words` and a string `target`.

Your task is to form `target` using the given `words` under the following rules:
`target` should be formed from left to right.

To form the `ith` character (0-indexed) of `target`, you can choose the `kth` character of the `jth` string in `words` if `target[i] = words[j][k]`.

Once you use the `kth` character of the `jth` string of `words`, you can no longer use the `xth` character of any string in `words` where `x <= k`. In other words, all characters to the left of or at index `k` become unusuable for every string.

Repeat the process until you form the string `target`.

Notice that you can use multiple characters from the same string in `words` provided the conditions above are met.

Return the number of ways to form `target` from `words`. Since the answer may be too large, return it modulo `109 + 7`.


Example 1:
Input: words = [""acca"",""bbbb"",""caca""], target = ""aba""
Output: 6
Explanation: There are 6 ways to form target.

""aba"" -> index 0 (""acca""), index 1 (""bbbb""), index 3 (""caca"")
""aba"" -> index 0 (""acca""), index 2 (""bbbb""), index 3 (""caca"")
""aba"" -> index 0 (""acca""), index 1 (""bbbb""), index 3 (""acca"")
""aba"" -> index 0 (""acca""), index 2 (""bbbb""), index 3 (""acca"")
""aba"" -> index 1 (""caca""), index 2 (""bbbb""), index 3 (""acca"")
""aba"" -> index 1 (""caca""), index 2 (""bbbb""), index 3 (""caca"")

Example 2:
Input: words = [""abba"",""baab""], target = ""bab""
Output: 4
Explanation: There are 4 ways to form target.

""bab"" -> index 0 (""baab""), index 1 (""baab""), index 2 (""abba"")
""bab"" -> index 0 (""baab""), index 1 (""baab""), index 3 (""baab"")
""bab"" -> index 0 (""baab""), index 2 (""baab""), index 3 (""baab"")
""bab"" -> index 1 (""abba""), index 2 (""baab""), index 3 (""baab"")

Example 3:
Input: words = [""abcd""], target = ""abcd""
Output: 1

Example 4:
Input: words = [""abab"",""baba"",""abba"",""baab""], target = ""abba""
Output: 16

Constraints:
`1 <= words.length <= 1000`
`1 <= words[i].length <= 1000`
All strings in `words` have the same length.

`1 <= target.length <= 1000`
`words[i]` and `target` contain only lowercase English letters.",0,,40.0,7.2,https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary,61,3.9K,9.7K,Dunzo,Dynamic Programming,129,7,95,0,
343,1643,Kth Smallest Instructions,"Bob is standing at cell `(0, 0)`, and he wants to reach `destination`: `(row, column)`. He can only travel right and down. You are going to help Bob by providing instructions for him to reach `destination`.

The instructions are represented as a string, where each character is either:
`'H'`, meaning move horizontally (go right), or
`'V'`, meaning move vertically (go down).

Multiple instructions will lead Bob to `destination`. For example, if `destination` is `(2, 3)`, both `""HHHVV""` and `""HVHVH""` are valid instructions.

However, Bob is very picky. Bob has a lucky number `k`, and he wants the `kth` lexicographically smallest instructions that will lead him to `destination`. `k` is 1-indexed.

Given an integer array `destination` and an integer `k`, return the `kth` lexicographically smallest instructions that will take Bob to `destination`.


Example 1:
Input: destination = [2,3], k = 1
Output: ""HHHVV""
Explanation: All the instructions that reach (2, 3) in lexicographic order are as follows:
[""HHHVV"", ""HHVHV"", ""HHVVH"", ""HVHHV"", ""HVHVH"", ""HVVHH"", ""VHHHV"", ""VHHVH"", ""VHVHH"", ""VVHHH""].


Example 2:
Input: destination = [2,3], k = 2
Output: ""HHVHV""

Example 3:
Input: destination = [2,3], k = 3
Output: ""HHVVH""

Constraints:
`destination.length == 2`
`1 <= row, column <= 15`
`1 <= k <= nCr(row + column, row)`, where `nCr(a, b)` denotes `a` choose `b`​​​​​.",0,,44.8,17.8,https://leetcode.com/problems/kth-smallest-instructions,100,4.9K,11K,HeavyWater,Dynamic Programming,193,3,98,0,
344,1645,Hopper Company Queries II,SQL Schema,1,,39.1,0.0,https://leetcode.com/problems/hopper-company-queries-ii,58,1.7K,4.3K,Uber,,22,5,81,0,
345,1649,Create Sorted Array through Instructions,"Given an integer array `instructions`, you are asked to create a sorted array from the elements in `instructions`. You start with an empty container `nums`. For each element from left to right in `instructions`, insert it into `nums`. The cost of each insertion is the minimum of the following:
The number of elements currently in `nums` that are strictly less than `instructions[i]`.

The number of elements currently in `nums` that are strictly greater than `instructions[i]`.

For example, if inserting element `3` into `nums = [1,2,3,5]`, the cost of insertion is `min(2, 1)` (elements `1` and `2` are less than `3`, element `5` is greater than `3`) and `nums` will become `[1,2,3,3,5]`.

Return the total cost to insert all elements from `instructions` into `nums`. Since the answer may be large, return it modulo `109 + 7`

Example 1:
Input: instructions = [1,5,6,2]
Output: 1
Explanation: Begin with nums = [].

Insert 1 with cost min(0, 0) = 0, now nums = [1].

Insert 5 with cost min(1, 0) = 0, now nums = [1,5].

Insert 6 with cost min(2, 0) = 0, now nums = [1,5,6].

Insert 2 with cost min(1, 2) = 1, now nums = [1,2,5,6].

The total cost is 0 + 0 + 0 + 1 = 1.


Example 2:
Input: instructions = [1,2,3,6,5,4]
Output: 3
Explanation: Begin with nums = [].

Insert 1 with cost min(0, 0) = 0, now nums = [1].

Insert 2 with cost min(1, 0) = 0, now nums = [1,2].

Insert 3 with cost min(2, 0) = 0, now nums = [1,2,3].

Insert 6 with cost min(3, 0) = 0, now nums = [1,2,3,6].

Insert 5 with cost min(3, 1) = 1, now nums = [1,2,3,5,6].

Insert 4 with cost min(3, 2) = 2, now nums = [1,2,3,4,5,6].

The total cost is 0 + 0 + 0 + 0 + 1 + 2 = 3.


Example 3:
Input: instructions = [1,3,3,3,2,4,2,1,2]
Output: 4
Explanation: Begin with nums = [].

Insert 1 with cost min(0, 0) = 0, now nums = [1].

Insert 3 with cost min(1, 0) = 0, now nums = [1,3].

Insert 3 with cost min(1, 0) = 0, now nums = [1,3,3].

Insert 3 with cost min(1, 0) = 0, now nums = [1,3,3,3].

Insert 2 with cost min(1, 3) = 1, now nums = [1,2,3,3,3].

Insert 4 with cost min(5, 0) = 0, now nums = [1,2,3,3,3,4].

​​​​​​​Insert 2 with cost min(1, 4) = 1, now nums = [1,2,2,3,3,3,4].

​​​​​​​Insert 1 with cost min(0, 6) = 0, now nums = [1,1,2,2,3,3,3,4].

​​​​​​​Insert 2 with cost min(2, 4) = 2, now nums = [1,1,2,2,2,3,3,3,4].

The total cost is 0 + 0 + 0 + 0 + 1 + 0 + 1 + 0 + 2 = 4.


Constraints:
`1 <= instructions.length <= 105`
`1 <= instructions[i] <= 105`",0,/articles/create-sorted-array-through-instructions,36.5,6.3,https://leetcode.com/problems/create-sorted-array-through-instructions,134,17.1K,46.7K,Akuna Capital,"Binary Search,Binary Indexed Tree,Segment Tree,Ordered Map",341,50,87,0,
346,1651,Hopper Company Queries III,SQL Schema,1,,67.2,3.8,https://leetcode.com/problems/hopper-company-queries-iii,59,1.6K,2.4K,Uber,,9,9,50,0,
347,1655,Distribute Repeating Integers,"You are given an array of `n` integers, `nums`, where there are at most `50` unique values in the array. You are also given an array of `m` customer order quantities, `quantity`, where `quantity[i]` is the amount of integers the `ith` customer ordered. Determine if it is possible to distribute `nums` such that:
The `ith` customer gets exactly `quantity[i]` integers,
The integers the `ith` customer gets are all equal, and
Every customer is satisfied.

Return `true` if it is possible to distribute `nums` according to the above conditions.


Example 1:
Input: nums = [1,2,3,4], quantity = [2]
Output: false
Explanation: The 0th customer cannot be given two different integers.


Example 2:
Input: nums = [1,2,3,3], quantity = [2]
Output: true
Explanation: The 0th customer is given [3,3]. The integers [1,2] are not used.


Example 3:
Input: nums = [1,1,2,2], quantity = [2,2]
Output: true
Explanation: The 0th customer is given [1,1], and the 1st customer is given [2,2].


Example 4:
Input: nums = [1,1,2,3], quantity = [2,2]
Output: false
Explanation: Although the 0th customer could be given [1,1], the 1st customer cannot be satisfied.


Example 5:
Input: nums = [1,1,1,1,1], quantity = [2,3]
Output: true
Explanation: The 0th customer is given [1,1], and the 1st customer is given [1,1,1].


Constraints:
`n == nums.length`
`1 <= n <= 105`
`1 <= nums[i] <= 1000`
`m == quantity.length`
`1 <= m <= 10`
`1 <= quantity[i] <= 105`
There are at most `50` unique values in `nums`.",0,,40.0,0.0,https://leetcode.com/problems/distribute-repeating-integers,54,4.4K,11K,Google,"Dynamic Programming,Backtracking",115,11,91,1,
348,1659,Maximize Grid Happiness,"You are given four integers, `m`, `n`, `introvertsCount`, and `extrovertsCount`. You have an `m x n` grid, and there are two types of people: introverts and extroverts. There are `introvertsCount` introverts and `extrovertsCount` extroverts.

You should decide how many people you want to live in the grid and assign each of them one grid cell. Note that you do not have to have all the people living in the grid.

The happiness of each person is calculated as follows:
Introverts start with `120` happiness and lose `30` happiness for each neighbor (introvert or extrovert).

Extroverts start with `40` happiness and gain `20` happiness for each neighbor (introvert or extrovert).

Neighbors live in the directly adjacent cells north, east, south, and west of a person's cell.

The grid happiness is the sum of each person's happiness. Return the maximum possible grid happiness.


Example 1:
Input: m = 2, n = 3, introvertsCount = 1, extrovertsCount = 2
Output: 240
Explanation: Assume the grid is 1-indexed with coordinates (row, column).

We can put the introvert in cell (1,1) and put the extroverts in cells (1,3) and (2,3).

- Introvert at (1,1) happiness: 120 (starting happiness) - (0 * 30) (0 neighbors) = 120
- Extrovert at (1,3) happiness: 40 (starting happiness) + (1 * 20) (1 neighbor) = 60
- Extrovert at (2,3) happiness: 40 (starting happiness) + (1 * 20) (1 neighbor) = 60
The grid happiness is 120 + 60 + 60 = 240.

The above figure shows the grid in this example with each person's happiness. The introvert stays in the light green cell while the extroverts live on the light purple cells.


Example 2:
Input: m = 3, n = 1, introvertsCount = 2, extrovertsCount = 1
Output: 260
Explanation: Place the two introverts in (1,1) and (3,1) and the extrovert at (2,1).

- Introvert at (1,1) happiness: 120 (starting happiness) - (1 * 30) (1 neighbor) = 90
- Extrovert at (2,1) happiness: 40 (starting happiness) + (2 * 20) (2 neighbors) = 80
- Introvert at (3,1) happiness: 120 (starting happiness) - (1 * 30) (1 neighbor) = 90
The grid happiness is 90 + 80 + 90 = 260.


Example 3:
Input: m = 2, n = 2, introvertsCount = 4, extrovertsCount = 0
Output: 240

Constraints:
`1 <= m, n <= 5`
`0 <= introvertsCount, extrovertsCount <= min(m * n, 6)`",0,,35.6,24.3,https://leetcode.com/problems/maximize-grid-happiness,36,2.5K,7.1K,Salesforce,"Dynamic Programming,Backtracking",128,42,75,0,
349,1665,Minimum Initial Energy to Finish Tasks,"You are given an array `tasks` where `tasks[i] = [actuali, minimumi]`:
`actuali` is the actual amount of energy you spend to finish the `ith` task.

`minimumi` is the minimum amount of energy you require to begin the `ith` task.

For example, if the task is `[10, 12]` and your current energy is `11`, you cannot start this task. However, if your current energy is `13`, you can complete this task, and your energy will be `3` after finishing it.

You can finish the tasks in any order you like.

Return the minimum initial amount of energy you will need to finish all the tasks.


Example 1:
Input: tasks = [[1,2],[2,4],[4,8]]
Output: 8
Explanation:
Starting with 8 energy, we finish the tasks in the following order:
    - 3rd task. Now energy = 8 - 4 = 4.

    - 2nd task. Now energy = 4 - 2 = 2.

    - 1st task. Now energy = 2 - 1 = 1.

Notice that even though we have leftover energy, starting with 7 energy does not work because we cannot do the 3rd task.


Example 2:
Input: tasks = [[1,3],[2,4],[10,11],[10,12],[8,9]]
Output: 32
Explanation:
Starting with 32 energy, we finish the tasks in the following order:
    - 1st task. Now energy = 32 - 1 = 31.

    - 2nd task. Now energy = 31 - 2 = 29.

    - 3rd task. Now energy = 29 - 10 = 19.

    - 4th task. Now energy = 19 - 10 = 9.

    - 5th task. Now energy = 9 - 8 = 1.


Example 3:
Input: tasks = [[1,7],[2,8],[3,9],[4,10],[5,11],[6,12]]
Output: 27
Explanation:
Starting with 27 energy, we finish the tasks in the following order:
    - 5th task. Now energy = 27 - 5 = 22.

    - 2nd task. Now energy = 22 - 2 = 20.

    - 3rd task. Now energy = 20 - 3 = 17.

    - 1st task. Now energy = 17 - 1 = 16.

    - 4th task. Now energy = 16 - 4 = 12.

    - 6th task. Now energy = 12 - 6 = 6.


Constraints:
`1 <= tasks.length <= 105`
`1 <= actual​i <= minimumi <= 104`",0,,65.1,6.5,https://leetcode.com/problems/minimum-initial-energy-to-finish-tasks,149,9.1K,14K,Akuna Capital,Greedy,207,24,90,0,
350,1671,Minimum Number of Removals to Make Mountain Array,"You may recall that an array `arr` is a mountain array if and only if:
`arr.length >= 3`
There exists some index `i` (0-indexed) with `0 < i < arr.length - 1` such that:
	
`arr[0] < arr[1] < ... < arr[i - 1] < arr[i]`
`arr[i] > arr[i + 1] > ... > arr[arr.length - 1]`
Given an integer array `nums`​​​, return the minimum number of elements to remove to make `nums​​​` a mountain array.


Example 1:
Input: nums = [1,3,1]
Output: 0
Explanation: The array itself is a mountain array so we do not need to remove any elements.


Example 2:
Input: nums = [2,1,1,5,6,2,3,1]
Output: 3
Explanation: One solution is to remove the elements at indices 0, 1, and 5, making the array nums = [1,5,6,3,1].


Example 3:
Input: nums = [4,3,2,1,1,2,3,1]
Output: 4

Example 4:
Input: nums = [1,2,3,4,4,3,2,1]
Output: 1

Constraints:
`3 <= nums.length <= 1000`
`1 <= nums[i] <= 109`
It is guaranteed that you can make a mountain array out of `nums`.",0,,45.4,13.4,https://leetcode.com/problems/minimum-number-of-removals-to-make-mountain-array,112,5.4K,12K,Microsoft,Dynamic Programming,257,4,98,0,"[Longest Increasing Subsequence, /problems/longest-increasing-subsequence/, Medium], [Longest Mountain in Array, /problems/longest-mountain-in-array/, Medium], [Peak Index in a Mountain Array, /problems/peak-index-in-a-mountain-array/, Easy], [Valid Mountain Array, /problems/valid-mountain-array/, Easy], [Find in Mountain Array, /problems/find-in-mountain-array/, Hard]"
351,1675,Minimize Deviation in Array,"You are given an array `nums` of `n` positive integers.

You can perform two types of operations on any element of the array any number of times:
If the element is even, divide it by `2`.

	
For example, if the array is `[1,2,3,4]`, then you can do this operation on the last element, and the array will be `[1,2,3,2].`
If the element is odd, multiply it by `2`.

	
For example, if the array is `[1,2,3,4]`, then you can do this operation on the first element, and the array will be `[2,2,3,4].`
The deviation of the array is the maximum difference between any two elements in the array.

Return the minimum deviation the array can have after performing some number of operations.


Example 1:
Input: nums = [1,2,3,4]
Output: 1
Explanation: You can transform the array to [1,2,3,2], then to [2,2,3,2], then the deviation will be 3 - 2 = 1.


Example 2:
Input: nums = [4,1,5,20,3]
Output: 3
Explanation: You can transform the array after two operations to [4,2,5,5,3], then the deviation will be 5 - 2 = 3.


Example 3:
Input: nums = [2,10,8]
Output: 3

Constraints:
`n == nums.length`
`2 <= n <= 105`
`1 <= nums[i] <= 109`",0,/articles/minimize-deviation-in-array,48.2,23.0,https://leetcode.com/problems/minimize-deviation-in-array,105,15.7K,32.6K,Samsung,"Heap,Ordered Map",406,18,96,0,
352,1681,Minimum Incompatibility,"You are given an integer array `nums`​​​ and an integer `k`. You are asked to distribute this array into `k` subsets of equal size such that there are no two equal elements in the same subset.

A subset's incompatibility is the difference between the maximum and minimum elements in that array.

Return the minimum possible sum of incompatibilities of the `k` subsets after distributing the array optimally, or return `-1` if it is not possible.

A subset is a group integers that appear in the array with no particular order.


Example 1:
Input: nums = [1,2,1,4], k = 2
Output: 4
Explanation: The optimal distribution of subsets is [1,2] and [1,4].

The incompatibility is (2-1) + (4-1) = 4.

Note that [1,1] and [2,4] would result in a smaller sum, but the first subset contains 2 equal elements.


Example 2:
Input: nums = [6,3,8,1,3,1,2,2], k = 4
Output: 6
Explanation: The optimal distribution of subsets is [1,2], [2,3], [6,8], and [1,3].

The incompatibility is (2-1) + (3-2) + (8-6) + (3-1) = 6.


Example 3:
Input: nums = [5,3,3,6,3,3], k = 3
Output: -1
Explanation: It is impossible to distribute nums into 3 subsets where no two elements are equal in the same subset.


Constraints:
`1 <= k <= nums.length <= 16`
`nums.length` is divisible by `k`
`1 <= nums[i] <= nums.length`",0,,35.8,9.0,https://leetcode.com/problems/minimum-incompatibility,63,4.3K,12.2K,Microsoft,"Backtracking,Greedy",109,77,59,0,
353,1687,Delivering Boxes from Storage to Ports,"You have the task of delivering some boxes from storage to their ports using only one ship. However, this ship has a limit on the number of boxes and the total weight that it can carry.

You are given an array `boxes`, where `boxes[i] = [ports​​i​, weighti]`, and three integers `portsCount`, `maxBoxes`, and `maxWeight`.

`ports​​i` is the port where you need to deliver the `ith` box and `weightsi` is the weight of the `ith` box.

`portsCount` is the number of ports.

`maxBoxes` and `maxWeight` are the respective box and weight limits of the ship.

The boxes need to be delivered in the order they are given. The ship will follow these steps:
The ship will take some number of boxes from the `boxes` queue, not violating the `maxBoxes` and `maxWeight` constraints.

For each loaded box in order, the ship will make a trip to the port the box needs to be delivered to and deliver it. If the ship is already at the correct port, no trip is needed, and the box can immediately be delivered.

The ship then makes a return trip to storage to take more boxes from the queue.

The ship must end at storage after all the boxes have been delivered.

Return the minimum number of trips the ship needs to make to deliver all boxes to their respective ports.


Example 1:
Input: boxes = [[1,1],[2,1],[1,1]], portsCount = 2, maxBoxes = 3, maxWeight = 3
Output: 4
Explanation: The optimal strategy is as follows: 
- The ship takes all the boxes in the queue, goes to port 1, then port 2, then port 1 again, then returns to storage. 4 trips.

So the total number of trips is 4.

Note that the first and third boxes cannot be delivered together because the boxes need to be delivered in order (i.e. the second box needs to be delivered at port 2 before the third box).


Example 2:
Input: boxes = [[1,2],[3,3],[3,1],[3,1],[2,4]], portsCount = 3, maxBoxes = 3, maxWeight = 6
Output: 6
Explanation: The optimal strategy is as follows: 
- The ship takes the first box, goes to port 1, then returns to storage. 2 trips.

- The ship takes the second, third and fourth boxes, goes to port 3, then returns to storage. 2 trips.

- The ship takes the fifth box, goes to port 3, then returns to storage. 2 trips.

So the total number of trips is 2 + 2 + 2 = 6.


Example 3:
Input: boxes = [[1,4],[1,2],[2,1],[2,1],[3,2],[3,4]], portsCount = 3, maxBoxes = 6, maxWeight = 7
Output: 6
Explanation: The optimal strategy is as follows:
- The ship takes the first and second boxes, goes to port 1, then returns to storage. 2 trips.

- The ship takes the third and fourth boxes, goes to port 2, then returns to storage. 2 trips.

- The ship takes the fifth and sixth boxes, goes to port 3, then returns to storage. 2 trips.

So the total number of trips is 2 + 2 + 2 = 6.


Example 4:
Input: boxes = [[2,4],[2,5],[3,1],[3,2],[3,7],[3,1],[4,4],[1,3],[5,2]], portsCount = 5, maxBoxes = 5, maxWeight = 7
Output: 14
Explanation: The optimal strategy is as follows:
- The ship takes the first box, goes to port 2, then storage. 2 trips.

- The ship takes the second box, goes to port 2, then storage. 2 trips.

- The ship takes the third and fourth boxes, goes to port 3, then storage. 2 trips.

- The ship takes the fifth box, goes to port 3, then storage. 2 trips.

- The ship takes the sixth and seventh boxes, goes to port 3, then port 4, then storage. 3 trips. 
- The ship takes the eighth and ninth boxes, goes to port 1, then port 5, then storage. 3 trips.

So the total number of trips is 2 + 2 + 2 + 2 + 3 + 3 = 14.


Constraints:
`1 <= boxes.length <= 105`
`1 <= portsCount, maxBoxes, maxWeight <= 105`
`1 <= ports​​i <= portsCount`
`1 <= weightsi <= maxWeight`",0,,35.4,6.4,https://leetcode.com/problems/delivering-boxes-from-storage-to-ports,22,2.1K,6K,Nutanix,"Two Pointers,Dynamic Programming,Segment Tree,Dequeue",129,12,91,0,
354,1691,Maximum Height by Stacking Cuboids,"Given `n` `cuboids` where the dimensions of the `ith` cuboid is `cuboids[i] = [widthi, lengthi, heighti]` (0-indexed). Choose a subset of `cuboids` and place them on each other.

You can place cuboid `i` on cuboid `j` if `widthi <= widthj` and `lengthi <= lengthj` and `heighti <= heightj`. You can rearrange any cuboid's dimensions by rotating it to put it on another cuboid.

Return the maximum height of the stacked `cuboids`.


Example 1:
Input: cuboids = [[50,45,20],[95,37,53],[45,23,12]]
Output: 190
Explanation:
Cuboid 1 is placed on the bottom with the 53x37 side facing down with height 95.

Cuboid 0 is placed next with the 45x20 side facing down with height 50.

Cuboid 2 is placed next with the 23x12 side facing down with height 45.

The total height is 95 + 50 + 45 = 190.


Example 2:
Input: cuboids = [[38,25,45],[76,35,3]]
Output: 76
Explanation:
You can't place any of the cuboids on the other.

We choose cuboid 1 and rotate it so that the 35x3 side is facing down and its height is 76.


Example 3:
Input: cuboids = [[7,11,17],[7,17,11],[11,7,17],[11,17,7],[17,7,11],[17,11,7]]
Output: 102
Explanation:
After rearranging the cuboids, you can see that all cuboids have the same dimension.

You can place the 11x7 side down on all cuboids so their heights are 17.

The maximum height of stacked cuboids is 6 * 17 = 102.


Constraints:
`n == cuboids.length`
`1 <= n <= 100`
`1 <= widthi, lengthi, heighti <= 100`",0,,50.2,20.6,https://leetcode.com/problems/maximum-height-by-stacking-cuboids,79,4.4K,8.8K,Samsung,"Dynamic Programming,Sort",177,8,96,0,
355,1692,Count Ways to Distribute Candies,"There are `n` unique candies (labeled `1` through `n`) and `k` bags. You are asked to distribute all the candies into the bags such that every bag has at least one candy.

There can be multiple ways to distribute the candies. Two ways are considered different if the candies in one bag in the first way are not all in the same bag in the second way. The order of the bags and the order of the candies within each bag do not matter.

For example, `(1), (2,3)` and `(2), (1,3)` are considered different because candies `2` and `3` in the bag `(2,3)` in the first way are not in the same bag in the second way (they are split between the bags `(2)` and `(1,3)`). However, `(1), (2,3)` and `(3,2), (1)` are considered the same because the candies in each bag are all in the same bags in both ways.

Given two integers, `n` and `k`, return the number of different ways to distribute the candies. As the answer may be too large, return it modulo `109 + 7`.


Example 1:
Input: n = 3, k = 2
Output: 3
Explanation: You can distribute 3 candies into 2 bags in 3 ways:
(1), (2,3)
(1,2), (3)
(1,3), (2)

Example 2:
Input: n = 4, k = 2
Output: 7
Explanation: You can distribute 4 candies into 2 bags in 7 ways:
(1), (2,3,4)
(1,2), (3,4)
(1,3), (2,4)
(1,4), (2,3)
(1,2,3), (4)
(1,2,4), (3)
(1,3,4), (2)

Example 3:
Input: n = 20, k = 5
Output: 206085257
Explanation: You can distribute 20 candies into 5 bags in 1881780996 ways. 1881780996 modulo 109 + 7 = 206085257.


Constraints:
`1 <= k <= n <= 1000`",1,,61.6,0.0,https://leetcode.com/problems/count-ways-to-distribute-candies,20,791,1.3K,Google,Dynamic Programming,24,5,83,1,
356,1697,Checking Existence of Edge Length Limited Paths,"An undirected graph of `n` nodes is defined by `edgeList`, where `edgeList[i] = [ui, vi, disi]` denotes an edge between nodes `ui` and `vi` with distance `disi`. Note that there may be multiple edges between two nodes.

Given an array `queries`, where `queries[j] = [pj, qj, limitj]`, your task is to determine for each `queries[j]` whether there is a path between `pj` and `qj` such that each edge on the path has a distance strictly less than `limitj` .

Return a boolean array `answer`, where `answer.length == queries.length` and the `jth` value of `answer` is `true` if there is a path for `queries[j]` is `true`, and `false` otherwise.


Example 1:
Input: n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]]
Output: [false,true]
Explanation: The above figure shows the given graph. Note that there are two overlapping edges between 0 and 1 with distances 2 and 16.

For the first query, between 0 and 1 there is no path where each distance is less than 2, thus we return false for this query.

For the second query, there is a path (0 -> 1 -> 2) of two edges with distances less than 5, thus we return true for this query.


Example 2:
Input: n = 5, edgeList = [[0,1,10],[1,2,5],[2,3,9],[3,4,13]], queries = [[0,4,14],[1,4,13]]
Output: [true,false]
Exaplanation: The above figure shows the given graph.


Constraints:
`2 <= n <= 105`
`1 <= edgeList.length, queries.length <= 105`
`edgeList[i].length == 3`
`queries[j].length == 3`
`0 <= ui, vi, pj, qj <= n - 1`
`ui != vi`
`pj != qj`
`1 <= disi, limitj <= 109`
There may be multiple edges between two nodes.",0,,54.2,16.0,https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths,69,5.4K,9.9K,Google,"Sort,Union Find",266,6,98,1,"[Checking Existence of Edge Length Limited Paths II, /problems/checking-existence-of-edge-length-limited-paths-ii/, Hard]"
357,1703,Minimum Adjacent Swaps for K Consecutive Ones,"You are given an integer array, `nums`, and an integer `k`. `nums` comprises of only `0`'s and `1`'s. In one move, you can choose two adjacent indices and swap their values.

Return the minimum number of moves required so that `nums` has `k` consecutive `1`'s.


Example 1:
Input: nums = [1,0,0,1,0,1], k = 2
Output: 1
Explanation: In 1 move, nums could be [1,0,0,0,1,1] and have 2 consecutive 1's.


Example 2:
Input: nums = [1,0,0,0,0,0,1,1], k = 3
Output: 5
Explanation: In 5 moves, the leftmost 1 can be shifted right until nums = [0,0,0,0,0,1,1,1].


Example 3:
Input: nums = [1,1,0,1], k = 2
Output: 0
Explanation: nums already has 2 consecutive 1's.


Constraints:
`1 <= nums.length <= 105`
`nums[i]` is `0` or `1`.

`1 <= k <= sum(nums)`",0,,40.1,6.8,https://leetcode.com/problems/minimum-adjacent-swaps-for-k-consecutive-ones,38,2.9K,7.1K,Microsoft,Stack,187,6,97,0,"[Minimum Swaps to Group All 1's Together, /problems/minimum-swaps-to-group-all-1s-together/, Medium]"
358,1707,Maximum XOR With an Element From Array,"You are given an array `nums` consisting of non-negative integers. You are also given a `queries` array, where `queries[i] = [xi, mi]`.

The answer to the `ith` query is the maximum bitwise `XOR` value of `xi` and any element of `nums` that does not exceed `mi`. In other words, the answer is `max(nums[j] XOR xi)` for all `j` such that `nums[j] <= mi`. If all elements in `nums` are larger than `mi`, then the answer is `-1`.

Return an integer array `answer` where `answer.length == queries.length` and `answer[i]` is the answer to the `ith` query.


Example 1:
Input: nums = [0,1,2,3,4], queries = [[3,1],[1,3],[5,6]]
Output: [3,3,7]
Explanation:
1) 0 and 1 are the only two integers not greater than 1. 0 XOR 3 = 3 and 1 XOR 3 = 2. The larger of the two is 3.

2) 1 XOR 2 = 3.

3) 5 XOR 2 = 7.


Example 2:
Input: nums = [5,2,4,6,6,3], queries = [[12,4],[8,1],[6,3]]
Output: [15,-1,5]

Constraints:
`1 <= nums.length, queries.length <= 105`
`queries[i].length == 2`
`0 <= nums[j], xi, mi <= 109`",0,,46.4,7.8,https://leetcode.com/problems/maximum-xor-with-an-element-from-array,69,5.1K,10.9K,Google,"Bit Manipulation,Trie",190,10,95,1,"[Maximum XOR of Two Numbers in an Array, /problems/maximum-xor-of-two-numbers-in-an-array/, Medium]"
359,1713,Minimum Operations to Make a Subsequence,"You are given an array `target` that consists of distinct integers and another integer array `arr` that can have duplicates.

In one operation, you can insert any integer at any position in `arr`. For example, if `arr = [1,4,1,2]`, you can add `3` in the middle and make it `[1,4,3,1,2]`. Note that you can insert the integer at the very beginning or end of the array.

Return the minimum number of operations needed to make `target` a subsequence of `arr`.

A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order. For example, `[2,7,4]` is a subsequence of `[4,2,3,7,2,1,4]` (the underlined elements), while `[2,4,2]` is not.


Example 1:
Input: target = [5,1,3], `arr` = [9,4,2,3,4]
Output: 2
Explanation: You can add 5 and 1 in such a way that makes `arr` = [5,9,4,1,2,3,4], then target will be a subsequence of `arr`.


Example 2:
Input: target = [6,4,8,1,3,2], `arr` = [4,7,6,2,3,8,6,1]
Output: 3

Constraints:
`1 <= target.length, arr.length <= 105`
`1 <= target[i], arr[i] <= 109`
`target` contains no duplicates.",0,,45.6,29.8,https://leetcode.com/problems/minimum-operations-to-make-a-subsequence,62,3.9K,8.5K,Google,Greedy,223,3,99,1,
360,1714,Sum Of Special Evenly-Spaced Elements In Array,"You are given a 0-indexed integer array `nums` consisting of `n` non-negative integers.

You are also given an array `queries`, where `queries[i] = [xi, yi]`. The answer to the `ith` query is the sum of all `nums[j]` where `xi <= j < n` and `(j - xi)` is divisible by `yi`.

Return an array `answer` where `answer.length == queries.length` and `answer[i]` is the answer to the `ith` query modulo `109 + 7`.


Example 1:
Input: nums = [0,1,2,3,4,5,6,7], queries = [[0,3],[5,1],[4,2]]
Output: [9,18,10]
Explanation: The answers of the queries are as follows:
1) The j indices that satisfy this query are 0, 3, and 6. nums[0] + nums[3] + nums[6] = 9
2) The j indices that satisfy this query are 5, 6, and 7. nums[5] + nums[6] + nums[7] = 18
3) The j indices that satisfy this query are 4 and 6. nums[4] + nums[6] = 10

Example 2:
Input: nums = [100,200,101,201,102,202,103,203], queries = [[0,7]]
Output: [303]

Constraints:
`n == nums.length`
`1 <= n <= 5 * 104`
`0 <= nums[i] <= 109`
`1 <= queries.length <= 1.5 * 105`
`0 <= xi < n`
`1 <= yi <= 5 * 104`",1,,48.7,0.0,https://leetcode.com/problems/sum-of-special-evenly-spaced-elements-in-array,9,525,1.1K,"MakeMyTrip,Sprinklr",,10,8,56,0,
361,1719,Number Of Ways To Reconstruct A Tree,"You are given an array `pairs`, where `pairs[i] = [xi, yi]`, and:
There are no duplicates.

`xi < yi`
Let `ways` be the number of rooted trees that satisfy the following conditions:
The tree consists of nodes whose values appeared in `pairs`.

A pair `[xi, yi]` exists in `pairs` if and only if `xi` is an ancestor of `yi` or `yi` is an ancestor of `xi`.

Note: the tree does not have to be a binary tree.

Two ways are considered to be different if there is at least one node that has different parents in both ways.

Return:
`0` if `ways == 0`
`1` if `ways == 1`
`2` if `ways > 1`
A rooted tree is a tree that has a single root node, and all edges are oriented to be outgoing from the root.

An ancestor of a node is any node on the path from the root to that node (excluding the node itself). The root has no ancestors.


Example 1:
Input: pairs = [[1,2],[2,3]]
Output: 1
Explanation: There is exactly one valid rooted tree, which is shown in the above figure.


Example 2:
Input: pairs = [[1,2],[2,3],[1,3]]
Output: 2
Explanation: There are multiple valid rooted trees. Three of them are shown in the above figures.


Example 3:
Input: pairs = [[1,2],[2,3],[2,4],[1,5]]
Output: 0
Explanation: There are no valid rooted trees.


Constraints:
`1 <= pairs.length <= 105`
`1 <= xi < yi <= 500`
The elements in `pairs` are unique.",0,,39.5,12.3,https://leetcode.com/problems/number-of-ways-to-reconstruct-a-tree,25,1.5K,3.8K,Uber,"Tree,Graph",64,46,58,0,
362,1723,Find Minimum Time to Finish All Jobs,"You are given an integer array `jobs`, where `jobs[i]` is the amount of time it takes to complete the `ith` job.

There are `k` workers that you can assign jobs to. Each job should be assigned to exactly one worker. The working time of a worker is the sum of the time it takes to complete all jobs assigned to them. Your goal is to devise an optimal assignment such that the maximum working time of any worker is minimized.

Return the minimum possible maximum working time of any assignment. 

Example 1:
Input: jobs = [3,2,3], k = 3
Output: 3
Explanation: By assigning each person one job, the maximum time is 3.


Example 2:
Input: jobs = [1,2,4,7,8], k = 2
Output: 11
Explanation: Assign the jobs the following way:
Worker 1: 1, 2, 8 (working time = 1 + 2 + 8 = 11)
Worker 2: 4, 7 (working time = 4 + 7 = 11)
The maximum working time is 11.


Constraints:
`1 <= k <= jobs.length <= 12`
`1 <= jobs[i] <= 107`",0,,43.7,5.7,https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs,77,7.7K,17.6K,Amazon,"Backtracking,Recursion",211,10,95,1,
363,1724,Checking Existence of Edge Length Limited Paths II,"An undirected graph of `n` nodes is defined by `edgeList`, where `edgeList[i] = [ui, vi, disi]` denotes an edge between nodes `ui` and `vi` with distance `disi`. Note that there may be multiple edges between two nodes, and the graph may not be connected.

Implement the `DistanceLimitedPathsExist` class:
`DistanceLimitedPathsExist(int n, int[][] edgeList)` Initializes the class with an undirected graph.

`boolean query(int p, int q, int limit)` Returns `true` if there exists a path from `p` to `q` such that each edge on the path has a distance strictly less than `limit`, and otherwise `false`.


Example 1:
Input
[""DistanceLimitedPathsExist"", ""query"", ""query"", ""query"", ""query""]
[[6, [[0, 2, 4], [0, 3, 2], [1, 2, 3], [2, 3, 1], [4, 5, 5]]], [2, 3, 2], [1, 3, 3], [2, 0, 3], [0, 5, 6]]
Output
[null, true, false, true, false]
Explanation
DistanceLimitedPathsExist distanceLimitedPathsExist = new DistanceLimitedPathsExist(6, [[0, 2, 4], [0, 3, 2], [1, 2, 3], [2, 3, 1], [4, 5, 5]]);
distanceLimitedPathsExist.query(2, 3, 2); // return true. There is an edge from 2 to 3 of distance 1, which is less than 2.

distanceLimitedPathsExist.query(1, 3, 3); // return false. There is no way to go from 1 to 3 with distances strictly less than 3.

distanceLimitedPathsExist.query(2, 0, 3); // return true. There is a way to go from 2 to 0 with distance < 3: travel from 2 to 3 to 0.

distanceLimitedPathsExist.query(0, 5, 6); // return false. There are no paths from 0 to 5.


`Constraints:`
`2 <= n <= 104`
`0 <= edgeList.length <= 104`
`edgeList[i].length == 3`
`0 <= ui, vi, p, q <= n-1`
`ui != vi`
`p != q`
`1 <= disi, limit <= 109`
At most `104` calls will be made to `query`.",1,,58.0,0.0,https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths-ii,20,888,1.5K,Google,"Dynamic Programming,Union Find,Graph",17,2,89,1,"[Checking Existence of Edge Length Limited Paths, /problems/checking-existence-of-edge-length-limited-paths/, Hard]"
364,1728,Cat and Mouse II,"A game is played by a cat and a mouse named Cat and Mouse.

The environment is represented by a `grid` of size `rows x cols`, where each element is a wall, floor, player (Cat, Mouse), or food.

Players are represented by the characters `'C'`(Cat)`,'M'`(Mouse).

Floors are represented by the character `'.'` and can be walked on.

Walls are represented by the character `'#'` and cannot be walked on.

Food is represented by the character `'F'` and can be walked on.

There is only one of each character `'C'`, `'M'`, and `'F'` in `grid`.

Mouse and Cat play according to the following rules:
Mouse moves first, then they take turns to move.

During each turn, Cat and Mouse can jump in one of the four directions (left, right, up, down). They cannot jump over the wall nor outside of the `grid`.

`catJump, mouseJump` are the maximum lengths Cat and Mouse can jump at a time, respectively. Cat and Mouse can jump less than the maximum length.

Staying in the same position is allowed.

Mouse can jump over Cat.

The game can end in 4 ways:
If Cat occupies the same position as Mouse, Cat wins.

If Cat reaches the food first, Cat wins.

If Mouse reaches the food first, Mouse wins.

If Mouse cannot get to the food within 1000 turns, Cat wins.

Given a `rows x cols` matrix `grid` and two integers `catJump` and `mouseJump`, return `true` if Mouse can win the game if both Cat and Mouse play optimally, otherwise return `false`.


Example 1:
Input: grid = [""####F"",""#C..."",""M....""], catJump = 1, mouseJump = 2
Output: true
Explanation: Cat cannot catch Mouse on its turn nor can it get the food before Mouse.


Example 2:
Input: grid = [""M.C...F""], catJump = 1, mouseJump = 4
Output: true

Example 3:
Input: grid = [""M.C...F""], catJump = 1, mouseJump = 3
Output: false

Example 4:
Input: grid = [""C...#"",""...#F"",""....#"",""M....""], catJump = 2, mouseJump = 5
Output: false

Example 5:
Input: grid = ["".M..."",""..#.."",""#..#."",""C#.#."",""...#F""], catJump = 3, mouseJump = 1
Output: true

Constraints:
`rows == grid.length`
`cols = grid[i].length`
`1 <= rows, cols <= 8`
`grid[i][j]` consist only of characters `'C'`, `'M'`, `'F'`, `'.'`, and `'#'`.

There is only one of each character `'C'`, `'M'`, and `'F'` in `grid`.

`1 <= catJump, mouseJump <= 8`",0,,41.0,0.0,https://leetcode.com/problems/cat-and-mouse-ii,40,3K,7.3K,Google,Dynamic Programming,79,18,81,1,"[Escape The Ghosts, /problems/escape-the-ghosts/, Medium], [Cat and Mouse, /problems/cat-and-mouse/, Hard]"
365,1735,Count Ways to Make Array With Product,"You are given a 2D integer array, `queries`. For each `queries[i]`, where `queries[i] = [ni, ki]`, find the number of different ways you can place positive integers into an array of size `ni` such that the product of the integers is `ki`. As the number of ways may be too large, the answer to the `ith` query is the number of ways modulo `109 + 7`.

Return an integer array `answer` where `answer.length == queries.length`, and `answer[i]` is the answer to the `ith` query.


Example 1:
Input: queries = [[2,6],[5,1],[73,660]]
Output: [4,1,50734910]
Explanation: Each query is independent.

[2,6]: There are 4 ways to fill an array of size 2 that multiply to 6: [1,6], [2,3], [3,2], [6,1].

[5,1]: There is 1 way to fill an array of size 5 that multiply to 1: [1,1,1,1,1].

[73,660]: There are 1050734917 ways to fill an array of size 73 that multiply to 660. 1050734917 modulo 109 + 7 = 50734910.


Example 2:
Input: queries = [[1,1],[2,2],[3,3],[4,4],[5,5]]
Output: [1,2,3,10,5]

Constraints:
`1 <= queries.length <= 104 `
`1 <= ni, ki <= 104`",0,,47.9,0.0,https://leetcode.com/problems/count-ways-to-make-array-with-product,31,2.1K,4.4K,Amazon,Math,92,20,82,1,
366,1739,Building Boxes,"You have a cubic storeroom where the width, length, and height of the room are all equal to `n` units. You are asked to place `n` boxes in this room where each box is a cube of unit side length. There are however some rules to placing the boxes:
You can place the boxes anywhere on the floor.

If box `x` is placed on top of the box `y`, then each side of the four vertical sides of the box `y` must either be adjacent to another box or to a wall.

Given an integer `n`, return the minimum possible number of boxes touching the floor.


Example 1:
Input: n = 3
Output: 3
Explanation: The figure above is for the placement of the three boxes.

These boxes are placed in the corner of the room, where the corner is on the left side.


Example 2:
Input: n = 4
Output: 3
Explanation: The figure above is for the placement of the four boxes.

These boxes are placed in the corner of the room, where the corner is on the left side.


Example 3:
Input: n = 10
Output: 6
Explanation: The figure above is for the placement of the ten boxes.

These boxes are placed in the corner of the room, where the corner is on the back side.


Constraints:
`1 <= n <= 109`",0,,49.6,11.2,https://leetcode.com/problems/building-boxes,62,3.3K,6.7K,Codenation,"Math,Binary Search",130,22,86,0,
367,1745,Palindrome Partitioning IV,"Given a string `s`, return `true` if it is possible to split the string `s` into three non-empty palindromic substrings. Otherwise, return `false`.​​​​​
A string is said to be palindrome if it the same string when reversed.


Example 1:
Input: s = ""abcbdd""
Output: true
Explanation: ""abcbdd"" = ""a"" + ""bcb"" + ""dd"", and all three substrings are palindromes.


Example 2:
Input: s = ""bcbddxy""
Output: false
Explanation: s cannot be split into 3 palindromes.


Constraints:
`3 <= s.length <= 2000`
`s`​​​​​​ consists only of lowercase English letters.",0,,49.5,4.3,https://leetcode.com/problems/palindrome-partitioning-iv,115,7.4K,15K,tcs,"String,Dynamic Programming",204,4,98,0,"[Palindrome Partitioning, /problems/palindrome-partitioning/, Medium], [Palindrome Partitioning II, /problems/palindrome-partitioning-ii/, Hard], [Palindrome Partitioning III, /problems/palindrome-partitioning-iii/, Hard]"
368,1751,Maximum Number of Events That Can Be Attended II,"You are given an array of `events` where `events[i] = [startDayi, endDayi, valuei]`. The `ith` event starts at `startDayi` and ends at `endDayi`, and if you attend this event, you will receive a value of `valuei`. You are also given an integer `k` which represents the maximum number of events you can attend.

You can only attend one event at a time. If you choose to attend an event, you must attend the entire event. Note that the end day is inclusive: that is, you cannot attend two events where one of them starts and the other ends on the same day.

Return the maximum sum of values that you can receive by attending events.


Example 1:
Input: events = [[1,2,4],[3,4,3],[2,3,1]], k = 2
Output: 7
Explanation: Choose the green events, 0 and 1 (0-indexed) for a total value of 4 + 3 = 7.


Example 2:
Input: events = [[1,2,4],[3,4,3],[2,3,10]], k = 2
Output: 10
Explanation: Choose event 2 for a total value of 10.

Notice that you cannot attend any other event as they overlap, and that you do not have to attend k events.


Example 3:
Input: events = [[1,1,1],[2,2,2],[3,3,3],[4,4,4]], k = 3
Output: 9
Explanation: Although the events do not overlap, you can only attend 3 events. Pick the highest valued three.


Constraints:
`1 <= k <= events.length`
`1 <= k * events.length <= 106`
`1 <= startDayi <= endDayi <= 109`
`1 <= valuei <= 106`",0,,48.1,10.0,https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii,80,4.7K,9.7K,Amazon,"Binary Search,Dynamic Programming",179,3,98,1,"[Maximum Number of Events That Can Be Attended, /problems/maximum-number-of-events-that-can-be-attended/, Medium]"
369,1755,Closest Subsequence Sum,"You are given an integer array `nums` and an integer `goal`.

You want to choose a subsequence of `nums` such that the sum of its elements is the closest possible to `goal`. That is, if the sum of the subsequence's elements is `sum`, then you want to minimize the absolute difference `abs(sum - goal)`.

Return the minimum possible value of `abs(sum - goal)`.

Note that a subsequence of an array is an array formed by removing some elements (possibly all or none) of the original array.


Example 1:
Input: nums = [5,-7,3,5], goal = 6
Output: 0
Explanation: Choose the whole array as a subsequence, with a sum of 6.

This is equal to the goal, so the absolute difference is 0.


Example 2:
Input: nums = [7,-9,15,-2], goal = -5
Output: 1
Explanation: Choose the subsequence [7,-9,-2], with a sum of -4.

The absolute difference is abs(-4 - (-5)) = abs(1) = 1, which is the minimum.


Example 3:
Input: nums = [1,2,3], goal = -7
Output: 7

Constraints:
`1 <= nums.length <= 40`
`-107 <= nums[i] <= 107`
`-109 <= goal <= 109`",0,,35.7,2.7,https://leetcode.com/problems/closest-subsequence-sum,67,4.5K,12.6K,Sprinklr,"Divide and Conquer,Meet in the Middle",185,40,82,0,
370,1761,Minimum Degree of a Connected Trio in a Graph,"You are given an undirected graph. You are given an integer `n` which is the number of nodes in the graph and an array `edges`, where each `edges[i] = [ui, vi]` indicates that there is an undirected edge between `ui` and `vi`.

A connected trio is a set of three nodes where there is an edge between every pair of them.

The degree of a connected trio is the number of edges where one endpoint is in the trio, and the other is not.

Return the minimum degree of a connected trio in the graph, or `-1` if the graph has no connected trios.


Example 1:
Input: n = 6, edges = [[1,2],[1,3],[3,2],[4,1],[5,2],[3,6]]
Output: 3
Explanation: There is exactly one trio, which is [1,2,3]. The edges that form its degree are bolded in the figure above.


Example 2:
Input: n = 7, edges = [[1,3],[4,1],[4,3],[2,5],[5,6],[6,7],[7,5],[2,6]]
Output: 0
Explanation: There are exactly three trios:
1) [1,4,3] with degree 0.

2) [2,5,6] with degree 2.

3) [5,6,7] with degree 2.


Constraints:
`2 <= n <= 400`
`edges[i].length == 2`
`1 <= edges.length <= n * (n-1) / 2`
`1 <= ui, vi <= n`
`ui != vi`
There are no repeated edges.",0,,37.5,17.3,https://leetcode.com/problems/minimum-degree-of-a-connected-trio-in-a-graph,77,5.8K,15.5K,Amazon,Graph,65,118,36,1,
371,1766,Tree of Coprimes,"There is a tree (i.e., a connected, undirected graph that has no cycles) consisting of `n` nodes numbered from `0` to `n - 1` and exactly `n - 1` edges. Each node has a value associated with it, and the root of the tree is node `0`.

To represent this tree, you are given an integer array `nums` and a 2D array `edges`. Each `nums[i]` represents the `ith` node's value, and each `edges[j] = [uj, vj]` represents an edge between nodes `uj` and `vj` in the tree.

Two values `x` and `y` are coprime if `gcd(x, y) == 1` where `gcd(x, y)` is the greatest common divisor of `x` and `y`.

An ancestor of a node `i` is any other node on the shortest path from node `i` to the root. A node is not considered an ancestor of itself.

Return an array `ans` of size `n`, where `ans[i]` is the closest ancestor to node `i` such that `nums[i]` and `nums[ans[i]]` are coprime, or `-1` if there is no such ancestor.


Example 1:
Input: nums = [2,3,3,2], edges = [[0,1],[1,2],[1,3]]
Output: [-1,0,0,1]
Explanation: In the above figure, each node's value is in parentheses.

- Node 0 has no coprime ancestors.

- Node 1 has only one ancestor, node 0. Their values are coprime (gcd(2,3) == 1).

- Node 2 has two ancestors, nodes 1 and 0. Node 1's value is not coprime (gcd(3,3) == 3), but node 0's
  value is (gcd(2,3) == 1), so node 0 is the closest valid ancestor.

- Node 3 has two ancestors, nodes 1 and 0. It is coprime with node 1 (gcd(3,2) == 1), so node 1 is its
  closest valid ancestor.


Example 2:
Input: nums = [5,6,10,2,3,6,15], edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]]
Output: [-1,0,-1,0,0,0,-1]

Constraints:
`nums.length == n`
`1 <= nums[i] <= 50`
`1 <= n <= 105`
`edges.length == n - 1`
`edges[j].length == 2`
`0 <= uj, vj < n`
`uj != vj`",0,,36.7,2.8,https://leetcode.com/problems/tree-of-coprimes,55,2.8K,7.6K,Google,"Math,Tree,Depth-first Search,Breadth-first Search",119,8,94,1,
372,1767,Find the Subtasks That Did Not Execute,SQL Schema,1,,87.7,0.0,https://leetcode.com/problems/find-the-subtasks-that-did-not-execute,57,965,1.1K,Google,,26,1,96,1,
373,1771,Maximize Palindrome Length From Subsequences,"You are given two strings, `word1` and `word2`. You want to construct a string in the following manner:
Choose some non-empty subsequence `subsequence1` from `word1`.

Choose some non-empty subsequence `subsequence2` from `word2`.

Concatenate the subsequences: `subsequence1 + subsequence2`, to make the string.

Return the length of the longest palindrome that can be constructed in the described manner. If no palindromes can be constructed, return `0`.

A subsequence of a string `s` is a string that can be made by deleting some (possibly none) characters from `s` without changing the order of the remaining characters.

A palindrome is a string that reads the same forward as well as backward.


Example 1:
Input: word1 = ""cacb"", word2 = ""cbba""
Output: 5
Explanation: Choose ""ab"" from word1 and ""cba"" from word2 to make ""abcba"", which is a palindrome.


Example 2:
Input: word1 = ""ab"", word2 = ""ab""
Output: 3
Explanation: Choose ""ab"" from word1 and ""a"" from word2 to make ""aba"", which is a palindrome.


Example 3:
Input: word1 = ""aa"", word2 = ""bb""
Output: 0
Explanation: You cannot construct a palindrome from the described method, so return 0.


Constraints:
`1 <= word1.length, word2.length <= 1000`
`word1` and `word2` consist of lowercase English letters.",0,,34.1,4.4,https://leetcode.com/problems/maximize-palindrome-length-from-subsequences,84,4.6K,13.4K,Goldman Sachs,Dynamic Programming,182,5,97,0,"[Longest Palindromic Subsequence, /problems/longest-palindromic-subsequence/, Medium]"
374,1776,Car Fleet II,"There are `n` cars traveling at different speeds in the same direction along a one-lane road. You are given an array `cars` of length `n`, where `cars[i] = [positioni, speedi]` represents:
`positioni` is the distance between the `ith` car and the beginning of the road in meters. It is guaranteed that `positioni < positioni+1`.

`speedi` is the initial speed of the `ith` car in meters per second.

For simplicity, cars can be considered as points moving along the number line. Two cars collide when they occupy the same position. Once a car collides with another car, they unite and form a single car fleet. The cars in the formed fleet will have the same position and the same speed, which is the initial speed of the slowest car in the fleet.

Return an array `answer`, where `answer[i]` is the time, in seconds, at which the `ith` car collides with the next car, or `-1` if the car does not collide with the next car. Answers within `10-5` of the actual answers are accepted.


Example 1:
Input: cars = [[1,2],[2,1],[4,3],[7,2]]
Output: [1.00000,-1.00000,3.00000,-1.00000]
Explanation: After exactly one second, the first car will collide with the second car, and form a car fleet with speed 1 m/s. After exactly 3 seconds, the third car will collide with the fourth car, and form a car fleet with speed 2 m/s.


Example 2:
Input: cars = [[3,4],[5,4],[6,3],[9,1]]
Output: [2.00000,1.00000,1.50000,-1.00000]

Constraints:
`1 <= cars.length <= 105`
`1 <= positioni, speedi <= 106`
`positioni < positioni+1`",0,,46.5,16.6,https://leetcode.com/problems/car-fleet-ii,62,3.8K,8.2K,Google,Math,167,4,98,1,"[Car Fleet, /problems/car-fleet/, Medium]"
375,1782,Count Pairs Of Nodes,"You are given an undirected graph represented by an integer `n`, which is the number of nodes, and `edges`, where `edges[i] = [ui, vi]` which indicates that there is an undirected edge between `ui` and `vi`. You are also given an integer array `queries`.

The answer to the `jth` query is the number of pairs of nodes `(a, b)` that satisfy the following conditions:
`a < b`
`cnt` is strictly greater than `queries[j]`, where `cnt` is the number of edges incident to `a` or `b`.

Return an array `answers` such that `answers.length == queries.length` and `answers[j]` is the answer of the `jth` query.

Note that there can be repeated edges.


Example 1:
Input: n = 4, edges = [[1,2],[2,4],[1,3],[2,3],[2,1]], queries = [2,3]
Output: [6,5]
Explanation: The number of edges incident to at least one of each pair is shown above.


Example 2:
Input: n = 5, edges = [[1,5],[1,5],[3,4],[2,5],[1,3],[5,1],[2,3],[2,5]], queries = [1,2,3,4,5]
Output: [10,10,9,8,6]

Constraints:
`2 <= n <= 2 * 104`
`1 <= edges.length <= 105`
`1 <= ui, vi <= n`
`ui != vi`
`1 <= queries.length <= 20`
`0 <= queries[j] < edges.length`",0,,32.4,1.1,https://leetcode.com/problems/count-pairs-of-nodes,39,2.2K,6.7K,Google,Graph,101,77,57,1,
376,1787,Make the XOR of All Segments Equal to Zero,"You are given an array `nums`​​​ and an integer `k`​​​​​. The XOR of a segment `[left, right]` where `left <= right` is the `XOR` of all the elements with indices between `left` and `right`, inclusive: `nums[left] XOR nums[left+1] XOR ... XOR nums[right]`.

Return the minimum number of elements to change in the array such that the `XOR` of all segments of size `k`​​​​​​ is equal to zero.


Example 1:
Input: nums = [1,2,0,3,0], k = 1
Output: 3
Explanation: Modify the array from [1,2,0,3,0] to from [0,0,0,0,0].


Example 2:
Input: nums = [3,4,5,2,1,7,3,4,7], k = 3
Output: 3
Explanation: Modify the array from [3,4,5,2,1,7,3,4,7] to [3,4,7,3,4,7,3,4,7].


Example 3:
Input: nums = [1,2,4,1,2,5,1,2,6], k = 3
Output: 3
Explanation: Modify the array from [1,2,4,1,2,5,1,2,6] to [1,2,3,1,2,3,1,2,3].


Constraints:
`1 <= k <= nums.length <= 2000`
`​​​​​​0 <= nums[i] < 210`",0,,36.6,2.3,https://leetcode.com/problems/make-the-xor-of-all-segments-equal-to-zero,34,2.1K,5.8K,"Media.net,codeagon",Dynamic Programming,144,6,96,0,
377,1788,Maximize the Beauty of the Garden,"There is a garden of `n` flowers, and each flower has an integer beauty value. The flowers are arranged in a line. You are given an integer array `flowers` of size `n` and each `flowers[i]` represents the beauty of the `ith` flower.

A garden is valid if it meets these conditions:
The garden has at least two flowers.

The first and the last flower of the garden have the same beauty value.

As the appointed gardener, you have the ability to remove any (possibly none) flowers from the garden. You want to remove flowers in a way that makes the remaining garden valid. The beauty of the garden is the sum of the beauty of all the remaining flowers.

Return the maximum possible beauty of some valid garden after you have removed any (possibly none) flowers.


Example 1:
Input: flowers = [1,2,3,1,2]
Output: 8
Explanation: You can produce the valid garden [2,3,1,2] to have a total beauty of 2 + 3 + 1 + 2 = 8.


Example 2:
Input: flowers = [100,1,1,-3,1]
Output: 3
Explanation: You can produce the valid garden [1,1,1] to have a total beauty of 1 + 1 + 1 = 3.


Example 3:
Input: flowers = [-1,-2,0,-1]
Output: -2
Explanation: You can produce the valid garden [-1,-1] to have a total beauty of -1 + -1 = -2.


Constraints:
`2 <= flowers.length <= 105`
`-104 <= flowers[i] <= 104`
It is possible to create a valid garden by removing some (possibly none) flowers.",1,,69.9,0.0,https://leetcode.com/problems/maximize-the-beauty-of-the-garden,22,599,854,Amazon,Greedy,18,4,82,1,
378,1793,Maximum Score of a Good Subarray,"You are given an array of integers `nums` (0-indexed) and an integer `k`.

The score of a subarray `(i, j)` is defined as `min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1)`. A good subarray is a subarray where `i <= k <= j`.

Return the maximum possible score of a good subarray.


Example 1:
Input: nums = [1,4,3,7,4,5], k = 3
Output: 15
Explanation: The optimal subarray is (1, 5) with a score of min(4,3,7,4,5) * (5-1+1) = 3 * 5 = 15. 

Example 2:
Input: nums = [5,5,4,5,4,1,1,1], k = 0
Output: 20
Explanation: The optimal subarray is (0, 4) with a score of min(5,5,4,5,4) * (4-0+1) = 4 * 5 = 20.


Constraints:
`1 <= nums.length <= 105`
`1 <= nums[i] <= 2 * 104`
`0 <= k < nums.length`",0,,46.2,1.1,https://leetcode.com/problems/maximum-score-of-a-good-subarray,118,5.8K,12.6K,Google,Greedy,231,14,94,1,"[Largest Rectangle in Histogram, /problems/largest-rectangle-in-histogram/, Hard]"
379,1799,Maximize Score After N Operations,"You are given `nums`, an array of positive integers of size `2 * n`. You must perform `n` operations on this array.

In the `ith` operation (1-indexed), you will:
Choose two elements, `x` and `y`.

Receive a score of `i * gcd(x, y)`.

Remove `x` and `y` from `nums`.

Return the maximum score you can receive after performing `n` operations.

The function `gcd(x, y)` is the greatest common divisor of `x` and `y`.


Example 1:
Input: nums = [1,2]
Output: 1
Explanation: The optimal choice of operations is:
(1 * gcd(1, 2)) = 1

Example 2:
Input: nums = [3,4,6,8]
Output: 11
Explanation: The optimal choice of operations is:
(1 * gcd(3, 6)) + (2 * gcd(4, 8)) = 3 + 8 = 11

Example 3:
Input: nums = [1,2,3,4,5,6]
Output: 14
Explanation: The optimal choice of operations is:
(1 * gcd(1, 5)) + (2 * gcd(2, 4)) + (3 * gcd(3, 6)) = 1 + 4 + 9 = 14

Constraints:
`1 <= n <= 7`
`nums.length == 2 * n`
`1 <= nums[i] <= 106`",0,,50.4,4.7,https://leetcode.com/problems/maximize-score-after-n-operations,68,4K,7.8K,Amazon,"Dynamic Programming,Backtracking,Recursion",127,7,95,1,
380,1803,Count Pairs With XOR in a Range,"Given a (0-indexed) integer array `nums` and two integers `low` and `high`, return the number of nice pairs.

A nice pair is a pair `(i, j)` where `0 <= i < j < nums.length` and `low <= (nums[i] XOR nums[j]) <= high`.


Example 1:
Input: nums = [1,4,2,7], low = 2, high = 6
Output: 6
Explanation: All nice pairs (i, j) are as follows:
    - (0, 1): nums[0] XOR nums[1] = 5 
    - (0, 2): nums[0] XOR nums[2] = 3
    - (0, 3): nums[0] XOR nums[3] = 6
    - (1, 2): nums[1] XOR nums[2] = 6
    - (1, 3): nums[1] XOR nums[3] = 3
    - (2, 3): nums[2] XOR nums[3] = 5

Example 2:
Input: nums = [9,8,4,2,1], low = 5, high = 14
Output: 8
Explanation: All nice pairs (i, j) are as follows:
​​​​​    - (0, 2): nums[0] XOR nums[2] = 13
    - (0, 3): nums[0] XOR nums[3] = 11
    - (0, 4): nums[0] XOR nums[4] = 8
    - (1, 2): nums[1] XOR nums[2] = 12
    - (1, 3): nums[1] XOR nums[3] = 10
    - (1, 4): nums[1] XOR nums[4] = 9
    - (2, 3): nums[2] XOR nums[3] = 6
    - (2, 4): nums[2] XOR nums[4] = 5

Constraints:
`1 <= nums.length <= 2 * 104`
`1 <= nums[i] <= 2 * 104`
`1 <= low <= high <= 2 * 104`",0,,43.1,0.3,https://leetcode.com/problems/count-pairs-with-xor-in-a-range,37,2.7K,6.2K,Vimeo,Trie,122,8,94,0,
381,1808,Maximize Number of Nice Divisors,"You are given a positive integer `primeFactors`. You are asked to construct a positive integer `n` that satisfies the following conditions:
The number of prime factors of `n` (not necessarily distinct) is at most `primeFactors`.

The number of nice divisors of `n` is maximized. Note that a divisor of `n` is nice if it is divisible by every prime factor of `n`. For example, if `n = 12`, then its prime factors are `[2,2,3]`, then `6` and `12` are nice divisors, while `3` and `4` are not.

Return the number of nice divisors of `n`. Since that number can be too large, return it modulo `109 + 7`.

Note that a prime number is a natural number greater than `1` that is not a product of two smaller natural numbers. The prime factors of a number `n` is a list of prime numbers such that their product equals `n`.


Example 1:
Input: primeFactors = 5
Output: 6
Explanation: 200 is a valid value of n.

It has 5 prime factors: [2,2,2,5,5], and it has 6 nice divisors: [10,20,40,50,100,200].

There is not other value of n that has at most 5 prime factors and more nice divisors.


Example 2:
Input: primeFactors = 8
Output: 18

Constraints:
`1 <= primeFactors <= 109`",0,,27.3,0.0,https://leetcode.com/problems/maximize-number-of-nice-divisors,51,3.1K,11.4K,Microsoft,Math,95,103,48,0,"[Integer Break, /problems/integer-break/, Medium]"
382,1815,Maximum Number of Groups Getting Fresh Donuts,"There is a donuts shop that bakes donuts in batches of `batchSize`. They have a rule where they must serve all of the donuts of a batch before serving any donuts of the next batch. You are given an integer `batchSize` and an integer array `groups`, where `groups[i]` denotes that there is a group of `groups[i]` customers that will visit the shop. Each customer will get exactly one donut.

When a group visits the shop, all customers of the group must be served before serving any of the following groups. A group will be happy if they all get fresh donuts. That is, the first customer of the group does not receive a donut that was left over from the previous group.

You can freely rearrange the ordering of the groups. Return the maximum possible number of happy groups after rearranging the groups.


Example 1:
Input: batchSize = 3, groups = [1,2,3,4,5,6]
Output: 4
Explanation: You can arrange the groups as [6,2,4,5,1,3]. Then the 1st, 2nd, 4th, and 6th groups will be happy.


Example 2:
Input: batchSize = 4, groups = [1,3,2,5,2,2,1,6]
Output: 4

Constraints:
`1 <= batchSize <= 9`
`1 <= groups.length <= 30`
`1 <= groups[i] <= 109`",0,,35.7,0.0,https://leetcode.com/problems/maximum-number-of-groups-getting-fresh-donuts,27,2.1K,5.4K,Google,Dynamic Programming,94,8,92,1,
383,1819,Number of Different Subsequences GCDs,"You are given an array `nums` that consists of positive integers.

The GCD of a sequence of numbers is defined as the greatest integer that divides all the numbers in the sequence evenly.

For example, the GCD of the sequence `[4,6,16]` is `2`.

A subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array.

For example, `[2,5,10]` is a subsequence of `[1,2,1,2,4,1,5,10]`.

Return the number of different GCDs among all non-empty subsequences of `nums`.


Example 1:
Input: nums = [6,10,3]
Output: 5
Explanation: The figure shows all the non-empty subsequences and their GCDs.

The different GCDs are 6, 10, 3, 2, and 1.


Example 2:
Input: nums = [5,15,40,5,6]
Output: 7

Constraints:
`1 <= nums.length <= 105`
`1 <= nums[i] <= 2 * 105`",0,,29.2,0.0,https://leetcode.com/problems/number-of-different-subsequences-gcds,51,2.9K,9.7K,Akuna Capital,Math,131,29,82,0,
384,1825,Finding MK Average,"You are given two integers, `m` and `k`, and a stream of integers. You are tasked to implement a data structure that calculates the MKAverage for the stream.

The MKAverage can be calculated using these steps:
If the number of the elements in the stream is less than `m` you should consider the MKAverage to be `-1`. Otherwise, copy the last `m` elements of the stream to a separate container.

Remove the smallest `k` elements and the largest `k` elements from the container.

Calculate the average value for the rest of the elements rounded down to the nearest integer.

Implement the `MKAverage` class:
`MKAverage(int m, int k)` Initializes the MKAverage object with an empty stream and the two integers `m` and `k`.

`void addElement(int num)` Inserts a new element `num` into the stream.

`int calculateMKAverage()` Calculates and returns the MKAverage for the current stream rounded down to the nearest integer.


Example 1:
Input
[""MKAverage"", ""addElement"", ""addElement"", ""calculateMKAverage"", ""addElement"", ""calculateMKAverage"", ""addElement"", ""addElement"", ""addElement"", ""calculateMKAverage""]
[[3, 1], [3], [1], [], [10], [], [5], [5], [5], []]
Output
[null, null, null, -1, null, 3, null, null, null, 5]
Explanation
MKAverage obj = new MKAverage(3, 1); 
obj.addElement(3);        // current elements are [3]
obj.addElement(1);        // current elements are [3,1]
obj.calculateMKAverage(); // return -1, because m = 3 and only 2 elements exist.

obj.addElement(10);       // current elements are [3,1,10]
obj.calculateMKAverage(); // The last 3 elements are [3,1,10].

                          // After removing smallest and largest 1 element the container will be `[3].

                          // The average of [3] equals 3/1 = 3, return 3
obj.addElement(5);        // current elements are [3,1,10,5]
obj.addElement(5);        // current elements are [3,1,10,5,5]
obj.addElement(5);        // current elements are [3,1,10,5,5,5]
obj.calculateMKAverage(); // The last 3 elements are [5,5,5].

                          // After removing smallest and largest 1 element the container will be `[5].

                          // The average of [5] equals 5/1 = 5, return 5
``

Constraints:
`3 <= m <= 105`
`1 <= k*2 < m`
`1 <= num <= 105`
At most `105` calls will be made to `addElement` and `calculateMKAverage`.",0,,28.1,0.0,https://leetcode.com/problems/finding-mk-average,48,2.1K,7.4K,Google,"Heap,Design,Queue",52,43,55,1,"[Find Median from Data Stream, /problems/find-median-from-data-stream/, Hard], [Kth Largest Element in a Stream, /problems/kth-largest-element-in-a-stream/, Easy]"
